# 18. Templates

- [18. Templates](#18-templates)
  - [18.1 Overview](#181-overview)
  - [18.2 Template Declarations](#182-template-declarations)
    - [18.2.1 Basic Form: `definition` Block with `let` Parameters](#1821-basic-form-definition-block-with-let-parameters)
    - [18.2.2 Type Parameters](#1822-type-parameters)
    - [18.2.3 Predicate Parameters](#1823-predicate-parameters)
    - [18.2.4 Functor Parameters](#1824-functor-parameters)
    - [18.2.5 Constrained Parameters](#1825-constrained-parameters)
    - [18.2.6 Scoping Rules](#1826-scoping-rules)
  - [18.3 Template for Attributes (attr)](#183-template-for-attributes-attr)
  - [18.4 Template for Modes (mode)](#184-template-for-modes-mode)
  - [18.5 Template for Structures (struct)](#185-template-for-structures-struct)
  - [18.6 Template for Predicates (pred)](#186-template-for-predicates-pred)
  - [18.7 Template for Functors (func)](#187-template-for-functors-func)
  - [18.8 Parameterized Theorems and Schemes](#188-parameterized-theorems-and-schemes)
    - [18.8.1 When Templates Are Not Needed](#1881-when-templates-are-not-needed)
    - [18.8.2 Predicate-Parameterized Theorems (Schemes)](#1882-predicate-parameterized-theorems-schemes)
    - [18.8.3 Functor-Parameterized Theorems](#1883-functor-parameterized-theorems)
    - [18.8.4 Mixed-Parameter Theorems](#1884-mixed-parameter-theorems)
  - [18.9 Scheme Application in Proofs](#189-scheme-application-in-proofs)
  - [18.10 Logic Encoding Details](#1810-logic-encoding-details)
    - [18.10.1 Templates as Axiom Schemas](#18101-templates-as-axiom-schemas)
    - [18.10.2 Type Parameter Encoding](#18102-type-parameter-encoding)
    - [18.10.3 Predicate Parameter Encoding](#18103-predicate-parameter-encoding)
    - [18.10.4 Functor Parameter Encoding](#18104-functor-parameter-encoding)
    - [18.10.5 Constraint Encoding](#18105-constraint-encoding)
  - [18.11 Complete Syntax (EBNF)](#1811-complete-syntax-ebnf)

## 18.1 Overview

Templates are the **generics mechanism** of Mizar-Evo — a facility for writing mathematical definitions and theorem schemas parameterized by types, predicates, or functions. A template captures a pattern of mathematical reasoning that is valid across a family of instances.

Templates serve two distinct roles:

1. **Parameterized Definitions**: Define attributes, modes, structures, predicates, and functors over abstract type parameters. For example, a generic `VectorSpace[K]` template can be instantiated for real numbers, complex numbers, or any field K; a `PolyRing[R]` template generates the polynomial ring over any commutative ring R.

2. **Theorem Schemas (Schemes)**: State theorems parameterized by predicates or functions — the primary mechanism for induction, recursion, and universal structural properties. These subsume the classical Mizar `scheme` construct.

**When templates are needed**

| Situation | Approach |
|---|---|
| Theorem quantified over types only | Ordinary universally quantified theorem — no template needed |
| Definition (struct, mode, attr, func, pred) parameterized by a type | Template (`definition` block with `let` type parameters) |
| Theorem parameterized by a predicate or functor | Template with `let P be pred(T);` or `let F be func(T) -> S;` |

**Relationship to the `of`/`over` Syntax**

The `of`/`over` parameterization in modes (Chapter 5) and structures (Chapter 7) is **syntactic sugar** for single-parameter type templates. Both forms are accepted:

```mizar
:: Shorthand (Chapter 5 syntax — preferred for simple single parameters)
definition
  mode Subset of X is X-subset_like set;
end;

:: Equivalent full template form
definition
  let X be type;
  mode Subset[X] is X-subset_like set;
  :: Automatic synonym: Subset of X
end;
```

For simple modes, the `of`/`over` shorthand is preferred. Multi-parameter and constrained templates require the full form.

**Relationship to Classical Mizar Schemes**

Classical Mizar `scheme` declarations are unified with the general template system in Mizar-Evo. A `definition` block containing `let P be pred(T);` and a `theorem` item subsumes the `scheme` mechanism using consistent syntax.

> [!NOTE]
> For reasoning patterns that apply template theorems (e.g., natural number induction, structural induction), see [Chapter 19 (Reasoning Patterns)](./19.reasoning_patterns.md).

## 18.2 Template Declarations

### 18.2.1 Basic Form: `definition` Block with `let` Parameters

A template is a `definition` block whose leading items are `let` declarations establishing the template parameters. All items in the block share the scope of these parameter declarations. This extends the standard Mizar scoping rule — where `let IT be multMagma;` at the top of a `definition` block scopes over all `attr` items in that block — to multi-item template definitions.

**Syntax (EBNF):**

```ebnf
template_def    ::= "definition"
                    { let_param }
                    { template_item }
                    "end" ";" ;

let_param       ::= "let" identifier_list "be" type_expression
                    [ "such" "that" formula ( "by" label_ref_list | proof ) ]
                    ";" ;

template_item   ::= attr_def
                  | mode_def
                  | struct_def
                  | pred_def
                  | func_def
                  | theorem_item
                  | registration_item ;
```

**Example — Parameterized magma structure:**

```mizar
definition
  let T be type;
  struct Magma[T] where
    field carrier -> T;
    field binop -> BinOp of T;
  end;
end;
```

The parameterized name `Magma[T]` uses `[...]` brackets to indicate that the name carries a type argument. This bracket notation is **reserved** for parameterized template names and scheme application; it must not be used for other purposes (such as list indexing).

Automatic synonyms are generated where applicable:

- `Module over R` becomes a synonym for `Module[R]` (single struct parameter)
- `Subset of X` becomes a synonym for `Subset[X]` (single mode parameter)

### 18.2.2 Type Parameters

`let X be <type>;` declares a **type parameter** ranging over types (modes or structures).

| Declaration | Meaning |
|---|---|
| `let T be type;` | T is any type |
| `let G be Group;` | G must satisfy the `Group` mode |
| `let R be commutative Ring;` | R must be a commutative Ring |

```mizar
:: Single type parameter: polynomial ring over a commutative ring
definition
  let R be commutative Ring;
  struct PolyRing[R] where
    field carrier -> non empty set;   :: the underlying set of polynomials
    field add -> BinOp of carrier;
    field mul -> BinOp of carrier;
    field coeff -> Function of [:carrier, Nat:], R.carrier;
  end;
  :: Automatic synonym: PolyRing over R
end;

:: Two type parameters: generic homomorphism mode
definition
  let G be Group;
  let H be Group;
  mode Homomorphism[G,H] is
    operation_preserving Function of G.carrier, H.carrier;
  :: Automatic synonym: Homomorphism of G, H
end;
```

### 18.2.3 Predicate Parameters

`let P be pred(T₁, ..., Tₙ);` declares a **predicate parameter** ranging over n-ary predicates. Predicate parameters are valid only within `theorem` items in the same `definition` block.

Predicate parameters follow the `defpred` convention: applied as `P(t₁, ..., tₙ)` inside theorem bodies.

```mizar
definition
  let P be pred(Nat);
  theorem NatInduction:
    (for n being Nat holds P(n))
  provided
    Base: P(0) and
    Step: for n being Nat st P(n) holds P(n+1)
  proof
    assume Base and Step;
    let n be Nat;
    thus P(n) by Base, Step, mml.number.natural.Nat_induction;
  end;
end;
```

> [!NOTE]
> Predicate parameters represent **second-order quantification** at the meta-level. In the underlying first-order logic, each instantiation of a predicate parameter generates a distinct first-order axiom. See §18.10.3.

### 18.2.4 Functor Parameters

`let F be func(T₁, ..., Tₙ) -> S;` declares a **functor parameter** ranging over functions of the given signature. Functor parameters are valid only within `theorem` items in the same `definition` block.

Functor parameters follow the `deffunc` convention: applied as `F(t)` inside theorem bodies.

```mizar
definition
  let A be type;
  let F be func(A) -> A;
  let P be pred(A);
  theorem Invariant:
    (for x being A holds P(F(x)))
  provided
    Base: P(x0) and
    Step: for x being A st P(x) holds P(F(x))
  proof
    ...
  end;
end;
```

**Functor parameters vs first-order functions**

A functor parameter `let F be func(T) -> S;` is a **schema-level function symbol** — it is not a set in the domain of discourse, and does not support `is`-predicate reasoning. This distinguishes it from first-order functions defined via modes (e.g., `let phi be Homomorphism[G,H];`), which are set elements.

| Kind | Declaration | FOL status | `is` predicates |
|---|---|---|---|
| First-order function (mode-based) | `let phi be Homomorphism[G,H];` | Set element | Supported |
| Schema functor parameter | `let F be func(T) -> S;` | Meta-level symbol | Not supported |

When algebraic properties are needed on a function parameter, use a mode-based type declaration (`let phi be Homomorphism[G,H];`). Reserve `func(...)` parameters for truly generic function schemas where no algebraic constraint is required (see §18.8.3).

> [!NOTE]
> For a comprehensive treatment of the three function representations in Mizar-Evo (set-theoretic functions, `deffunc` term abbreviations, and schema functor parameters), see [Chapter 10 (Functors)](./10.functors.md).

### 18.2.5 Constrained Parameters

When a type parameter must satisfy an additional condition beyond its mode, state it after `such that` with a proof obligation at the `let` declaration:

```mizar
:: Single-step justification
definition
  let F be Field;
  let V be VectorSpace[F] such that V is finite_dimensional
    by mml.linear_algebra.FinDim_exists;
  theorem BasisCard:
    card (Basis of V) = dim V;
end;
```

If no single-step justification is available, use a `proof ... end;` block:

```mizar
definition
  let R be Ring;
  let M be Module[R] such that M is non empty
  proof
    consider x being Element of M;
    :: ...
  end;
  theorem SomeModuleTheorem: ...;
end;
```

Constrained parameters correspond to hypotheses that must be discharged at each **use site**. At the definition site, the constraint is assumed as a hypothesis. At a use site (e.g., `let V be FinDimVectorSpace[REAL_FIELD];`), the verifier requires the user to supply a proof that the constraint holds.

> [!NOTE]
> The `such that` constraint on `let` applies to **type parameters** and is verified at use sites. The `provided` clause (§18.8.2) applies to **theorem-level hypotheses** and is discharged at proof application sites. These are distinct mechanisms.

### 18.2.6 Scoping Rules

- `let` declarations at the beginning of a `definition` block scope over **all items** in the block. This follows the classical Mizar scoping rule for `let IT be ...;` in definition blocks.
- Predicate parameters (`let P be pred(T);`) and functor parameters (`let F be func(T) -> S;`) scope only to individual `theorem` items within the block; they may not be used in `attr`, `mode`, `struct`, `func`, or `pred` items.
- Parameterized names `N[params]` are globally visible after the enclosing block.
- A `definition` block with parameterized definitions may not be nested inside another `definition` block or inside a `proof` block.
- Circular dependencies between parameterized definitions are forbidden.

## 18.3 Template for Attributes (attr)

Attribute templates define families of attributes indexed by type parameters.

**Example 1 — Order compatibility on a ring:**

```mizar
definition
  let R be Ring;
  let a, b be Element of R;
  attr CompatDef: a is order_compatible[R] means
    for c being Element of R holds
      a <= b implies a + c <= b + c;
  :: Automatic synonym: a is R-order_compatible
end;
```

**Example 2 — Boundedness in a normed space:**

```mizar
definition
  let V be VectorSpace[REAL];
  let v be Element of V;
  attr NormedDef: v is bounded[V] means
    ex r being non negative Real st
      for w being Element of V holds |.inner_product(v, w).| <= r * norm w;
  :: Automatic synonym: v is V-bounded
end;
```

**Usage:**

```mizar
let R be Ring;
let a be Element of R;
assume a is order_compatible[R];
:: equivalently: assume a is R-order_compatible;
```

Template attributes are instantiated implicitly by the type checker when the parameterized attribute name is used. No explicit `instantiate` declaration is required.

**Logic Encoding:**

An attribute `attr D: a is P[T] means φ[a, T]` generates, for each usage `T := T₀`:

```
∀a. (is_Element(a, T₀) → (is_P_T₀(a) ↔ φ[a, T₀]))
```

## 18.4 Template for Modes (mode)

Mode templates define families of types indexed by type parameters, generalizing the `of`/`over` parameterization.

**Example 1 — Generic subobject mode:**

```mizar
definition
  let A be type;
  mode Subobject[A] is A-subset_like set;
  :: Automatic synonym: Subobject of A
end;

:: Usage
let S be Subobject[G];
:: equivalently: let S be Subobject of G;
```

**Example 2 — Generic homomorphism mode (two parameters):**

```mizar
definition
  let G be Group;
  let H be Group;
  mode Homomorphism[G,H] is
    operation_preserving Function of G.carrier, H.carrier;
  :: Automatic synonym: Homomorphism of G, H
end;

:: Usage
let phi be Homomorphism[G, H];
```

**Example 3 — Constrained mode:**

```mizar
definition
  let F be Field;
  let V be VectorSpace[F] such that
    ex n being positive integer st dim V = n
    by mml.linear_algebra.FinDim_characterization;
  mode FinDimVectorSpace[V] is VectorSpace[F];
  :: Automatic synonym: FinDimVectorSpace over V
end;
```

**`of`/`over` as syntactic sugar**

The `of`/`over` syntax in ordinary mode definitions (Chapter 5) is shorthand for single-parameter mode templates:

```mizar
:: Shorthand (Chapter 5 syntax — preferred for single parameters)
definition
  mode Subset of X is X-subset_like set;
end;

:: Full template form (equivalent)
definition
  let X be type;
  mode Subset[X] is X-subset_like set;
end;
```

Both forms are accepted. The `of`/`over` shorthand is preferred for simple single-parameter modes.

**Logic Encoding:**

A template mode `mode M[T] is A T` generates, for each usage `T := T₀`:

```
∀x. (is_M(x, T₀) ↔ (is_A(x) ∧ is_T₀(x)))
```

## 18.5 Template for Structures (struct)

Structure templates define parameterized composite types.

**Example 1 — Generic vector space over a field:**

```mizar
definition
  let K be Field;
  struct VectorSpace[K] where
    field carrier -> non empty set;
    field add -> BinOp of carrier;
    field smul -> Function of [:K.carrier, carrier:], carrier;
  end;
  :: Automatic synonym: VectorSpace over K
end;

:: Usage: instantiated for real numbers
let V be VectorSpace[REAL_FIELD];
:: equivalently: let V be VectorSpace over REAL_FIELD;
```

**Example 2 — Generic ordered structure with inheritance:**

```mizar
definition
  let T be type;
  struct OrdStr[T] where
    field carrier -> T;
    field order -> Relation of T;
  end;
  :: Automatic synonym: OrdStr over T

  inherit OrdStr[T] from 1-sorted where
    field carrier from carrier;
  end;
end;
```

**Example 3 — Structure with multiple type parameters:**

```mizar
definition
  let F be Field;
  let V be VectorSpace[F];
  let W be VectorSpace[F];
  struct BilinearMap[F,V,W] where
    field map -> Function of [:V.carrier, W.carrier:], F.carrier;
    property kernel -> Subobject[V];
  end;
  :: Automatic synonym: BilinearMap over F, V, W
end;

:: Usage
let B be BilinearMap[REAL_FIELD, V, W];
```

**Logic Encoding:**

A template structure `struct S[T]` generates, for each usage `T := T₀`:

- A new predicate `is_S_T₀(x)`
- Field selector axioms: `∀x. (is_S_T₀(x) → is_T₀(field(x)))`
- Extensionality: `∀x,y. (is_S_T₀(x) ∧ is_S_T₀(y) ∧ f₁(x)=f₁(y) ∧ ... → x=y)`

## 18.6 Template for Predicates (pred)

Predicate templates define families of predicates indexed by type parameters.

**Example 1 — Generic congruence predicate:**

```mizar
definition
  let G be Group;
  let H be Subgroup of G;
  let a, b be Element of G;
  pred CongruenceDef: a, b are_congruent[H] means
    a * b" in H;
end;

:: Usage
let G be Group;
let H be Subgroup of G;
let a, b be Element of G;
assume a, b are_congruent[H];
```

**Example 2 — Generic divisibility predicate:**

```mizar
definition
  let R be Ring;
  let a, b be Element of R;
  pred DividesDef: a divides[R] b means
    ex c being Element of R st b = a * c;
  reflexivity
  proof
    let a be Element of R;
    take c = 1_R;
    thus a = a * 1_R by mml.algebra.ring.mul_one;
  end;
end;
```

**Logic Encoding:**

A template predicate `pred P[T](a, b) means φ[a, b, T]` generates, for each usage `T := T₀`:

```
∀a, b. (is_T₀(a) ∧ is_T₀(b) → (P(a, b, T₀) ↔ φ[a, b, T₀]))
```

## 18.7 Template for Functors (func)

Functor templates define families of operations parameterized by type parameters.

**Example 1 — Generic identity function:**

```mizar
definition
  let T be type;
  func IdDef: id[T] -> Function of T, T equals
    { [x, x] where x is Element of T : x in T };
end;

:: Usage
let f = id[NAT];
```

**Example 2 — Generic neutral element:**

```mizar
definition
  let G be Group;
  func NeutralDef: neutral[G] -> Element of G means
    for a being Element of G holds it * a = a & a * it = a;
  existence
  proof
    consider e being Element of G such that
      A1: for a being Element of G holds e * a = a & a * e = a
      by mml.algebra.group.Group_identity_exists;
    take e;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let e1, e2 be Element of G;
    assume A1: for a being Element of G holds e1 * a = a & a * e1 = a;
    assume A2: for a being Element of G holds e2 * a = a & a * e2 = a;
    thus e1 = e1 * e2 by A2
           .= e2 by A1;
  end;
end;
```

**Functor parameters vs first-order functions**

The `func(T) -> S` parameter kind in theorem schemas (§18.2.4) is a **schema-level functor** — a meta-level function symbol, not a first-order term. This contrasts with functors defined via `func` definitions (like `id[T]` and `neutral[G]` above), which denote terms in the object language and are set elements.

When a function argument to a theorem must satisfy algebraic properties, use a mode-based parameter instead of a schema functor:

```mizar
:: Preferred: mode-based parameter supports is-predicates
definition
  let M be Monoid;
  let N be Monoid;
  let phi be Homomorphism[M, N];   :: first-order, supports is-predicates
  theorem HomPreservesNeutral:
    phi(neutral[M]) = neutral[N]
  proof
    ...
  end;
end;
```

Reserve `let F be func(T) -> S;` for contexts where no algebraic constraint on the function is required (see §18.8.3).

> [!NOTE]
> For a comprehensive treatment of the three function representations in Mizar-Evo — set-theoretic functions, `deffunc` term abbreviations, and schema functor parameters — see [Chapter 10 (Functors)](./10.functors.md).

**Logic Encoding:**

A functor template `func F[T] -> S means φ[F[T], T]` generates, for each usage `T := T₀`:

```
∃!y. (is_S(y) ∧ φ[y, T₀])
∀x. (is_T₀(x) → φ[F_T₀(x), T₀])
```

## 18.8 Parameterized Theorems and Schemes

### 18.8.1 When Templates Are Not Needed

Theorems parameterized only over types do **not** require the template mechanism. Write them as ordinary universally quantified theorems:

```mizar
:: No template needed — quantify over types directly
theorem CommMul:
  for G being commutative Group
  for a, b being Element of G holds a * b = b * a
proof
  let G be commutative Group;
  let a, b be Element of G;
  thus a * b = b * a by mml.algebra.group.CommGroup_commutative;
end;

:: No template needed — type constraint expressed as hypothesis
theorem InjectiveKernel:
  for G, H being Group st G is non trivial
  for phi being Homomorphism[G, H]
    holds phi is injective iff
      (for a being Element of G st phi(a) = neutral[H] holds a = neutral[G])
proof
  ...
end;
```

Templates are required only when:

1. A definition item (struct, mode, attr, func, pred) is parameterized by a type.
2. A theorem is parameterized by a **predicate** or **functor** (scheme-style).

### 18.8.2 Predicate-Parameterized Theorems (Schemes)

A theorem containing `let P be pred(T);` in the enclosing `definition` block is a **predicate schema** — it generates a family of first-order theorems, one for each predicate substituted for `P`.

The `provided` clause introduces named hypotheses that are discharged at each application site (see §18.9). At the definition site, they are assumed.

**Example 1 — Natural number induction:**

```mizar
definition
  let P be pred(Nat);
  theorem NatInduction:
    (for n being Nat holds P(n))
  provided
    Base: P(0) and
    Step: for n being Nat st P(n) holds P(n+1)
  proof
    assume Base and Step;
    let n be Nat;
    thus P(n) by Base, Step, mml.number.natural.Nat_induction;
  end;
end;
```

**Example 2 — Transfinite induction:**

```mizar
definition
  let A be WellFoundedOrder;
  let P be pred(Element of A);
  theorem TransfiniteInduction:
    (for x being Element of A holds P(x))
  provided
    Step: for x being Element of A st
            (for y being Element of A st y <<< x holds P(y))
            holds P(x)
  proof
    ...
  end;
end;
```

**Example 3 — Structural induction over lists:**

```mizar
definition
  let T be type;
  let P be pred(List of T);
  theorem ListInduction:
    (for l being List of T holds P(l))
  provided
    NilCase:  P({}) and
    ConsCase: for x being T, l being List of T st P(l) holds P(x :: l)
  proof
    let l be List of T;
    defpred Q(n) means for l being List of T st len l = n holds P(l);
    thus P(l) by NatInduction[Q], NilBase, NilStep
    where
      NilBase: proof thus Q(0) by NilCase; end,
      NilStep: proof
        let n be Nat;
        assume IH: Q(n);
        let l be List of T;
        assume A1: len l = n+1;
        :: l = x :: l' for some x, l' with len l' = n
        ...
        thus P(l) by ConsCase, IH;
      end;
  end;
end;
```

### 18.8.3 Functor-Parameterized Theorems

Theorems parameterized by functor parameters state properties that hold for **any** function of the given type signature, without requiring algebraic structure on that function.

When algebraic properties are needed, use mode-based parameters (§18.7). Reserve `func(...)` parameters for structural or recursion-theoretic schemas where the function is treated as a black box.

**Example — Homomorphism preservation via mode parameter (preferred):**

```mizar
definition
  let M be Monoid;
  let N be Monoid;
  let phi be Homomorphism[M, N];   :: mode-based: carries algebraic type
  theorem HomPreservesId:
    phi(neutral[M]) = neutral[N]
  provided
    PhiHom: for a, b being Element of M
              holds phi(a * b) = phi(a) * phi(b)
  proof
    ...
  end;
end;
```

**Example — Generic iteration invariant (func parameter appropriate):**

```mizar
definition
  let A be type;
  let F be func(A) -> A;
  let P be pred(A);
  theorem IterationInvariant:
    P(x0) & (for y being A st P(y) holds P(F(y)))
    implies for n being Nat holds P(F@@n(x0))
  proof
    assume A1: P(x0) & (for y being A st P(y) holds P(F(y)));
    defpred Q(n) means P(F@@n(x0));
    QBase: Q(0) proof thus P(x0) by A1; end;
    QStep: for n being Nat st Q(n) holds Q(n+1)
    proof
      let n be Nat;
      assume Q(n);
      thus Q(n+1) by A1;
    end;
    thus for n being Nat holds Q(n) by NatInduction[Q], QBase, QStep;
  end;
end;
```

### 18.8.4 Mixed-Parameter Theorems

Templates may combine type, predicate, and functor parameters.

**Example — Generic monotone fixpoint schema:**

```mizar
definition
  let T be type;
  let P be pred(T, T);
  let F be func(T) -> T;
  assume P is a_partial_order;
  theorem MonotoneFixpoint:
    ex x being T st F(x) = x
  provided
    Monotone: for x, y being T st P(x, y) holds P(F(x), F(y))
  proof
    ...
  end;
end;
```

## 18.9 Scheme Application in Proofs

A predicate or functor schema is applied in a proof by:

1. Defining the predicate argument with `defpred` (or the functor argument with `deffunc`).
2. Proving the `provided` hypotheses as named labels.
3. Referencing the schema theorem with `by SchemaName[P], Label1, Label2, ...`.

**Syntax (EBNF):**

```ebnf
scheme_app  ::= "by" theorem_label "[" scheme_arg { "," scheme_arg } "]"
                { "," label_reference } ";" ;

scheme_arg  ::= defpred_identifier | deffunc_identifier ;
```

The `defpred` (or `deffunc`) name acts as the scheme argument. The `provided` labels are passed as additional label references.

> [!IMPORTANT]
> Inline λ-style predicate arguments (e.g., `by NatInduction[pred n means n * 2 is even]`) are **not** supported. Always use `defpred` (or `deffunc`) before referencing a scheme. This requirement promotes readability and allows the verifier to resolve the predicate definition unambiguously.

**Example 1 — Applying natural number induction:**

```mizar
theorem NatMulEven:
  for n being Nat holds n * 2 is even
proof
  defpred P(n) means n * 2 is even;
  Base: P(0)
  proof
    thus 0 * 2 is even by mml.number.nat.zero_even;
  end;
  Step: for n being Nat st P(n) holds P(n+1)
  proof
    let n be Nat;
    assume A1: n * 2 is even;
    n * 2 + 2 = (n + 1) * 2 by mml.number.nat.distrib;
    thus (n + 1) * 2 is even by A1, mml.number.nat.even_plus_even;
  end;
  thus for n being Nat holds P(n) by NatInduction[P], Base, Step;
end;
```

**Example 2 — Applying list induction:**

```mizar
theorem ListLenNonNeg:
  for T being type, l being List of T holds len l >= 0
proof
  let T be type;
  defpred Q(l) means len l >= 0;
  NilCase: Q({})
  proof
    thus len ({} : List of T) >= 0;
  end;
  ConsCase: for x being T, l being List of T st Q(l) holds Q(x :: l)
  proof
    let x be T, l be List of T;
    assume len l >= 0;
    thus len (x :: l) >= 0 by mml.data.list.Cons_len_pos;
  end;
  thus for l being List of T holds Q(l)
    by ListInduction[Q], NilCase, ConsCase;
end;
```

**Example 3 — Applying a mixed schema (func and pred parameters):**

```mizar
theorem SuccIterationInvariant:
  for n being Nat holds (succ)@@n(0) >= 0
proof
  deffunc F(n) = succ(n);
  defpred P(n) means (succ)@@n(0) >= 0;
  A1: P(0) & (for x being Nat st P(x) holds P(F(x)))
  proof
    thus P(0);   :: (succ)@@0(0) = 0 >= 0
    let x be Nat;
    assume (succ)@@x(0) >= 0;
    thus P(F(x));   :: (succ)@@(succ(x))(0) >= 0
  end;
  thus for n being Nat holds P(n)
    by IterationInvariant[F, P], A1;
end;
```

## 18.10 Logic Encoding Details

Templates are meta-level constructs. Each **use site** (where a parameterized name is used or a schema is applied) generates a collection of first-order axioms and proof obligations.

### 18.10.1 Templates as Axiom Schemas

A `definition` block with `let` parameters is treated as an **axiom schema** — a recipe for generating FOL axioms when a parameterized name is used or a schema theorem is referenced.

| Template Level | FOL Status |
|---|---|
| `definition` block with `let` parameters | No FOL axioms generated (schema only) |
| Use of parameterized name (e.g., `let M be Module[R];`) | Generates axioms for that instantiation of `R` |
| Schema application (`by NatInduction[P], Base, Step`) | Generates the specific first-order instance |

**Verification guarantee**: The verifier checks each template body **once symbolically** at declaration time. All proof obligations in the body are discharged relative to the parameter constraints. This ensures that every use generates valid axioms without re-proving.

### 18.10.2 Type Parameter Encoding

A type parameter `let T be type;` is encoded as an **uninterpreted predicate symbol** `is_T(x)` in the schema.

| Source | FOL Schema |
|---|---|
| `let T be type;` | Schema variable `is_T/1` (uninterpreted) |
| `let G be Group;` | Schema variable `is_G/1` with guard `∀x. is_G(x) → is_Group(x)` |
| `let x be T;` | Guard `is_T(x)` added as antecedent |

**Example:**

FOL schema for `Homomorphism[G, H]` with `G, H` being `Group`:

```
∀G, H. (∀x. is_G(x) → is_Group(x)) ∧ (∀x. is_H(x) → is_Group(x))
  → ∀f. (is_Hom(f, G, H) ↔ is_operation_preserving(f, G, H))
```

For usage `G := INT_GROUP`, `H := REAL_GROUP`:

```
∀f. (is_Hom(f, INT_GROUP, REAL_GROUP)
       ↔ is_operation_preserving(f, INT_GROUP, REAL_GROUP))
```

### 18.10.3 Predicate Parameter Encoding

A predicate parameter `let P be pred(T);` is encoded as an **uninterpreted predicate symbol** `P/1`. The schema represents a **family of first-order formulas** — one for each predicate substituted for `P`. Since FOL does not support second-order quantification, each instantiation generates a distinct first-order axiom.

| Source | FOL Schema |
|---|---|
| `let P be pred(T);` | Schema variable `P/1` (uninterpreted) |
| `P(x)` in formula | `P(x)` in generated formula |
| `for x st P(x) holds Q` | `∀x. (P(x) → Q)` in generated formula |

**Example — NatInduction schema:**

FOL schema (one instance for each predicate `P` substituted):

```
P(0) ∧ (∀n. is_Nat(n) → P(n) → P(succ(n)))
  → ∀n. is_Nat(n) → P(n)
```

This is precisely the **natural number induction axiom schema** in FOL. The trusted kernel verifies each specific instance (e.g., `P(n) := is_even(n * 2)`) without requiring higher-order reasoning.

**Summary table:**

| Mizar Form | FOL Encoding |
|---|---|
| `let P be pred(T);` | Uninterpreted predicate `P/1` in schema |
| `P(x)` in theorem body | `P(x)` |
| `by NatInduction[P], Base, Step` | Instantiation: substitute `P` and generate first-order axiom |

### 18.10.4 Functor Parameter Encoding

A functor parameter `let F be func(T) -> S;` is encoded as an **uninterpreted function symbol** `F/1` with a type guard axiom.

| Source | FOL Schema |
|---|---|
| `let F be func(T) -> S;` | Uninterpreted function `F/1` with guard `∀x. is_T(x) → is_S(F(x))` |
| `F(x)` in term | `F(x)` |

**Example — MonoidHom with mode-based parameter:**

FOL schema for `HomPreservesId[phi]` (where `phi` is mode-based):

```
(∀a, b. is_M(a) ∧ is_M(b) → phi(mul_M(a,b)) = mul_N(phi(a), phi(b)))
  → phi(neutral_M) = neutral_N
```

### 18.10.5 Constraint Encoding

Parameter constraints (`such that` clause) are encoded as **conditional guards** — proof obligations at use sites, not axioms.

| Source | FOL Effect |
|---|---|
| `let V be T such that φ by proof` | Obligation `φ` must hold at each use site |
| `provided H: φ` | Obligation `φ` supplied by caller at application site |
| Verified constraint | Antecedent added to all generated axioms |

**Example:**

```mizar
definition
  let F be Field;
  let V be VectorSpace[F] such that V is finite_dimensional
    by mml.linear_algebra.FinDim_exists;
  theorem BasisCard:
    card (Basis of V) = dim V;
end;
```

Generated axiom at use site `F := F₀`, `V := V₀` (after user proves `V₀ is finite_dimensional`):

```
is_Field(F₀) ∧ is_VectorSpace(V₀, F₀) ∧ is_finite_dimensional(V₀)
  → card(Basis(V₀)) = dim(V₀)
```

## 18.11 Complete Syntax (EBNF)

```ebnf
(* === Template Declaration (definition block with let parameters) === *)
template_def    ::= "definition"
                    { let_param }
                    { template_item }
                    "end" ";" ;

let_param       ::= "let" identifier_list "be" type_expression
                    [ "such" "that" formula
                      ( "by" label_ref_list | proof ) ]
                    ";" ;

template_item   ::= attr_def
                  | mode_def
                  | struct_def
                  | pred_def
                  | func_def
                  | theorem_item
                  | registration_item ;

(* === Type Parameters (in let_param) === *)
type_param      ::= identifier "be" ( "type" | type_expression ) ;

(* === Predicate Parameters (in let_param; valid in theorem items only) === *)
pred_param      ::= identifier "be" "pred" "(" type_list ")" ;

type_list       ::= type_expression { "," type_expression } ;

(* === Functor Parameters (in let_param; valid in theorem items only) === *)
func_param      ::= identifier "be" "func" "(" type_list ")" "->" type_expression ;

(* === Parameterized Names (reserved bracket notation) === *)
param_name      ::= identifier "[" type_arg_list "]" ;
type_arg_list   ::= type_expression { "," type_expression } ;

(* === Theorem Items with Predicate/Functor Parameters === *)
theorem_item    ::= ( "theorem" | "conjecture" ) label_identifier ":"
                    formula
                    [ "provided" hypothesis { "and" hypothesis } ]
                    [ justification ] ";" ;

hypothesis      ::= label_identifier ":" formula ;

(* === Scheme Application in Proofs === *)
scheme_app      ::= "by" label_identifier
                    "[" scheme_arg { "," scheme_arg } "]"
                    { "," label_reference } ";" ;

scheme_arg      ::= defpred_identifier | deffunc_identifier ;

(* === Predicate/Functor Application (following defpred/deffunc convention) === *)
pred_app        ::= identifier "(" term_list ")" ;
func_app        ::= identifier "(" term_list ")" ;
```

**Summary of template parameter kinds:**

| Kind | Declaration | Application | FOL Status |
|---|---|---|---|
| Type | `let T be type;` | Used as type | Uninterpreted predicate `is_T` |
| Constrained type | `let G be Group;` | Used as type; guard added | Uninterpreted pred with guard |
| Predicate | `let P be pred(T);` | `P(x)` | Uninterpreted predicate `P/n` (schema only) |
| Functor | `let F be func(T) -> S;` | `F(x)` | Uninterpreted function `F/n` (schema only) |

**Summary of usage forms:**

| Form | Example | When to Use |
|---|---|---|
| Parameterized type name | `let M be Module[R];` | Using a parameterized type definition |
| `of`/`over` synonym | `let M be Module over R;` | Single-parameter type definitions |
| Schema application | `by NatInduction[P], Base, Step` | Applying a predicate schema in a proof |
| Mode-based function param | `let phi be Homomorphism[G,H];` | Function with algebraic properties |
| Schema functor param | `let F be func(A) -> A;` | Generic function without algebraic constraints |

> [!NOTE]
> For reasoning patterns that apply the template theorems defined here (induction schemes, recursive definitions, and standard pattern libraries), see [Chapter 19 (Reasoning Patterns)](./19.reasoning_patterns.md).

> [!NOTE]
> For overload resolution when multiple template definitions introduce overlapping symbols, see [Chapter 20 (Overload Resolution)](./20.overload_resolution.md).
