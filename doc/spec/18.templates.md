# 18. Templates

- [18. Templates](#18-templates)
  - [18.1 Overview](#181-overview)
  - [18.2 Template Syntax and Semantics](#182-template-syntax-and-semantics)
    - [18.2.1 Template Declarations](#1821-template-declarations)
    - [18.2.2 Template Parameter Kinds](#1822-template-parameter-kinds)
    - [18.2.3 Template Constraints](#1823-template-constraints)
    - [18.2.4 Template Body](#1824-template-body)
    - [18.2.5 Template Scoping Rules](#1825-template-scoping-rules)
  - [18.3 Template for Attributes (attr)](#183-template-for-attributes-attr)
  - [18.4 Template for Modes (mode)](#184-template-for-modes-mode)
  - [18.5 Template for Structures (struct)](#185-template-for-structures-struct)
  - [18.6 Template for Predicates (pred)](#186-template-for-predicates-pred)
  - [18.7 Template for Functors (func)](#187-template-for-functors-func)
  - [18.8 Template for Theorems (theorem / scheme)](#188-template-for-theorems-theorem--scheme)
    - [18.8.1 Type-Parameterized Theorems](#1881-type-parameterized-theorems)
    - [18.8.2 Predicate-Parameterized Theorems (Schemes)](#1882-predicate-parameterized-theorems-schemes)
    - [18.8.3 Functor-Parameterized Theorems](#1883-functor-parameterized-theorems)
    - [18.8.4 Mixed-Parameter Theorems](#1884-mixed-parameter-theorems)
  - [18.9 Template Specialization and Instantiation](#189-template-specialization-and-instantiation)
    - [18.9.1 Explicit Instantiation](#1891-explicit-instantiation)
    - [18.9.2 Implicit Instantiation via Type Inference](#1892-implicit-instantiation-via-type-inference)
    - [18.9.3 Scheme Application in Proofs](#1893-scheme-application-in-proofs)
    - [18.9.4 Partial Specialization](#1894-partial-specialization)
  - [18.10 Logic Encoding Details](#1810-logic-encoding-details)
    - [18.10.1 Templates as Axiom Schemas](#18101-templates-as-axiom-schemas)
    - [18.10.2 Type Parameter Encoding](#18102-type-parameter-encoding)
    - [18.10.3 Predicate Parameter Encoding (Schemes)](#18103-predicate-parameter-encoding-schemes)
    - [18.10.4 Functor Parameter Encoding](#18104-functor-parameter-encoding)
    - [18.10.5 Constraint Encoding](#18105-constraint-encoding)
  - [18.11 Complete Syntax (EBNF)](#1811-complete-syntax-ebnf)

## 18.1 Overview

Templates are the **generics mechanism** of Mizar — a systematic facility for writing mathematical definitions and theorems that are parameterized by types, predicates, or functions. A template captures a **pattern of mathematical reasoning** that is valid across a family of instances, and allows each instance to be generated automatically upon use.

Templates serve several distinct roles in the language:

1. **Generic Definitions**: Define attributes, modes, structures, predicates, and functors over abstract type parameters. For example, a generic `Monoid` template can be instantiated for natural numbers, integers, polynomials, etc.

2. **Theorem Schemas (Schemes)**: State theorems parameterized by predicates or functions — the primary mechanism for reasoning by induction, recursion, or universal structural properties. These generalize the classical Mizar `scheme` construct.

3. **Grouped Parameterized Theories**: Bundle together related definitions under a shared set of parameters, enabling modular library organization.

**Relationship to the `of`/`over` Syntax**

The `of`/`over` parameterization in modes (Chapter 5) and structures (Chapter 7) is **syntactic sugar** for simple type-parameterized templates. For example:

```mizar
definition
  mode Subset of X is X-subset_like set;
end;
```

is shorthand for a template with a single type parameter `X`. The full template mechanism generalizes this to:
- Multiple parameters of different kinds
- Constraints on parameters
- Groups of related definitions
- Higher-order parameters (predicates and functors)

**Relationship to Classical Mizar Schemes**

The classical Mizar `scheme` construct allowed parameterization over predicates and functors for stating parametric theorems. In Mizar-Evo, `scheme`-style parameterization is unified with the general template system. A template theorem with predicate parameters subsumes the `scheme` mechanism while fitting consistently into the overall syntax.

> [!NOTE]
> For reasoning patterns that apply template theorems (e.g., natural number induction, structural induction), see [Chapter 19 (Reasoning Patterns)](./19.reasoning_patterns.md).

## 18.2 Template Syntax and Semantics

### 18.2.1 Template Declarations

A template is declared with the `template` keyword, followed by a name, a bracketed parameter list, an optional constraint clause, and a body.

**Syntax (EBNF):**

```ebnf
template_decl   ::= "template" template_name
                    "<" param_decl_list ">"
                    [ "where" constraint_list ]
                    template_body
                    "end" ";" ;

template_name   ::= identifier ;
```

**Example:**

```mizar
:: A template for algebraic structures with a binary operation
template AlgStr<T being type>
  definition
    struct MagmaOver<T> where
      field carrier -> T;
      field binop -> BinOp of T;
    end;
  end;
end;
```

Templates may contain any combination of `definition`, `registration`, and `theorem` items. All items in the body share the template's parameters.

### 18.2.2 Template Parameter Kinds

Mizar templates support three kinds of parameters:

**Syntax (EBNF):**

```ebnf
param_decl_list ::= param_decl { "," param_decl } ;

param_decl      ::= type_param
                  | pred_param
                  | func_param ;

type_param      ::= identifier "being" ( "type" | type_expression ) ;
pred_param      ::= identifier "being" "pred" "of" "(" type_list ")" ;
func_param      ::= identifier "being" "func" "of" "(" type_list ")" "->" type_expression ;

type_list       ::= type_expression { "," type_expression } ;
```

**1. Type Parameters (`being type` or `being <mode>`)**

A type parameter ranges over types (modes or structures). The constraint `being type` imposes no restriction; `being <mode>` restricts the parameter to subtypes of the named mode.

| Declaration | Meaning |
|---|---|
| `T being type` | T is any type |
| `G being Group` | G must be a Group (or subtype) |
| `R being Ring` | R must be a Ring (or subtype) |

```mizar
template Container<T being type>
  ...
end;

template AlgHom<G being Group, H being Group>
  ...
end;
```

**2. Predicate Parameters (`being pred of (...)`)**

A predicate parameter ranges over predicates of a given arity and argument types. This is the mechanism underlying scheme-style parameterization.

```mizar
template Induction<A being type, P being pred of (A)>
  theorem Main:
    (P[a0] & (for n being A st P[n] holds P[succ n]))
    implies for n being A holds P[n];
end;
```

Predicate parameters are applied using bracket notation `P[t1, ..., tn]`.

**3. Functor Parameters (`being func of (...) -> ...`)**

A functor parameter ranges over functions of a given type signature.

```mizar
template Homomorphism<G being Group, H being Group, phi being func of (Element of G) -> Element of H>
  theorem PreservesOp:
    for a, b being Element of G
      holds phi[a * b] = phi[a] * phi[b]
    :: (to be discharged by the user upon instantiation)
    ;
end;
```

Functor parameters are applied using bracket notation `F[t]`.

### 18.2.3 Template Constraints

The optional `where` clause introduces constraints (hypotheses) that must be satisfied by instantiations. Constraints are stated as formulas involving the template parameters.

**Syntax (EBNF):**

```ebnf
constraint_list ::= constraint { "," constraint } ;
constraint      ::= formula ;
```

**Example:**

```mizar
template VectorSpaceThm<F being Field, V being VectorSpace over F>
where V is non empty
  theorem DimPositive:
    card (Basis of V) > 0;
end;
```

Constraints are discharged at each instantiation site: the user must prove that each constraint holds for the chosen arguments.

> [!NOTE]
> Constraints in `where` clauses are **hypotheses** — they must be proved at each instantiation, not assumed globally. They resemble the `provided` clauses of classical Mizar schemes.

### 18.2.4 Template Body

The template body consists of zero or more top-level items drawn from:

```ebnf
template_body  ::= { template_item } ;
template_item  ::= definition_block
                 | registration_block
                 | theorem_item ;

definition_block   ::= "definition" { def_content } "end" ";" ;
registration_block ::= "registration" { registration_item } "end" ";" ;
theorem_item       ::= ( "theorem" | "conjecture" ) label_identifier ":" formula
                       [ justification ] ";" ;
```

All items in the body may freely reference the template's parameters. Cross-references between items within the same template are permitted.

**Example (multiple items):**

```mizar
template OrderedAlg<R being Ring>
  definition
    mode OrderedRingDef: OrderedRing over R is
      total_order_compatible R;
  end;

  registration
    cluster R -> ordered for Ring;
    coherence proof ... end;
  end;

  theorem OrderedRing_pos_prod:
    for a, b being Element of R
      st a > 0 & b > 0 holds a * b > 0;
end;
```

### 18.2.5 Template Scoping Rules

- Template parameters are **in scope** throughout the entire template body.
- Labels defined in the template body are **local** to the template; they are exported under the fully qualified name `TemplateName<args>.LabelName` after instantiation.
- Templates may **not** be defined inside `definition` or `proof` blocks; they are top-level declarations only.
- A template may reference other templates, but **circular template dependencies** are forbidden.

## 18.3 Template for Attributes (attr)

Attribute templates allow defining a family of attributes parameterized by a type.

**Syntax:**

```ebnf
attr_template ::= "template" template_name "<" type_param_list ">"
                  "definition"
                  { attr_item }
                  "end" ";"
                  "end" ";" ;
attr_item     ::= "let" identifier "be" type_expression ";"
                | attr_def ;
```

**Example 1 — Parameterized attribute for algebraic compatibility:**

```mizar
template CompatibleOrder<R being Ring>
  definition
    let a, b be Element of R;
    attr CompatDef: a is (R)-order_compatible means
      for c being Element of R holds
        a <= b implies a + c <= b + c;
  end;
end;
```

**Example 2 — Attribute parameterized over a predicate-like index:**

```mizar
template NormAttr<V being VectorSpace over REAL>
  definition
    let v be Element of V;
    attr NormedDef: v is (V)-bounded means
      ex r being non negative Real st
        for w being Element of V holds |.inner_product(v, w).| <= r * norm w;
  end;
end;
```

**Instantiation:**

```mizar
:: Attribute instantiated for integer ring
instantiate CompatibleOrder<INT_RING>;

let n, m be Element of INT_RING;
assume n is (INT_RING)-order_compatible;
```

**Logic Encoding:**

A template attribute `attr CompatDef<R>: a is (R)-P means φ[a, R]` generates, for each concrete instantiation `R := R₀`:

```
∀a. (is_Element(a, R₀) → (is_(R₀)-P(a) ↔ φ[a, R₀]))
```

## 18.4 Template for Modes (mode)

Mode templates generalize the `of`/`over` parameterization. They allow defining a family of types indexed by type parameters.

**Syntax:**

```ebnf
mode_template ::= "template" template_name "<" type_param_list ">"
                  "definition"
                  { mode_item }
                  "end" ";"
                  "end" ";" ;
mode_item     ::= "let" identifier "be" type_expression ";"
                | mode_def ;
```

**Example 1 — Generic subobject mode:**

```mizar
template SubobjectMode<A being type>
  definition
    mode SubDef: Subobject of A is A-subset_like set;
  end;
end;

:: Usage (equivalent to built-in Subset of A)
let S be Subobject of G;
```

**Example 2 — Generic homomorphism mode:**

```mizar
template HomMode<G being Group, H being Group>
  definition
    mode HomDef: Homomorphism of G, H is
      G-H-operation_preserving Function of G.carrier, H.carrier;
  end;
end;

:: Usage
let phi be Homomorphism of G, H;
```

**Example 3 — Mode with a constraint:**

```mizar
template FinDimMode<F being Field>
where ex n being Nat st n > 0
  definition
    mode FinDimVSDef: FinDimVectorSpace over F is
      finite_dimensional VectorSpace over F;
  end;
end;
```

**Relationship to `of`/`over` Syntax**

The `of`/`over` parameterization in ordinary mode definitions is shorthand for a single-parameter mode template:

```mizar
:: Shorthand (Chapter 5 syntax)
definition
  mode SubsetDef: Subset of X is X-subset_like set;
end;

:: Equivalent template form
template SubsetTemplate<X being type>
  definition
    mode SubsetDef: Subset of X is X-subset_like set;
  end;
end;
```

Both forms are accepted. The `of`/`over` shorthand is preferred for simple single-parameter modes.

**Logic Encoding:**

A template mode `mode M<T> is A T` generates, for each instantiation `T := T₀`:

```
∀x. (is_M(x, T₀) ↔ (is_A(x) ∧ is_T₀(x)))
```

## 18.5 Template for Structures (struct)

Structure templates allow defining parameterized composite types.

**Syntax:**

```ebnf
struct_template ::= "template" template_name "<" type_param_list ">"
                    "definition"
                    { struct_item }
                    "end" ";"
                    "end" ";" ;
struct_item     ::= struct_def | inherit_def ;
```

**Example 1 — Generic module structure:**

```mizar
template ModuleStr<R being Ring>
  definition
    struct ModuleOver over R where
      field carrier -> non empty set;
      field add -> BinOp of carrier;
      field smul -> Function of [:R.carrier, carrier:], carrier;
    end;
  end;
end;

:: Usage
let M be ModuleOver over INT_RING;
```

**Example 2 — Generic ordered structure:**

```mizar
template OrderedStr<T being type>
  definition
    struct OrdStr over T where
      field carrier -> T;
      field order -> Relation of T;
    end;

    inherit OrdStr from 1-sorted where
      field carrier from carrier;
    end;
  end;
end;
```

**Example 3 — Structure template with multiple parameters:**

```mizar
template BilinearStr<F being Field, V being VectorSpace over F, W being VectorSpace over F>
  definition
    struct BilinearMap over F, V, W where
      field carrier -> Function of [:V.carrier, W.carrier:], F.carrier;
      property kernel -> Subobject of V;
    end;
  end;
end;

:: Usage
let B be BilinearMap over REAL, V, W;
```

**Logic Encoding:**

A template structure `struct S<T>` generates, for each instantiation `T := T₀`:
- A new predicate `is_S_T₀(x)`
- Field selector axioms: `∀x. (is_S_T₀(x) → is_T₀(field(x)))`
- Extensionality: `∀x,y. (is_S_T₀(x) ∧ is_S_T₀(y) ∧ f₁(x)=f₁(y) ∧ ... → x=y)`

## 18.6 Template for Predicates (pred)

Predicate templates define families of predicates indexed by types. They generalize the dependent parameter syntax from Chapter 9.

**Syntax:**

```ebnf
pred_template ::= "template" template_name "<" type_param_list ">"
                  "definition"
                  { pred_item }
                  "end" ";"
                  "end" ";" ;
pred_item     ::= "let" identifier "be" type_expression ";"
                | pred_def ;
```

**Example 1 — Generic congruence predicate:**

```mizar
template CongruencePred<G being Group>
  definition
    let H be Subgroup of G;
    let a, b be Element of G;
    pred CongruenceDef: a === b (mod H) means
      a * b" in H;
  end;
end;

:: Usage
let G be Group;
let H be Subgroup of G;
let a, b be Element of G;
assume a === b (mod H);
```

**Example 2 — Generic divisibility:**

```mizar
template DivisibilityPred<R being Ring>
  definition
    let a, b be Element of R;
    pred DividesDef: a divides_in(R) b means
      ex c being Element of R st b = a * c;
    reflexivity
    proof
      let a be Element of R;
      take c = 1_R;
      thus a = a * 1_R by mml.algebra.ring.mul_one;
    end;
  end;
end;
```

**Example 3 — Predicate template with constraint:**

```mizar
template MetricPred<M being MetricSpace>
where M is non empty
  definition
    let x, y be Element of M;
    pred ConvergesDef: x, y are_at_distance_zero means
      M.distance(x, y) = 0;
    symmetry
    proof
      let a, b be Element of M;
      assume a, b are_at_distance_zero;
      thus M.distance(b, a) = 0
        by mml.topology.metric.Dist_symmetric;
    end;
  end;
end;
```

**Logic Encoding:**

A template predicate `pred P<T>(a, b) means φ[a, b, T]` generates, for each instantiation `T := T₀`:

```
∀a, b. (is_T₀(a) ∧ is_T₀(b) → (P(a, b, T₀) ↔ φ[a, b, T₀]))
```

## 18.7 Template for Functors (func)

Functor templates define families of operations parameterized by types or other structures.

**Syntax:**

```ebnf
func_template ::= "template" template_name "<" type_param_list ">"
                  "definition"
                  { func_item }
                  "end" ";"
                  "end" ";" ;
func_item     ::= "let" identifier "be" type_expression ";"
                | func_def ;
```

**Example 1 — Generic identity function:**

```mizar
template IdentityFunc<T being type>
  definition
    func IdDef: id(T) -> Function of T, T equals
      { [x, x] where x is Element of T : x in T };
  end;
end;

:: Usage
let f = id(NAT);
```

**Example 2 — Generic zero element:**

```mizar
template ZeroElement<G being Group>
  definition
    func ZeroDef: zero(G) -> Element of G means
      for a being Element of G holds it + a = a & a + it = a;
    existence
    proof
      :: G is a group, so neutral element exists
      consider e being Element of G such that
        A1: for a being Element of G holds e * a = a & a * e = a
        by mml.algebra.group.Group_identity_exists;
      take e;
      thus thesis by A1;
    end;
    uniqueness
    proof
      let e1, e2 be Element of G;
      assume A1: for a being Element of G holds e1 + a = a & a + e1 = a;
      assume A2: for a being Element of G holds e2 + a = a & a + e2 = a;
      thus e1 = e1 + e2 by A2
             .= e2 by A1;
    end;
  end;
end;
```

**Example 3 — Generic norm functor:**

```mizar
template NormFunc<V being NormedSpace over REAL>
  definition
    let v be Element of V;
    func NormDef: ||v|| -> non negative Real means
      it = V.norm(v);
    existence proof ... end;
    uniqueness proof ... end;
  end;
end;
```

**Example 4 — Functor template with multiple parameters:**

```mizar
template TensorProduct<F being Field, V being VectorSpace over F, W being VectorSpace over F>
  definition
    func TensorDef: V (x) W -> VectorSpace over F means
      :: universal property of tensor product
      for L being VectorSpace over F,
          phi being BilinearMap over F, V, W st phi is bilinear
        ex! psi being Homomorphism of it, L
          st psi * canonical_map(V, W) = phi;
    existence proof ... end;
    uniqueness proof ... end;
  end;
end;
```

**Logic Encoding:**

A template functor `func F<T>(x) -> S means φ[F(x), x, T]` generates, for each instantiation `T := T₀`:

```
∀x. (is_T₀(x) → ∃!y. (is_S(y) ∧ φ[y, x, T₀]))
∀x. (is_T₀(x) → φ[F_T₀(x), x, T₀])
```

## 18.8 Template for Theorems (theorem / scheme)

Template theorems state mathematical propositions that hold for any instantiation of their parameters. This subsumes the classical Mizar `scheme` construct.

### 18.8.1 Type-Parameterized Theorems

The simplest form of template theorem is parameterized only over types.

**Syntax:**

```ebnf
thm_template ::= "template" template_name "<" type_param_list ">"
                 [ "where" constraint_list ]
                 theorem_item
                 "end" ";" ;
```

**Example 1 — Generic commutativity theorem:**

```mizar
template CommGroup<G being CommutativeGroup>
  theorem CommMul:
    for a, b being Element of G holds a * b = b * a
  proof
    let a, b be Element of G;
    thus a * b = b * a by mml.algebra.group.CommGroup_commutative;
  end;
end;
```

**Example 2 — Generic injectivity theorem:**

```mizar
template InjectiveHom<G being Group, H being Group>
where G is non trivial
  theorem InjectiveKernel:
    for phi being Homomorphism of G, H
      holds phi is injective iff
        (for a being Element of G st phi(a) = 1_H holds a = 1_G)
  proof
    ...
  end;
end;
```

### 18.8.2 Predicate-Parameterized Theorems (Schemes)

Template theorems with predicate parameters directly generalize the classical `scheme` mechanism. A predicate parameter `P being pred of (T)` allows the theorem to quantify over a family of predicates at the meta-level.

**Syntax:**

```ebnf
scheme_template ::= "template" template_name
                    "<" ( type_param | pred_param | func_param )
                        { "," ( type_param | pred_param | func_param ) } ">"
                    [ "where" hypothesis_list ]
                    theorem_item
                    "end" ";" ;

hypothesis_list ::= "provided" hypothesis { "and" hypothesis } ;
hypothesis      ::= label_identifier ":" formula ;
```

The `provided` keyword introduces named hypotheses that are required at each instantiation. This closely mirrors the classical Mizar scheme syntax.

**Example 1 — Natural number induction scheme:**

```mizar
template NatInduction<P being pred of (Nat)>
  theorem IndMain:
    P[0] & (for n being Nat st P[n] holds P[n+1])
    implies for n being Nat holds P[n]
  provided
    Base: P[0] and
    Step: for n being Nat st P[n] holds P[n+1]
  proof
    assume Base and Step;
    let n be Nat;
    :: Proof by Nat_Induction_Axiom
    thus P[n] by Base, Step, mml.number.natural.Nat_induction;
  end;
end;
```

**Example 2 — Classical scheme form (alternate notation):**

The classical Mizar `scheme` syntax is supported as a shorthand:

```mizar
:: Classical Mizar-style (accepted for backward compatibility)
scheme NatInd{P: Nat -> bool}:
  for n being Nat holds P[n]
provided
  Base: P[0] and
  Step: for n being Nat st P[n] holds P[n+1];
```

This is semantically equivalent to the template form above. See §18.9.3 for how schemes are applied in proofs.

**Example 3 — Transfinite induction scheme:**

```mizar
template TransfiniteInduction<A being WellFoundedOrder, P being pred of (Element of A)>
  theorem TFInd:
    (for x being Element of A st
      (for y being Element of A st y <<< x holds P[y])
      holds P[x])
    implies for x being Element of A holds P[x]
  provided
    Step: for x being Element of A st
            (for y being Element of A st y <<< x holds P[y])
            holds P[x]
  proof
    ...
  end;
end;
```

**Example 4 — Structural induction over lists:**

```mizar
template ListInduction<T being type, P being pred of (List of T)>
  theorem ListInd:
    (for l being List of T holds P[l])
  provided
    NilCase:  P[{}] and
    ConsCase: for x being T, l being List of T st P[l] holds P[x :: l]
  proof
    let l be List of T;
    :: Induction over list length
    defpred Q[n] means for l being List of T st len l = n holds P[l];
    thus P[l] from NatInduction<Q>[NilCase, ConsCase];
  end;
end;
```

### 18.8.3 Functor-Parameterized Theorems

Theorems can also be parameterized over functions, useful for stating universal properties of algebraic constructions.

**Example — Uniqueness of homomorphic extension:**

```mizar
template HomExtension<G being Group, H being Group,
                      phi being func of (Element of G) -> Element of H>
where phi is group_homomorphism
  theorem ExtUnique:
    for psi being func of (Element of G) -> Element of H
      st psi is group_homomorphism &
         (for g being Element of Generator of G holds psi[g] = phi[g])
      holds for g being Element of G holds psi[g] = phi[g]
  provided
    PhiIsHom: phi is group_homomorphism
  proof
    ...
  end;
end;
```

### 18.8.4 Mixed-Parameter Theorems

Templates may combine all three parameter kinds, reflecting the full generality needed in abstract mathematics.

**Example — Generic fixpoint theorem schema:**

```mizar
template FixpointSchema<T being type,
                        F being func of (T) -> T,
                        P being pred of (T, T)>
where P is a_partial_order
  theorem FixpointExists:
    (for x, y being T st P[x, y] holds P[F[x], F[y]])
    implies
    ex x being T st F[x] = x
  provided
    FMonotone: for x, y being T st P[x, y] holds P[F[x], F[y]]
  proof
    ...
  end;
end;
```

## 18.9 Template Specialization and Instantiation

### 18.9.1 Explicit Instantiation

Templates are made available in a module via the `instantiate` declaration. This generates all definitions, registrations, and theorems from the template body for the specified arguments.

**Syntax (EBNF):**

```ebnf
instantiate_decl ::= "instantiate" template_name
                     "<" instantiation_arg_list ">"
                     [ "where" proof_list ]
                     [ "as" namespace_alias ] ";" ;

instantiation_arg_list ::= instantiation_arg { "," instantiation_arg } ;
instantiation_arg      ::= type_arg | pred_arg | func_arg ;
type_arg        ::= type_expression ;
pred_arg        ::= "pred" "(" locus_list ")" formula ;
func_arg        ::= "func" "(" locus_list ")" term_expression ;

proof_list      ::= proof_item { "," proof_item } ;
proof_item      ::= label_identifier proof ;
namespace_alias ::= identifier ;
```

**Example 1 — Simple type instantiation:**

```mizar
instantiate HomMode<INT_GROUP, REAL_GROUP>;
:: Now Homomorphism of INT_GROUP, REAL_GROUP is available as a type
```

**Example 2 — Instantiation with constraint proof:**

```mizar
instantiate FinDimMode<REAL_FIELD>
where ex n being Nat st n > 0
proof
  take 1;
  thus 1 > 0;
end;
```

**Example 3 — Instantiation with namespace alias:**

```mizar
instantiate ModuleStr<REAL_RING> as RealMod;
:: Access the generated struct as RealMod.ModuleOver
```

**Example 4 — Predicate instantiation (scheme):**

```mizar
instantiate NatInduction<pred n is prime>
where
  Base: 2 is prime proof ... end,
  Step: for n being Nat st n is prime holds ...;
```

### 18.9.2 Implicit Instantiation via Type Inference

For template modes and structures, explicit instantiation is often unnecessary. The type checker instantiates templates implicitly when a parameterized type is used.

```mizar
:: Implicit instantiation: HomMode<G, H> is instantiated automatically
let phi be Homomorphism of G, H;

:: Implicit instantiation: SubobjectMode<G.carrier> is instantiated automatically
let S be Subobject of G;
```

Implicit instantiation proceeds as follows:
1. The verifier matches the type expression against known templates.
2. Template parameters are unified with the supplied arguments.
3. If the match is unique and all constraints are satisfied, the instantiation proceeds automatically.
4. If constraints cannot be discharged automatically, the user must provide explicit `instantiate` declarations with proofs.

### 18.9.3 Scheme Application in Proofs

Template theorems with predicate or functor parameters are applied inside proofs using the `from` keyword (scheme application syntax).

**Syntax (EBNF):**

```ebnf
scheme_application ::= "from" template_name "<" scheme_arg_list ">"
                        "(" proof_arg_list ")" ";" ;

scheme_arg_list    ::= scheme_arg { "," scheme_arg } ;
scheme_arg         ::= type_expression
                     | "pred" "(" locus_list ")" formula
                     | "func" "(" locus_list ")" term_expression ;

proof_arg_list     ::= proof_arg { "," proof_arg } ;
proof_arg          ::= label_reference | proof ;
```

**Example 1 — Applying a natural number induction scheme:**

```mizar
:: Goal: prove for all n being Nat, n * 2 is even
theorem NatMulEven:
  for n being Nat holds n * 2 is even
proof
  defpred P[n] means n * 2 is even;
  :: Apply the NatInduction scheme with P[n] = (n * 2 is even)
  thus for n being Nat holds P[n]
    from NatInduction<pred n is_even(n * 2)>(
      proof :: P[0]: 0 * 2 = 0 is even
        thus 0 * 2 is even by mml.number.nat.zero_even;
      end,
      proof :: For all n, P[n] implies P[n+1]
        let n be Nat;
        assume A1: n * 2 is even;
        n * 2 + 2 = (n + 1) * 2 by mml.number.nat.distrib;
        thus (n + 1) * 2 is even by A1, mml.number.nat.even_plus_even;
      end
    );
end;
```

**Example 2 — Classical scheme application syntax (shorthand):**

```mizar
:: Classical shorthand (preserved for compatibility)
theorem Th:
  for n being Nat holds P[n]
proof
  ...
  thus thesis from NatInd(Base, Step);
end;
```

**Example 3 — Applying a predicate-parameterized scheme:**

```mizar
:: Using structural induction on lists
theorem ListLen:
  for T being type, l being List of T holds len l >= 0
proof
  defpred Q[l] means len l >= 0;
  thus for l being List of T holds Q[l]
    from ListInduction<T, pred l is_nonneg_len(l)>(
      proof thus len ({} : List of T) >= 0; end,
      proof
        let x be T, l be List of T;
        assume len l >= 0;
        thus len (x :: l) >= 0 by mml.data.list.Cons_len_pos;
      end
    );
end;
```

### 18.9.4 Partial Specialization

A template can be partially specialized by fixing some parameters and leaving others free. This yields a new template.

**Syntax (EBNF):**

```ebnf
partial_spec ::= "template" new_name "<" remaining_params ">"
                 "=" template_name "<" partial_args ">" ";" ;
partial_args ::= partial_arg { "," partial_arg } ;
partial_arg  ::= type_expression | "_" ;
```

The placeholder `_` denotes a parameter left free.

**Example:**

```mizar
:: Partial specialization: fix F = REAL_FIELD, leave V free
template RealVectorSpace<V being VectorSpace over REAL_FIELD>
  = VectorSpaceThm<REAL_FIELD, _>;

:: Instantiate the specialized template
instantiate RealVectorSpace<EUCLIDEAN_SPACE_3>;
```

## 18.10 Logic Encoding Details

Templates are meta-level constructs that do not directly add axioms to the FOL theory. Instead, each **instantiation** generates a collection of axioms and proof obligations in the current theory.

### 18.10.1 Templates as Axiom Schemas

A template `template T<A being type, ...> ... end;` is treated as an **axiom schema** — a recipe for generating FOL axioms when applied. The schema is **not** itself a first-order formula; it is a meta-level object in the type system.

| Template Level | FOL Status |
|---|---|
| Template declaration | No FOL axioms generated (schema only) |
| Explicit `instantiate` | Generates all axioms from the body for the given arguments |
| Implicit instantiation via type inference | Same effect as explicit instantiation |

**Verification guarantee**: The verifier checks each template body **once symbolically** at declaration time, verifying that all proof obligations in the body are discharged relative to the parameter constraints. This ensures that every instantiation is valid without re-proving.

> [!IMPORTANT]
> The symbolic check at template declaration time is performed **under the constraints** specified in `where`. At instantiation sites, the user must prove these constraints hold. This two-phase verification preserves soundness.

### 18.10.2 Type Parameter Encoding

A type parameter `T being type` is encoded as an **uninterpreted predicate symbol** `is_T(x)` in the schema.

| Template Source | FOL Schema |
|---|---|
| `T being type` | Schema variable `is_T/1` (uninterpreted) |
| `T being Group` | Schema variable `is_T/1` with guard axiom `∀x. is_T(x) → is_Group(x)` |
| `let x be T;` | Guard `is_T(x)` added as antecedent |

**Example:**

```mizar
template CommMul<G being CommutativeGroup>
  theorem:
    for a, b being Element of G holds a * b = b * a;
```

FOL schema (where `is_G` is the schema variable for `G`):

```
∀G. (∀x. is_G(x) → is_CommutativeGroup(x))
  → ∀a, b. (is_G(a) ∧ is_G(b) → mul(a,b) = mul(b,a))
```

For instantiation `G := INT_GROUP`:

```
∀a, b. (is_INT_GROUP(a) ∧ is_INT_GROUP(b) → mul(a,b) = mul(b,a))
```

### 18.10.3 Predicate Parameter Encoding (Schemes)

A predicate parameter `P being pred of (T)` is encoded as an **uninterpreted predicate symbol** `P/1` in the schema. Since FOL does not support second-order quantification, the schema represents a **family of first-order formulas** — one for each predicate `P` that can be substituted.

| Template Source | FOL Schema |
|---|---|
| `P being pred of (T)` | Schema variable `P/1` (uninterpreted predicate) |
| `P[x]` | `P(x)` in generated formula |
| `for x st P[x] holds Q` | `∀x. (P(x) → Q)` in generated formula |

**Example — NatInduction scheme:**

```mizar
template NatInduction<P being pred of (Nat)>
  theorem IndMain:
    P[0] & (for n being Nat st P[n] holds P[n+1])
    implies for n being Nat holds P[n];
```

FOL schema (one instance for each predicate `P`):

```
P(0) ∧ (∀n. is_Nat(n) → P(n) → P(succ(n)))
  → ∀n. is_Nat(n) → P(n)
```

This is precisely the **natural number induction axiom schema** in FOL. The trusted kernel verifies each specific instance (e.g., `P(n) := is_prime(n)`) without requiring higher-order reasoning.

**Summary table for scheme encoding:**

| Mizar Schema Form | FOL Encoding |
|---|---|
| `P being pred of (T)` | Uninterpreted predicate `P/1` in schema |
| `P[x]` in formula | `P(x)` |
| `from SchName<P>(Base, Step)` | Instantiation of schema with `P` replaced by concrete predicate |
| Application in `by` reference | Substitute `P` and generate specific first-order axiom |

### 18.10.4 Functor Parameter Encoding

A functor parameter `F being func of (T) -> S` is encoded as an **uninterpreted function symbol** `F/1` with a type guard axiom.

| Template Source | FOL Schema |
|---|---|
| `F being func of (T) -> S` | Uninterpreted function `F/1` with guard `∀x. is_T(x) → is_S(F(x))` |
| `F[x]` in term | `F(x)` |
| `for x holds F[x] = ...` | `∀x. F(x) = ...` |

**Example:**

```mizar
template MonoidHom<M being Monoid, N being Monoid,
                   phi being func of (Element of M) -> Element of N>
  theorem HomPreservesId:
    phi[1_M] = 1_N
  provided
    PhiHom: for a, b being Element of M
              holds phi[a * b] = phi[a] * phi[b]
  proof
    ...
  end;
```

FOL schema:

```
(∀a, b. is_M(a) ∧ is_M(b) → phi(mul_M(a,b)) = mul_N(phi(a), phi(b)))
  → phi(id_M) = id_N
```

For instantiation `phi := concrete_function`:

```
(∀a, b. is_M(a) ∧ is_M(b) → concrete_function(mul_M(a,b))
                              = mul_N(concrete_function(a), concrete_function(b)))
  → concrete_function(id_M) = id_N
```

### 18.10.5 Constraint Encoding

Template constraints (`where` clause) are encoded as **conditional guards** at the meta-level. They do not appear as axioms in the generated theory; instead, they are conditions that must be proved at each instantiation site.

| Template Source | FOL Effect |
|---|---|
| `where φ` | Obligation `φ` must be proved at each `instantiate` site |
| `provided H: φ` | Obligation `φ` is a hypothesis; user supplies proof at application site |
| Verified constraint | Antecedent added to all generated axioms from the template body |

**Example:**

```mizar
template FinVSThm<F being Field, V being VectorSpace over F>
where V is finite_dimensional
  theorem BasisCard:
    card (Basis of V) = dim V;
```

Generated axiom (per instantiation `F := F₀`, `V := V₀` with proof that `V₀ is finite_dimensional`):

```
is_Field(F₀) ∧ is_VectorSpace(V₀, F₀) ∧ is_finite_dimensional(V₀)
  → card(Basis(V₀)) = dim(V₀)
```

## 18.11 Complete Syntax (EBNF)

Summary of all template-related syntax.

```ebnf
(* === Template Declaration === *)
template_decl   ::= "template" template_name
                    "<" param_decl_list ">"
                    [ "where" constraint_list ]
                    template_body
                    "end" ";" ;

template_name   ::= identifier ;

(* === Template Parameters === *)
param_decl_list ::= param_decl { "," param_decl } ;
param_decl      ::= type_param | pred_param | func_param ;

type_param      ::= identifier "being" ( "type" | type_expression ) ;
pred_param      ::= identifier "being" "pred" "of" "(" type_list ")" ;
func_param      ::= identifier "being" "func" "of"
                    "(" type_list ")" "->" type_expression ;

type_list       ::= type_expression { "," type_expression } ;

(* === Template Constraints === *)
constraint_list ::= constraint { "," constraint } ;
constraint      ::= formula ;

hypothesis_list ::= "provided" hypothesis { "and" hypothesis } ;
hypothesis      ::= label_identifier ":" formula ;

(* === Template Body === *)
template_body   ::= { template_item } ;
template_item   ::= definition_block
                  | registration_block
                  | theorem_item ;

definition_block   ::= "definition" { def_content } "end" ";" ;
registration_block ::= "registration" { registration_item } "end" ";" ;
theorem_item       ::= ( "theorem" | "conjecture" )
                       label_identifier ":" formula
                       [ hypothesis_list ]
                       [ justification ] ";" ;

(* === Classical Scheme Syntax (compatibility shorthand) === *)
scheme_decl     ::= "scheme" scheme_name
                    "{" scheme_param_list "}" ":"
                    formula
                    [ "provided" hypothesis { "and" hypothesis } ]
                    justification ";" ;

scheme_name     ::= identifier ;

scheme_param_list ::= scheme_param { "," scheme_param } ;
scheme_param      ::= identifier ":" ( "set"
                                     | mode_name
                                     | type_expression "->" type_expression ) ;

(* === Instantiation === *)
instantiate_decl ::= "instantiate" template_name
                     "<" instantiation_arg_list ">"
                     [ "where" proof_list ]
                     [ "as" namespace_alias ] ";" ;

instantiation_arg_list ::= instantiation_arg { "," instantiation_arg } ;
instantiation_arg      ::= type_expression
                         | "pred" "(" locus_list ")" formula
                         | "func" "(" locus_list ")" term_expression ;

proof_list      ::= proof_item { "," proof_item } ;
proof_item      ::= label_identifier proof ;

namespace_alias ::= identifier ;

(* === Partial Specialization === *)
partial_spec ::= "template" new_name "<" remaining_param_list ">"
                 "=" template_name "<" partial_arg_list ">" ";" ;
partial_arg  ::= type_expression | "_" ;

(* === Scheme Application in Proofs === *)
scheme_application ::= "from" template_name
                       [ "<" scheme_arg_list ">" ]
                       "(" proof_arg_list ")" ;

scheme_arg_list    ::= scheme_arg { "," scheme_arg } ;
scheme_arg         ::= type_expression
                     | "pred" "(" locus_list ")" formula
                     | "func" "(" locus_list ")" term_expression ;

proof_arg_list     ::= proof_arg { "," proof_arg } ;
proof_arg          ::= label_reference | proof ;

(* --- Predicate/Functor application inside template body --- *)
pred_param_app  ::= identifier "[" term_expression { "," term_expression } "]" ;
func_param_app  ::= identifier "[" term_expression { "," term_expression } "]" ;
```

**Summary of template parameter kinds:**

| Kind | Declaration | Application | FOL Status |
|---|---|---|---|
| Type | `T being type` | Used as type in expressions | Uninterpreted predicate `is_T` |
| Constrained type | `G being Group` | Used as type; guard `is_Group(G)` added | Uninterpreted pred with guard |
| Predicate | `P being pred of (T)` | `P[x]` in formulas | Uninterpreted predicate `P/n` |
| Functor | `F being func of (T) -> S` | `F[x]` in terms | Uninterpreted function `F/n` |

**Summary of instantiation forms:**

| Form | Syntax | When to Use |
|---|---|---|
| Explicit | `instantiate T<args>` | Forced instantiation with proof obligations |
| Implicit | (none — type inference) | Simple type parameters; no constraints |
| Scheme application | `from S<P>(proof1, proof2)` | Predicate/functor parameters in proofs |
| Partial specialization | `template T2<...> = T1<..., _>` | Fix some parameters, leave others open |

> [!NOTE]
> For reasoning patterns that apply the template theorems defined here (induction schemes, recursive definitions, and standard pattern libraries), see [Chapter 19 (Reasoning Patterns)](./19.reasoning_patterns.md).

> [!NOTE]
> For overload resolution when multiple template instantiations define overlapping symbols, see [Chapter 20 (Overload Resolution)](./20.overload_resolution.md).
