# Index

- [1.Introduction](./01.introduction.md)
- [2.Lexical Structure](./02.lexical_structure.md)
- [3.Type System](./03.type_system.md)
- [4.Variables and Constants](./04.variables_and_constants.md)
- [5.Modes](./05.modes.md)
- [6.Attributes](./06.attributes.md)
- [7.Structures](./07.structures.md)
- [8.Type Inference](./08.type_inference.md)
- [9.Predicates](./09.predicates.md)
- [10.Functors](./10.functors.md)
- [11.Symbol Management](./11.symbol_management.md)
- [12.Modules and Namespaces](./12.modules_and_namespaces.md)
- [13.Term Expressions](./13.term_expression.md)
- [14.Formulas](./14.formulas.md)
- [15.Statements](./15.statements.md)
- [16.Theorems and Proofs](./16.theorems_and_proofs.md)
- [17.Clusters and Registrations](./17.clusters_and_registrations.md)
- [18.Templates](./18.templates.md)
- 19.Reasoning Patterns
    - 19.1. Template Theorem Application Patterns
    - 19.2. Inductive Reasoning
        - 19.2.1. Natural Number Induction
        - 19.2.2. Structural Induction
        - 19.2.3. Well-Founded Induction
    - 19.3. Recursive Definitions
    - 19.4. Standard Reasoning Pattern Library
    - TODO: Explain how to use `by` and `@hint`
    - TODO: Bulk citation using `by <module_name>.*`
- 20.Overload Resolution
    - 20.1. Overview
    - 20.2. Implicit Type Conversions
    - 20.3. Explicit Type Conversions
    - 20.4. Overload Resolution
    - 20.5. Symbol Redefinition
    - 20.6. Advanced Resolution Mechanisms
- 21.Algorithm and Verification
    - 21.1. Algorithm Syntax
    - 21.2. Control Flow (if, while, for, match)
    - 21.3. Non-determinism (Pick)
    - 21.4. Contracts (requires, ensures, assert)
    - 21.5. Loop Verification (invariant, decreasing)
    - 21.6. Termination Proofs
    - 21.7. Execution Model and Computability
    - 21.8. Code Extraction
- 22.Error Handling and Diagnostics
    - 22.1. Syntax Errors
    - 22.2. Type Errors
    - 22.3. Logical Inconsistencies
    - 22.4. Warning Messages
    - 22.5. Best Practices and Common Pitfalls
- 23.Source Code Annotation and ATP Integration
    - 23.1. Comment Annotations
    - 23.2. Library Annotations
    - 23.3. LaTeX Expression Annotations
    - 23.4. Type-checking Annotations
    - 23.5. Reasoning Annotations (`@[hint]`, `@[simp]`, solver selection)
    - 23.6. Other Annotations
    - 23.7. Property-based Verification Pipeline
        - 23.7.1. Term Normalization (commutativity, idempotence, involutiveness, projectivity)
        - 23.7.2. Extended Congruence Closure
        - 23.7.3. Built-in Inference Rules (symmetry, reflexivity, etc.)
        - 23.7.4. Checker Hint Database
    - 23.8. ATP Integration
        - 23.8.1. Backend Provers (Vampire, E, CVC5)
        - 23.8.2. Property Encoding for ATP (TPTP/SMT-LIB)
        - 23.8.3. Proof Reconstruction and Certificate Verification
- 24.Package Management and Build System
    - 24.1. Manifest File Format (mizar.pkg)
    - 24.2. Versioning and Dependency Resolution
    - 24.3. Workspace Layout
    - 24.4. Build Lifecycle and Reproducibility
- 25.Documentation Generation
    - 25.1. Documentation Comments Syntax
    - 25.2. Cross-Referencing and Hyperlinks
    - 25.3. Mathematical Formula Rendering
    - 25.4. Output Formats (HTML, PDF)
- Appendices
    - A. Grammar Summary
    - B. Compatibility with Previous Versions
    - C. Reserved Keywords
    - D. Operator Precedence
    - E. Glossary of Terms
    - F. Recommended Coding Rules
    - G. Semantic Rules Summary
    - H. Language Design Rationale
