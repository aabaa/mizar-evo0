# 5. Modes

- [5. Modes](#5-modes)
  - [5.1 Definition and Purpose of Modes](#51-definition-and-purpose-of-modes)
  - [5.2 Syntax for Declaring and Using Modes](#52-syntax-for-declaring-and-using-modes)
  - [5.3 Type Inference with Modes](#53-type-inference-with-modes)
  - [5.4 Mode Implementation](#54-mode-implementation)
  - [5.5 Relationship between Modes and Structures](#55-relationship-between-modes-and-structures)
  - [5.6 Unified Mode Syntax](#56-unified-mode-syntax)
  - [5.7 Dependent Modes](#57-dependent-modes)
  - [5.8 Correctness Conditions](#58-correctness-conditions)
    - [5.8.1 Mode Property: `sethood`](#581-mode-property-sethood)
  - [5.9 Logic Encoding Details](#59-logic-encoding-details)
  - [5.10 Complete Syntax (EBNF)](#510-complete-syntax-ebnf)

## 5.1 Definition and Purpose of Modes

Modes are user-defined type constructors built on top of radix-types such as `set` or `struct`. They allow:

* **Abstraction** of mathematical concepts as types
* **Refinement** of types using attributes
* **Composition** of complex types
* **Dependency** on values (i.e., dependent types)

Modes are a central mechanism for type classification in Mizar, offering an abstract and modular alternative to structures.

## 5.2 Syntax for Declaring and Using Modes

**Syntax (EBNF)**:

```ebnf
mode_def       ::= "mode" label ":" mode_name [ type_params ] "is" attribute_chain radix_type ";" ;
label          ::= identifier ;
mode_name      ::= identifier ;
type_params    ::= ( "of" | "over" ) parameter_list ;
parameter_list ::= identifier { "," identifier } ;
attribute_chain ::= { [ "non" ] attribute_ref } ;
attribute_ref  ::= [ param_prefix ] [ struct_name "." ] attribute_name ;
param_prefix   ::= parameter "-" | "(" parameter_list ")" "-" ;
radix_type     ::= builtin_type | mode_name [ type_args ] | struct_name [ type_args ] ;
```

* `label`: Mandatory identifier for referencing this definition
* `mode_name`: Name of the mode being defined
* `type_params`: Optional parameters for dependent modes (`of` or `over`)
* `attribute_chain`: Zero or more attributes (possibly parameterized) refining the base type

### Mode Definition

```mizar
definition
  mode Label: <mode_name> is <attribute_chain> <type_expression>;
end;
```

Here, `<attribute_chain>` is a (possibly empty) sequence of predicates (possibly parameterized) that refine the base type. Attributes must be defined using the `attr` keyword (see Chapter 6).

Examples:

```mizar
definition
  mode IntegerDef: Integer is integer Number;
  mode PrimeDef: Prime is prime Integer;
  mode GroupDef: Group is non empty associative invertible unital Magma;
end;
```

### Mode Application

Modes are used in variable declarations, expressions, and type restrictions:

```mizar
let G be Group;
let n be Prime;
```

## 5.3 Type Inference with Modes

Mizar automatically infers type relations for variables declared with modes:

* Inference follows attribute clusters and structural inheritance
* Inference supports dependent modes and parameterized types

Examples:

```mizar
let n be Prime;  :: implies n is Integer and Number
let S be Subset of X;  :: implies S is set and S ⊆ X
```

## 5.4 Mode Implementation

Internally, each mode is interpreted as:

1. A predicate for membership (possibly with parameters for dependent modes)
2. A cluster registration linking attributes and base types

This supports a uniform and efficient type checking mechanism.

```mizar
definition
  mode Label: M is <attribute_chain> <type_expression>;
end;
```

is equivalent to defining a predicate and a cluster registration.

## 5.5 Relationship between Modes and Structures

Modes and structures serve complementary roles. Use **structures** when you need to define composite types with internal fields (e.g., algebraic structures like rings or groups). Use **modes** when you want to classify or restrict existing types by logical properties without adding internal structure (e.g., prime numbers, continuous functions).

| Aspect     | Modes                                | Structures                         |
| ---------- | ------------------------------------ | ---------------------------------- |
| Definition | Abstract (via attributes)            | Concrete (via fields/properties)   |
| Usage      | Conceptual classification            | Data modeling and component access |
| Conversion | `qua` operator for structural access | Field/property access is explicit  |

Example:

```mizar
definition
  struct MetricStruct where
    field carrier -> set;
    field distance -> Function of [:carrier, carrier:], REAL;
  end;

definition
  mode MetricSpaceDef: MetricSpace is reflective discerning symmetric triangle MetricStruct;
end;
```

## 5.6 Unified Mode Syntax

Mizar enforces the `is` syntax for mode definitions, replacing the legacy `means` form. This ensures:

* Simplified parsing and inference
* Uniform representation across the language
* Clear separation between types (modes) and predicates (logical properties)

Instead of:

```mizar
definition
  mode Prime means <definition>;
end;
```

Use:

```mizar
definition
  let n be Nat;
  attr PrimeAttr: n is prime means <definition>;
  mode PrimeDef: Prime is prime Integer;
end;
```

## 5.7 Dependent Modes

Modes can be parameterized using `of` or `over`:

```mizar
definition
  mode SubsetDef: Subset of X is X-subset_like set;
  mode MatrixDef: Matrix over R is R-matrix_like set;
end;

let A be Matrix over REAL;
```

These forms are syntactic sugar for template-style definitions. For example, `Matrix over REAL` is equivalent to `Matrix[REAL]` in other notations.

Multiple parameters are supported:

```mizar
definition
  mode FinDimVSDef: FinDimVectorSpace over F, n is n-dimensional vector_space_like structure over F;
end;

let V be FinDimVectorSpace over COMPLEX, 5;
```

> [!WARNING]
> All variables used in the mode body must be declared in `type_params`. The following is an error because `n` is not declared:

```mizar
definition
  :: ERROR: 'n' is not declared in type_params
  mode FinDimVSDef: FinDimVectorSpace over F
  is n-dimensional vector_space_like structure over F;
end;
```

## 5.8 Correctness Conditions

Mode definitions require existence guarantees, typically provided by cluster registrations:

```mizar
registration
  cluster prime Integer;
  existence
  proof
    take 2; thus 2 is prime;
  end;
end;

definition
  mode PrimeDef2: Prime is prime Integer;
end;
```

To avoid warnings, ensure all mode base types with attribute chains have existential registrations.

Note: Existence checks for modes follow a two-stage policy. At the point of mode declaration (using the mode keyword), the system issues a warning if no existential registration is found. If such a mode is subsequently used (e.g., in variable declarations), and the required existence proof is still missing, a hard error is raised. This encourages early validation while supporting modular development.

### 5.8.1 Mode Property: `sethood`

The `sethood` property asserts that all instances of a mode form a **set** (not a proper class). This is essential for set-theoretic foundations, ensuring that comprehension over the mode's instances produces a well-defined set.

**Syntax (EBNF):**

```ebnf
mode_property ::= "sethood" justification ";" ;
```

**FOL Obligation:**

| Property | FOL Obligation |
|---|---|
| `sethood` | `∃S. ∀x. (is_T(x) → x ∈ S)` |

**Example:**

```mizar
definition
  mode FiniteOrdinalDef: FiniteOrdinal is ordinal finite set;
  sethood
  proof
    :: Must prove: ex S being set st
    ::   for x being FiniteOrdinal holds x in S
    take omega;
    let x be FiniteOrdinal;
    thus x in omega by mml.ordinal.Finite_ordinal_in_omega;
  end;
end;
```

**Verifier effect**: When `sethood` is proved for a mode T, the verifier permits Fraenkel expressions (set comprehensions) over elements of T. Without `sethood`, comprehension `{ f(x) where x is T : P(x) }` is rejected because the result might be a proper class.

> [!NOTE]
> For set comprehension restrictions, see [Chapter 13 (Term Expressions), §13.4.2](./13.term_expression.md#1342-set-comprehension-fraenkel-operator).

## 5.9 Logic Encoding Details

This section describes how modes map to First-Order Logic.

### 5.9.1 Modes as Predicates

Each mode `M` is encoded as a membership predicate. A variable declaration `let x be M` generates:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be Integer;` | `is_Integer(x)` |
| `let G be Group;` | `is_Group(G)` |
| `let S be Subset of X;` | `is_Subset(S, X)` |

### 5.9.2 Attribute Chain Expansion

Modes with attribute chains expand to conjunctions:

| Mizar Source | FOL Encoding |
| --- | --- |
| `mode Prime is prime Integer` | `∀x. is_Prime(x) ↔ (is_Integer(x) ∧ is_prime(x))` |
| `mode Group is non empty associative invertible unital Magma` | `∀x. is_Group(x) ↔ (is_Magma(x) ∧ ¬is_empty(x) ∧ is_associative(x) ∧ is_invertible(x) ∧ is_unital(x))` |

### 5.9.3 Dependent Mode Encoding

Dependent modes with parameters are encoded as multi-argument predicates:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let S be Subset of X;` | `is_Subset(S, X)` |
| `let V be FinDimVectorSpace over F, n;` | `is_FinDimVectorSpace(V, F, n)` |

### 5.9.4 Subtype Relationship

Mode inheritance generates implication axioms:

```
mode Prime is prime Integer
⇒  forall x (is_Prime(x) implies is_Integer(x))
```

## 5.10 Complete Syntax (EBNF)

Summary of mode-related syntax.

```ebnf
(* Mode Definition *)
mode_def       ::= "mode" label ":" mode_name [ type_params ] "is" attribute_chain radix_type ";"
                   [ mode_property ] ;
label          ::= identifier ;
mode_name      ::= identifier ;
type_params    ::= ( "of" | "over" ) parameter_list ;
parameter_list ::= identifier { "," identifier } ;
attribute_chain ::= { [ "non" ] attribute_ref } ;
attribute_ref  ::= [ param_prefix ] [ struct_name "." ] attribute_name ;
param_prefix   ::= parameter "-" | "(" parameter_list ")" "-" ;
radix_type     ::= builtin_type | mode_name [ type_args ] | struct_name [ type_args ] ;

(* Mode Property *)
mode_property  ::= "sethood" justification ";" ;

(* Mode Application *)
mode_application ::= mode_name [ type_args ] ;
type_args        ::= ( "of" | "over" ) argument_list ;
argument_list    ::= term_expression { "," term_expression } ;
```

