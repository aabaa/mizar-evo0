# 17. Clusters and Registrations

This chapter defines the syntax, semantics, and logic encoding of **cluster registrations** — the mechanisms by which attribute information is propagated automatically during type inference. Clusters are central to Mizar's soft typing system; they connect attributes to types and functors, enabling the verifier to derive properties without explicit user assertions.

- [17. Clusters and Registrations](#17-clusters-and-registrations)
  - [17.1 Overview](#171-overview)
  - [17.2 Registration Blocks](#172-registration-blocks)
  - [17.3 Existential Clusters](#173-existential-clusters)
  - [17.4 Conditional Clusters](#174-conditional-clusters)
  - [17.5 Functorial Clusters](#175-functorial-clusters)
  - [17.6 Reduction Registrations](#176-reduction-registrations)
  - [17.7 Cluster Resolution Rules](#177-cluster-resolution-rules)
  - [17.8 Interaction with Other Features](#178-interaction-with-other-features)
  - [17.9 Logic Encoding Details](#179-logic-encoding-details)
  - [17.10 Complete Syntax (EBNF)](#1710-complete-syntax-ebnf)

## 17.1 Overview

In Mizar's soft typing system (see [Chapter 3 (Type System)](./03.type_system.md)), types are composed of a **radix type** (mode or structure) and zero or more **attributes** (adjectives). Clusters bridge the gap between individual attribute definitions and the type inference engine by registering facts about attribute combinations.

There are four kinds of registrations:

| Registration Kind | Purpose | Correctness Condition |
|---|---|---|
| **Existential** | Prove that a type with given attributes is inhabited | `existence` |
| **Conditional** | Declare that one set of attributes implies another | `coherence` |
| **Functorial** | Declare that a functor's result has certain attributes | `coherence` |
| **Reduction** | Declare that a term can be simplified to another | `reducibility` |

All registrations appear inside `registration ... end` blocks and generate proof obligations that must be discharged before the registration takes effect.

> [!IMPORTANT]
> Cluster registrations are **global axioms** — once registered, they apply throughout the current module and all modules that import it. Incorrect registrations can compromise the soundness of the type system. This is why each registration requires a correctness proof.

## 17.2 Registration Blocks

All cluster and reduction registrations are enclosed in `registration ... end` blocks.

**Syntax (EBNF):**

```ebnf
registration_block ::= "registration" { registration_item } "end" ";" ;
registration_item  ::= existential_registration
                     | conditional_registration
                     | functorial_registration
                     | reduction_registration ;
```

**Example:**

```mizar
registration
  cluster EmptyFiniteExists: empty finite set;
  existence proof ... end;

  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence proof ... end;
end;
```

A single `registration` block may contain multiple registration items. Each item has its own correctness condition.

**Mandatory labels**

Every registration item must carry a **label** — an identifier placed immediately after the registration keyword, separated by a colon:

```
cluster Label: ...
reduce  Label: ...
```

Labels are required (not optional) for the following reasons:

- **Traceability**: proofs can cite a specific registration by name in `by` justifications.
- **Error messages**: the verifier reports errors by label, not by position.
- **Module interface**: labels are part of the module's public interface and can be selectively imported or overridden.

Labels on registrations follow the same naming conventions as theorem labels. They must be unique within their enclosing module.

> [!NOTE]
> The `registration` block is a top-level declaration. It may use `let` to introduce parameters, similar to `definition` blocks. See §17.3.3 for parameterized registrations.

## 17.3 Existential Clusters

An **existential cluster** registers the fact that a type qualified by certain attributes is **inhabited** — i.e., at least one object of that type exists, satisfying all specified attributes.

**Syntax (EBNF):**

```ebnf
existential_registration ::= "cluster" label ":" adjective_list type_expression ";"
                              "existence" justification ";" ;
adjective_list           ::= adjective { adjective } ;
adjective                ::= [ "non" ] [ param_prefix ] attribute_name ;
```

### 17.3.1 Basic Existential Registration

**Example:**

```mizar
registration
  :: Register that there exists an empty finite set
  cluster EmptyFiniteExists: empty finite set;
  existence
  proof
    take {};
    thus {} is empty finite set;
  end;
end;
```

After this registration, the type `empty finite set` is usable in variable declarations without further existence proofs:

```mizar
let S be empty finite set;  :: OK — existence registered
```

### 17.3.2 Existential Registration for Structures

**Example:**

```mizar
registration
  :: Register that there exists a non empty Group
  cluster NonEmptyGroupExists: non empty Group;
  existence
  proof
    set G = SymmetricGroup(3);
    take G;
    thus G is non empty Group by GroupTheory.Sym3_is_Group;
  end;
end;
```

### 17.3.3 Parameterized Existential Registration

Registration items may depend on parameters introduced by `let` within the registration block.

**Example:**

```mizar
registration
  let X be non empty set;
  cluster NonEmptyFiniteSubsetExists: non empty finite Subset of X;
  existence
  proof
    set A = { the Element of X };
    take A;
    thus A is non empty finite Subset of X;
  end;
end;
```

> [!NOTE]
> The expression `the Element of X` is the **definite description operator** (choice operator), which selects an arbitrary element from a non-empty type. It corresponds to Hilbert's ε-operator in FOL. The syntax and semantics are formally defined in [Chapter 13 (Term Expressions)](./13.term_expression.md).

### 17.3.4 When Existential Registrations Are Required

Existential registrations are **required** in the following situations. The verifier raises an error if the registration is missing.

| Situation | Example | Requirement |
|---|---|---|
| Declaring a variable with attributed type | `let x be prime Nat;` | Required — verifier error if missing |
| Defining a mode with attributed base | `mode Prime is prime Integer;` | Required — verifier error if missing |
| Using an attributed type in a functor return | `func F(x) -> non zero Real` | Required — verifier error if missing |

> [!IMPORTANT]
> All attributed types must have a corresponding existential registration before use. This policy ensures that no empty type is introduced into the system, maintaining the soundness of the type system. See [Chapter 5 (Modes), §5.8](./05.modes.md#58-correctness-conditions) for details.

## 17.4 Conditional Clusters

A **conditional cluster** registers an attribute implication: if an object of a given type has certain attributes (the *antecedent*), then it automatically has additional attributes (the *consequent*).

**Syntax (EBNF):**

```ebnf
conditional_registration ::= "cluster" label ":" antecedent_adjectives "->"
                              consequent_adjectives "for" type_expression ";"
                              "coherence" justification ";" ;
antecedent_adjectives    ::= adjective_list ;
consequent_adjectives    ::= adjective_list ;
```

### 17.4.1 Basic Conditional Registration

**Example:**

```mizar
registration
  :: Every empty set is finite
  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence
  proof
    let S be set;
    assume S is empty;
    thus S is finite by mml.set.Empty_is_finite;
  end;
end;
```

After this registration, the verifier automatically infers `finite` whenever it knows a set is `empty`. The label `EmptyImpliesFinite` can also be cited explicitly in proofs:

```mizar
let S be empty set;
:: The verifier now knows: S is empty AND S is finite (by cluster)
S is finite;  :: automatically true, no proof needed
:: or: S is finite by EmptyImpliesFinite;  :: explicit citation
```

### 17.4.2 Multi-Attribute Conditional Clusters

Both the antecedent and consequent may contain multiple attributes.

**Example:**

```mizar
registration
  :: A finite non empty lattice is complete
  cluster FiniteNonEmptyLatticeComplete: finite non empty -> complete for Lattice;
  coherence
  proof
    let L be Lattice;
    assume L is finite non empty;
    thus L is complete by mml.order.Finite_Lattice_complete;
  end;
end;
```

### 17.4.3 Chained Conditional Clusters

Multiple conditional registrations can form implication chains that the verifier resolves transitively.

```mizar
registration
  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence proof ... end;

  cluster FiniteImpliesCountable: finite -> countable for set;
  coherence proof ... end;
end;

:: Now the verifier can derive:
:: empty set -> finite set -> countable set
let S be empty set;
S is countable;   :: automatically true (by chaining EmptyImpliesFinite, FiniteImpliesCountable)
```

### 17.4.4 Parameterized Conditional Clusters

**Example:**

```mizar
registration
  let G be Group;
  cluster CyclicIsAbelian: cyclic -> abelian for Subgroup of G;
  coherence
  proof
    let H be Subgroup of G;
    assume H is cyclic;
    thus H is abelian by mml.group.Cyclic_is_abelian;
  end;
end;
```

### 17.4.5 Negated Attributes in Clusters

The `non` modifier may appear in both antecedent and consequent positions.

**Example:**

```mizar
registration
  :: A positive Real is non zero
  cluster PositiveIsNonZero: positive -> non zero for Real;
  coherence proof ... end;
end;
```

## 17.5 Functorial Clusters

A **functorial cluster** registers that the result of a functor application has certain attributes. This allows the verifier to automatically assign attributes to computed values.

**Syntax (EBNF):**

```ebnf
functorial_registration ::= "cluster" label ":" functor_term "->"
                             consequent_adjectives "for" type_expression ";"
                             "coherence" justification ";" ;
functor_term            ::= functor_application ;
```

### 17.5.1 Basic Functorial Registration

**Example:**

```mizar
registration
  let X, Y be non empty set;
  cluster CartesianNonEmpty: [: X, Y :] -> non empty for set;
  coherence
  proof
    let X, Y be non empty set;
    thus [: X, Y :] is non empty by mml.set.Cartesian_non_empty;
  end;
end;
```

After this registration:

```mizar
let A, B be non empty set;
set P = [: A, B :];
:: The verifier automatically knows: P is non empty
:: or: P is non empty by CartesianNonEmpty;  :: explicit citation
```

### 17.5.2 Functorial Registration with Multiple Attributes

**Example:**

```mizar
registration
  let n be Nat;
  cluster FactorialPositive: n ! -> positive non zero for Nat;
  coherence
  proof
    let n be Nat;
    thus n ! is positive non zero by mml.number.Factorial_positive;
  end;
end;
```

### 17.5.3 Functorial Registration Example

**Example:**

```mizar
definition
  let G be Group;
  func CenterDef: center(G) -> Subgroup of G means
    for x being Element of G holds
      x in it iff for y being Element of G holds x * y = y * x;
  existence proof ... end;
  uniqueness proof ... end;
end;

registration
  let G be Group;
  cluster CenterIsAbelian: center(G) -> abelian for Subgroup of G;
  coherence
  proof
    let G be Group;
    thus center(G) is abelian by mml.group.Center_is_abelian;
  end;
end;
```

### 17.5.4 Nested Functorial Registrations

Functorial registrations compose with other registrations.

```mizar
registration
  let A be non empty set;
  cluster PowerSetNonEmpty: bool A -> non empty for set;
  coherence proof ... end;
end;

:: Now with both registrations:
let X be non empty set;
set P = bool [: X, X :];
:: [: X, X :] is non empty (by CartesianNonEmpty)
:: bool [: X, X :] is non empty (by PowerSetNonEmpty, since [: X, X :] is non empty set)
```

## 17.6 Reduction Registrations

A **reduction registration** declares that a specific term can be simplified to another term. This is a form of computational simplification applied during type checking and proof verification.

> [!NOTE]
> Reduction registrations generate universal equality axioms (see §17.9.4) and are also exported to ATP backends as equational axioms (see §17.9.6). Modern ATPs (especially superposition-based provers like Vampire/E) automatically orient these equalities into rewrite rules based on term ordering, effectively performing Knuth-Bendix completion during proof search.

**Syntax (EBNF):**

```ebnf
reduction_registration ::= "reduce" label ":" term_expression "to" term_expression ";"
                           "reducibility" justification ";" ;
```

### 17.6.1 Basic Reduction

**Example:**

```mizar
registration
  let n be Nat;
  reduce NatAddZero: n + 0 to n;
  reducibility
  proof
    let n be Nat;
    thus n + 0 = n by mml.number.natural.Nat_add_zero;
  end;
end;
```

After this registration, the verifier automatically simplifies `n + 0` to `n` during type checking. The label can also be cited in proofs:

```mizar
let m be Nat;
set k = m + 0;
:: The verifier recognizes k = m (by NatAddZero)
:: or: k = m by NatAddZero;  :: explicit citation
```

### 17.6.2 Reduction for Identity Operations

**Example:**

```mizar
registration
  let X be set;
  reduce UnionEmpty: X \/ {} to X;
  reducibility
  proof
    let X be set;
    thus X \/ {} = X by mml.set.Union_empty;
  end;

  reduce IntersectionSelf: X /\ X to X;
  reducibility
  proof
    let X be set;
    thus X /\ X = X by mml.set.Intersection_self;
  end;
end;
```

### 17.6.3 Reduction for Algebraic Operations

**Example:**

```mizar
registration
  let G be Group;
  let x be Element of G;
  reduce GroupMultUnit: x * (1.G) to x;
  reducibility
  proof
    let G be Group;
    let x be Element of G;
    thus x * (1.G) = x by mml.group.Group_mult_unit;
  end;

  reduce GroupUnitMult: (1.G) * x to x;
  reducibility
  proof
    let G be Group;
    let x be Element of G;
    thus (1.G) * x = x by mml.group.Group_unit_mult;
  end;
end;
```

These reductions allow the verifier to automatically simplify multiplications by the unit element during type checking.

### 17.6.4 Reduction Rules and Limitations

| Rule | Description |
|---|---|
| **Direction** | Reductions are applied left-to-right only: the left term is simplified to the right term |
| **Confluence** | The verifier does not guarantee confluence — users must ensure reductions do not introduce ambiguity |
| **Application** | Reductions are applied eagerly during term normalization in type checking |
| **Scope** | Reductions are global once registered — they affect all subsequent verification |
| **Matching** | Reduction patterns are matched modulo variable binding (pattern variables are instantiated) |
| **Step limit** | The verifier imposes a step limit on reduction chains to prevent non-termination |

> [!CAUTION]
> Circular reductions (e.g., `reduce A to B` and `reduce B to A`) cause non-termination. The verifier attempts to detect direct cycles at registration time and rejects them. However, indirect cycles (A → B → C → A) may not be detected statically; these are caught at verification time by the step limit, resulting in a verification error.

## 17.7 Cluster Resolution Rules

Cluster registrations are translated into FOL axioms and delegated to ATP backends for resolution. The verifier does not implement its own inference engine for cluster resolution — instead, it relies on the ATP to derive attribute information from the registered axioms.

### 17.7.1 ATP-Based Resolution

When the verifier needs to determine whether a type has a particular attribute, it formulates the query as a FOL goal and submits it to the ATP backend along with all relevant cluster axioms.

**Axioms passed to ATP:**

| Registration Type | Axiom Form | Example |
|---|---|---|
| Conditional cluster | Universal implication | `∀x. (is_set(x) ∧ is_empty(x) → is_finite(x))` |
| Functorial cluster | Universal attribute assertion | `∀X,Y. (¬is_empty(X) ∧ ¬is_empty(Y) → ¬is_empty(cartesian_product(X, Y)))` |
| Reduction | Universal equality | `∀n. (is_Nat(n) → add(n, 0) = n)` |
| Inheritance | Subsumption | `∀x. (is_Subset(x, Y) → is_set(x))` |

**Query formulation:**

Given a type expression `A₁ ... Aₙ T`, to determine whether attribute `B` holds:

```
Goal: is_T(x) ∧ is_A₁(x) ∧ ... ∧ is_Aₙ(x) → is_B(x)
```

The ATP receives this goal plus all registered cluster axioms and attempts to prove it. If the ATP succeeds, the verifier accepts the attribute derivation via the returned proof certificate.

**Example:**

```mizar
:: Given these registrations:
registration
  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence proof ... end;

  cluster FiniteImpliesCountable: finite -> countable for set;
  coherence proof ... end;
end;

:: When the verifier encounters:
let S be empty set;
S is countable;  :: The verifier asks the ATP to prove this

:: ATP receives:
::   Axiom 1 (EmptyImpliesFinite):   ∀x. (is_set(x) ∧ is_empty(x) → is_finite(x))
::   Axiom 2 (FiniteImpliesCountable): ∀x. (is_set(x) ∧ is_finite(x) → is_countable(x))
::   Goal:    is_set(S) ∧ is_empty(S) → is_countable(S)
:: ATP derives the chain: empty → finite → countable
```

> [!NOTE]
> The ATP handles resolution order, fixpoint computation, and transitive chaining automatically. The verifier does not need to implement these algorithms internally — it only needs to formulate the correct axioms and goals. See [Chapter 23 (Source Code Annotation and ATP Integration)](./23.source_code_annotation.md) for ATP backend details.

### 17.7.2 Subtype Compatibility in Resolution

Conditional clusters registered for a type `T` also apply to subtypes of `T`. For example:

```mizar
registration
  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence proof ... end;
end;

:: Since Subset of X is a subtype of set:
let X be set;
let S be empty Subset of X;
:: The verifier derives: S is finite (EmptyImpliesFinite applies to subtypes of set)
```

### 17.7.3 Conflict Resolution

Since every cluster registration requires a correctness proof (`existence` or `coherence`), contradictory clusters (e.g., one deriving `A` and another deriving `non A` for the same type) should not arise in a consistent logical system.

If a contradiction is nevertheless detected during ATP resolution, this indicates a fundamental inconsistency in the axiom system — either a proof was accepted erroneously or the underlying axioms are contradictory. The verifier reports this as a **fatal error**.

> [!CAUTION]
> A contradiction in cluster resolution (e.g., both `finite` and `non finite` derived for the same term) signals that the logical system is unsound. This is not a recoverable error — the user must identify and fix the inconsistent registration or its premises.

## 17.8 Interaction with Other Features

### 17.8.1 Clusters and Modes

Mode definitions with attributed base types rely on existential clusters for well-formedness. See [Chapter 5 (Modes), §5.8](./05.modes.md#58-correctness-conditions).

```mizar
:: The mode "Prime" requires an existential cluster:
registration
  cluster PrimeIntegerExists: prime Integer;
  existence
  proof
    take 2;
    thus 2 is prime by mml.number.prime.Two_is_prime;
  end;
end;

definition
  mode PrimeDef: Prime is prime Integer;
end;
```

### 17.8.2 Clusters and Type Inference

The type inference engine (see [Chapter 8 (Type Inference)](./08.type_inference.md)) uses clusters as follows:

| Inference Phase | Cluster Role |
|---|---|
| **Type checking** | Conditional clusters extend the known attributes of a typed value |
| **Subtype testing** | Clusters are used to determine if `A₁ ... Aₙ T` is a subtype of `B₁ ... Bₘ T` |
| **Functor result typing** | Functorial clusters provide attributes for computed values |
| **Term simplification** | Reductions normalize terms before matching |

### 17.8.3 Clusters and Proof Obligations

Cluster registrations generate proof obligations as described in [Chapter 16 (Theorems and Proofs), §16.5.3](./16.theorems_and_proofs.md#1653-cluster-registration-obligations). Each registration's label becomes the name of the corresponding FOL axiom in the generated theory, enabling proofs to cite registrations explicitly via `by Label`. The following table summarizes the obligations:

| Registration Type | Correctness Condition | FOL Obligation |
|---|---|---|
| Existential | `existence` | `∃x. (is_T(x) ∧ is_A₁(x) ∧ ... ∧ is_Aₙ(x))` |
| Conditional | `coherence` | `∀x. (is_T(x) ∧ is_A₁(x) ∧ ... ∧ is_Aₖ(x) → is_B₁(x) ∧ ... ∧ is_Bₘ(x))` |
| Functorial | `coherence` | `∀args. is_B₁(F(args)) ∧ ... ∧ is_Bₘ(F(args))` |
| Reduction | `reducibility` | `∀args. LHS(args) = RHS(args)` |

### 17.8.4 Clusters and Separate Compilation

Cluster registrations defined in a module are exported as part of the module's public interface (unless marked `private`). When another module imports the defining module, registered clusters become available to the importer's type inference engine.

```mizar
:: Module: std.set.finite
registration
  cluster EmptyImpliesFinite: empty -> finite for set;
  coherence proof ... end;
end;

:: Module: std.topology.compact
import std.set.finite;
:: The cluster EmptyImpliesFinite is now available here
```

> [!NOTE]
> For separate compilation and module interface details, see [Chapter 12 (Modules and Namespaces), §12.6](./12.modules_and_namespaces.md#126-logic-encoding-and-separate-compilation).

## 17.9 Logic Encoding Details

This section describes how cluster registrations map to First-Order Logic (FOL). For type encoding conventions, see [Chapter 3 (Type System), §3.7](./03.type_system.md#37-logic-encoding-details). For attribute encoding, see [Chapter 6 (Attributes), §6.8](./06.attributes.md#68-logic-encoding-details).

### 17.9.1 Existential Cluster Encoding

An existential cluster generates an existential axiom asserting the non-emptiness of the attributed type.

| Mizar Source | FOL Encoding |
|---|---|
| `cluster empty finite set;` | `∃x. (is_set(x) ∧ is_empty(x) ∧ is_finite(x))` |
| `cluster non empty Group;` | `∃x. (is_Group(x) ∧ ¬is_empty(x))` |
| `cluster prime Integer;` | `∃x. (is_Integer(x) ∧ is_prime(x))` |

**Parameterized form:**

```
registration
  let X be non empty set;
  cluster NonEmptyFiniteSubsetExists: non empty finite Subset of X;
  existence proof ... end;
end;

⟹  ∀X. (is_set(X) ∧ ¬is_empty(X) →
      ∃x. (is_Subset_of(x, X) ∧ ¬is_empty(x) ∧ is_finite(x)))
```

### 17.9.2 Conditional Cluster Encoding

A conditional cluster generates a universal implication axiom.

| Mizar Source | FOL Encoding |
|---|---|
| `cluster empty -> finite for set;` | `∀x. (is_set(x) ∧ is_empty(x) → is_finite(x))` |
| `cluster finite non empty -> complete for Lattice;` | `∀x. (is_Lattice(x) ∧ is_finite(x) ∧ ¬is_empty(x) → is_complete(x))` |
| `cluster non zero -> non empty for Real;` | `∀x. (is_Real(x) ∧ ¬is_zero(x) → ¬is_empty(x))` |

**Parameterized form:**

```
registration
  let G be Group;
  cluster CyclicIsAbelian: cyclic -> abelian for Subgroup of G;
  coherence proof ... end;
end;

⟹  ∀G. (is_Group(G) →
      ∀x. (is_Subgroup_of(x, G) ∧ is_cyclic(x) → is_abelian(x)))
```

**Multi-attribute consequent:**

```
cluster FiniteNonEmptyLatticeCompleteBounded: finite non empty -> complete bounded for Lattice;

⟹  ∀x. (is_Lattice(x) ∧ is_finite(x) ∧ ¬is_empty(x)
      → is_complete(x) ∧ is_bounded(x))
```

### 17.9.3 Functorial Cluster Encoding

A functorial cluster generates a universal axiom asserting attributes of a functor's result.

| Mizar Source | FOL Encoding |
|---|---|
| `cluster [: X, Y :] -> non empty for set;` | `∀X,Y. (¬is_empty(X) ∧ ¬is_empty(Y) → ¬is_empty(cartesian_product(X, Y)))` |
| `cluster n ! -> positive for Nat;` | `∀n. (is_Nat(n) → is_positive(factorial(n)))` |
| `cluster center(G) -> abelian for Subgroup of G;` | `∀G. (is_Group(G) → is_abelian(center(G)))` |

> [!NOTE]
> The full FOL encoding includes the type guards for the functor's parameters (from the surrounding `let` declarations).

### 17.9.4 Reduction Encoding

A reduction generates a universal equality axiom.

| Mizar Source | FOL Encoding |
|---|---|
| `reduce n + 0 to n;` | `∀n. (is_Nat(n) → add(n, 0) = n)` |
| `reduce X \/ {} to X;` | `∀X. (is_set(X) → union(X, empty_set) = X)` |
| `reduce X /\ X to X;` | `∀X. (is_set(X) → intersection(X, X) = X)` |

### 17.9.5 Composite Encoding Example

A complete registration block with its FOL encoding:

```mizar
registration
  let R be Ring;

  cluster CommSubgroupIsAbelian: commutative -> abelian for Subgroup of (R qua AddLoopStr);
  coherence proof ... end;

  let I be Ideal of R;
  cluster QuotientIsRingLike: R / I -> Ring-like for DoubleLoopStr;
  coherence proof ... end;
end;
```

FOL encoding:

```
:: Conditional cluster
∀R. (is_Ring(R) →
  ∀x. (is_Subgroup_of(x, R_as_AddLoopStr(R)) ∧ is_commutative(x)
    → is_abelian(x)))

:: Functorial cluster
∀R. (is_Ring(R) →
  ∀I. (is_Ideal_of(I, R) →
    is_Ring_like(quotient(R, I))))
```

### 17.9.6 ATP Translation Strategy

When exporting clusters to ATP backends, the following encoding strategies are applied:

| Registration Type | TPTP Encoding | SMT-LIB Encoding |
|---|---|---|
| Existential | `fof(ex_cluster_N, axiom, ?[X]: (is_T(X) & is_A(X)))` | `(assert (exists ((x T)) (is_A x)))` |
| Conditional | `fof(cond_cluster_N, axiom, ![X]: (is_T(X) & is_A(X) => is_B(X)))` | `(assert (forall ((x T)) (=> (is_A x) (is_B x))))` |
| Functorial | `fof(func_cluster_N, axiom, ![Args]: is_A(f(Args)))` | `(assert (forall ((args T)) (is_A (f args))))` |
| Reduction | `fof(reduce_N, axiom, ![Args]: lhs(Args) = rhs(Args))` | `(assert (forall ((args T)) (= (lhs args) (rhs args))))` |

> [!NOTE]
> For ATP integration details and property encoding, see [Chapter 23 (Source Code Annotation and ATP Integration)](./23.source_code_annotation.md). Superposition-based provers (Vampire/E) typically treat unit equalities from reductions as rewrite rules without explicit instruction.

## 17.10 Complete Syntax (EBNF)

Summary of all cluster and registration syntax from this chapter.

```ebnf
(* === Registration Block === *)
registration_block ::= "registration" { registration_content } "end" ";" ;

registration_content ::= parameter_decl             (* let ... *)
                       | registration_item ;

parameter_decl       ::= "let" variable_list [ qualification ] [ "such" conditions ] ";" ;

registration_item    ::= existential_registration
                       | conditional_registration
                       | functorial_registration
                       | reduction_registration ;

(* === Existential Cluster === *)
existential_registration ::= "cluster" label ":" adjective_list type_expression ";"
                              "existence" justification ";" ;

(* === Conditional Cluster === *)
conditional_registration ::= "cluster" label ":" antecedent_adjectives "->"
                              consequent_adjectives "for" type_expression ";"
                              "coherence" justification ";" ;

(* === Functorial Cluster === *)
functorial_registration  ::= "cluster" label ":" functor_term "->"
                              consequent_adjectives "for" type_expression ";"
                              "coherence" justification ";" ;

(* === Reduction Registration === *)
reduction_registration   ::= "reduce" label ":" term_expression "to" term_expression ";"
                              "reducibility" justification ";" ;

(* === Supporting Rules === *)
adjective_list           ::= adjective { adjective } ;
adjective                ::= [ "non" ] [ param_prefix ] attribute_name ;
antecedent_adjectives    ::= adjective_list ;
consequent_adjectives    ::= adjective_list ;
functor_term             ::= functor_application ;

(* Note: variable_list, qualification, conditions, and justification
   are defined in Chapter 15 (Statements).
   type_expression is defined in Chapter 3 (Type System).
   functor_application is defined in Chapter 13 (Term Expressions).
   term_expression is defined in Chapter 13 (Term Expressions).
   param_prefix is defined in Chapter 6 (Attributes). *)
```
