# 13. Basic Term Expressions

- [13. Basic Term Expressions](#13-basic-term-expressions)
  - [13.1 Primary Expressions](#131-primary-expressions)
  - [13.2 Functor Applications](#132-functor-applications)
  - [13.3 Logic Encoding Details](#133-logic-encoding-details)
  - [13.4 Complete Syntax (EBNF)](#134-complete-syntax-ebnf)

## 13.1 Primary Expressions

Primary expressions represent atomic values, references, and basic constructs that form the building blocks of more complex terms.

**Syntax (EBNF)**:

```ebnf
primary_expression ::= variable_identifier
                     | "it"
                     | "(" term_expression ")"
                     | numeral
                     | set_expression ;
variable_identifier ::= identifier ;
numeral            ::= digit+ ;
set_expression     ::= "{" [ term_list ] "}"
                     | "{" term_expression "where" typed_var_list ":" formula "}" ;
```

### 13.1.1 Variable Identifiers

Variable identifiers are references to previously declared variables. Their usage follows the general scoping rules of the language.

See [Chapter 4 (Variables and Constants)](./04.variables_and_constants.md) for detailed rules on variable declaration, scope, shadowing, and reserved identifiers.

**Example**:

```mizar
let x be Nat;
let y be Nat;
x + y;
```

### 13.1.2 The `it` Keyword

`it` refers to the object currently being defined within a `func` block using the `means` style.

**Example**:

```mizar
definition
  let X, Y be set;
  func UnionDef: X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end;
```

**Restrictions**:
- Only allowed inside a `func` definition with `means`
- Refers exclusively to the return object being defined
- Not available in `equals` definitions (the value is explicit)

### 13.1.3 Parenthesized Expressions

Used for grouping and precedence control.

**Example**:

```mizar
(a + b) * c           :: Override default precedence
(x > 0) & (y > 0)     :: Group formula parts
(((a + b) * c) + d)   :: Arbitrary nesting
```

**Semantics**:
- Parentheses override default operator precedence
- Arbitrary nesting is supported
- Type of expression is preserved through parenthesization

### 13.1.4 Numerals

Numeric literals for natural numbers.

**Example**:

```mizar
0
42
1000
```

### 13.1.5 Set Expressions

Explicit set construction using enumeration or comprehension.

**Enumeration**:

```mizar
{}              :: empty set
{ a }           :: singleton
{ a, b, c }     :: finite set
```

**Comprehension**:

```mizar
{ x where x is Nat : x > 0 & x < 10 }
{ f(n) where n is Nat : n in dom f }
```

## 13.2 Functor Applications

Functor applications construct terms by applying user-defined or built-in functors to arguments.

**Syntax (EBNF)**:

```ebnf
functor_application ::= prefix_functor
                      | infix_functor
                      | postfix_functor
                      | bracket_functor
                      | functional_functor
                      | inline_functor_application ;
prefix_functor     ::= functor_symbol term_expression ;
infix_functor      ::= term_expression functor_symbol term_expression ;
postfix_functor    ::= term_expression functor_symbol ;
bracket_functor    ::= left_bracket term_list right_bracket ;
functional_functor ::= functor_symbol "(" [ term_list ] ")" ;
inline_functor_application ::= inline_func_name "(" [ term_list ] ")" ;
term_list          ::= term_expression { "," term_expression } ;
```

### 13.2.1 Classification of Functors

| Type | Declaration | Scope | Example |
| --- | --- | --- | --- |
| **Symbolic** | `func Label: pattern -> type ...` | Module-level | `x + y`, `|.x.|` |
| **Inline** | `deffunc name(args) -> type equals ...` | Proof-local | `double(n)` |

### 13.2.2 Symbolic Functor Applications

Symbolic functors support multiple notation styles:

| Notation | Pattern | Example |
| --- | --- | --- |
| **Infix** | `x symbol y` | `x + y`, `X \/ Y` |
| **Prefix** | `symbol x` | `- x`, `card X` |
| **Postfix** | `x symbol` | `n !`, `f "` |
| **Bracket** | `left x right` | `[: X, Y :]`, `|. x .|` |
| **Functional** | `symbol(args)` | `sin(x)`, `max(a, b)` |

**Examples**:

```mizar
:: Infix
x + y
X \/ Y

:: Prefix
- x
card X

:: Postfix
n !

:: Bracket
[: A, B :]
|. x .|

:: Functional
sin(x)
max(a, b)
```

### 13.2.3 Inline Functor Applications

Inline functors (defined with `deffunc`) are local to proof blocks.

**Definition Syntax**:

```ebnf
inline_func_def ::= "deffunc" identifier "(" [ typed_param_list ] ")" "->" type_expression
                    "equals" term_expression ";" ;
typed_param_list ::= typed_param { "," typed_param } ;
typed_param      ::= identifier "be" type_expression ;
```

**Example**:

```mizar
proof
  deffunc double(n be Nat) -> Nat equals n + n;
  deffunc triple(n be Nat) -> Nat equals n + n + n;
  
  A1: double(3) = 6;
  A2: triple(3) = 9;
  ...;
end;
```

**Semantics**:
- Inline functors are expanded by substitution
- Not visible outside the defining proof block
- Useful for proof-local abbreviations

> [!NOTE]
> For detailed information on `deffunc`, see [Chapter 17 (Statements), §17.2.3](./17.statements.md#1723-inline-function-definition-deffunc).

## 13.3 Logic Encoding Details

This section describes how term expressions map to First-Order Logic.

### 13.3.1 Variable References

Variables are encoded as FOL variables with type guards:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be Nat; x` | `x` (with context `is_Nat(x)`) |

### 13.3.2 The `it` Keyword

In `means` definitions, `it` is replaced by the function application:

```
func F(x) -> T means P(it)
⇒  forall x (P(F(x)))
```

### 13.3.3 Functor Applications

Functor applications are encoded as FOL function applications:

| Mizar Source | FOL Encoding |
| --- | --- |
| `x + y` | `add(x, y)` |
| `- x` | `neg(x)` |
| `n !` | `factorial(n)` |
| `[: A, B :]` | `cartesian_product(A, B)` |
| `sin(x)` | `sin(x)` |

### 13.3.4 Set Expressions

Set expressions are encoded using set-builder notation:

| Mizar Source | FOL Encoding |
| --- | --- |
| `{}` | `empty_set` |
| `{ a }` | `singleton(a)` |
| `{ a, b }` | `union(singleton(a), singleton(b))` |
| `{ x where x is T : P(x) }` | `{ x : is_T(x) ∧ P(x) }` |

### 13.3.5 Parenthesization

Parentheses do not affect FOL encoding; they only control parsing:

| Mizar Source | FOL Encoding |
| --- | --- |
| `(a + b) * c` | `mul(add(a, b), c)` |
| `a + (b * c)` | `add(a, mul(b, c))` |

## 13.4 Complete Syntax (EBNF)

Summary of term expression syntax.

```ebnf
(* Term Expressions *)
term_expression    ::= primary_expression
                     | functor_application
                     | term_expression "qua" type_expression ;

(* Primary Expressions *)
primary_expression ::= variable_identifier
                     | "it"
                     | "(" term_expression ")"
                     | numeral
                     | set_expression ;
variable_identifier ::= identifier ;
numeral            ::= digit+ ;

(* Set Expressions *)
set_expression     ::= "{" [ term_list ] "}"
                     | "{" term_expression "where" typed_var_list ":" formula "}" ;
typed_var_list     ::= typed_var { "," typed_var } ;
typed_var          ::= identifier "is" type_expression ;

(* Functor Applications *)
functor_application ::= prefix_functor
                      | infix_functor
                      | postfix_functor
                      | bracket_functor
                      | functional_functor
                      | inline_functor_application ;
prefix_functor     ::= functor_symbol term_expression ;
infix_functor      ::= term_expression functor_symbol term_expression ;
postfix_functor    ::= term_expression functor_symbol ;
bracket_functor    ::= left_bracket term_list right_bracket ;
functional_functor ::= functor_symbol "(" [ term_list ] ")" ;
inline_functor_application ::= inline_func_name "(" [ term_list ] ")" ;
term_list          ::= term_expression { "," term_expression } ;

(* Inline Functor Definition - see Chapter 17 *)
inline_func_def    ::= "deffunc" identifier "(" [ typed_param_list ] ")" "->" type_expression
                       "equals" term_expression ";" ;
typed_param_list   ::= typed_param { "," typed_param } ;
typed_param        ::= identifier "be" type_expression ;
```
