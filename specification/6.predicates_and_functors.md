# 6. Predicates and Functors

- [6. Predicates and Functors](#6-predicates-and-functors)
    - [6.1. Overview](#61-overview)
        - [6.1.1. Role in Mizar's Mathematical Language](#611-role-in-mizars-mathematical-language)
        - [6.1.2. Relationship to First-Order Logic](#612-relationship-to-first-order-logic)

## 6.1. Overview

### 6.1.1. Role in Mizar's Mathematical Language

Predicates and functors form the core vocabulary of Mizar's mathematical expressions. They enable the formalization of mathematical concepts by providing:

1. **Predicates**: Relations and properties that can be true or false
   - Type: `pred P(X₁, X₂, ..., Xₙ)` where `Xᵢ` are parameter types
   - Examples: `x in Y`, `X c= Y`, `f is continuous`

2. **Functors**: Operations that construct mathematical objects
   - Type: `func f(X₁, X₂, ..., Xₙ) -> Y` where `Y` is the return type
   - Examples: `x + y`, `sin x`, `X \/ Y`

Both predicates and functors can be:
- **Built-in**: Basic logical and set-theoretic operations (`=`, `<>`, `in`)
- **User-defined**: Declared in articles and imported from modules
- **Overloaded**: Multiple definitions with different type signatures

### 6.1.2. Relationship to First-Order Logic

Mizar's predicates and functors correspond directly to first-order logic constructs:

**Predicates** translate to atomic formulas:
```mizar
x in Y  :: ⟺  In(x, Y)
```

**Functors** translate to function applications:
```mizar
x + y   :: ⟺  plus(x, y)
```

**Type dependencies** create conditional expressions in FOL:
```mizar
let f be Function[X, Y];
let x be Element[X];
f.x     :: ⟺  apply(f, x) 
        :: Note: In Mizar, f.x is always well-formed syntactically,
        :: even when x ∉ dom f. The type system ensures type safety
        :: but does not prevent partial function applications.
```

The type system ensures syntactic well-formedness and generates appropriate proof obligations, but Mizar's partial function semantics allow applications outside the declared domain, following the principle that all functions are total at the implementation level (with unspecified behavior outside their logical domain).