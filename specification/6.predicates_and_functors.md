# 6. Predicates and Functors

- [6. Predicates and Functors](#6-predicates-and-functors)
  - [6.1. Overview](#61-overview)
    - [6.1.1. Role in Mizar's Mathematical Language](#611-role-in-mizars-mathematical-language)
    - [6.1.2. Relationship to First-Order Logic](#612-relationship-to-first-order-logic)
  - [6.2. Predicate Definitions](#62-predicate-definitions)
    - [6.2.1. Basic Syntax and Semantics](#621-basic-syntax-and-semantics)
    - [6.2.2. Built-in vs User-Defined Predicates](#622-built-in-vs-user-defined-predicates)
    - [6.2.3. Type Dependencies and Parameters](#623-type-dependencies-and-parameters)
  - [6.3. Functor Definitions](#63-functor-definitions)
    - [6.3.1. Basic Syntax and Semantics](#631-basic-syntax-and-semantics)
    - [6.3.2. Functor Definition Methods](#632-functor-definition-methods)
    - [6.3.3. Partial Functions and Definedness](#633-partial-functions-and-definedness)
    - [6.3.4. Type Dependencies and Return Types](#634-type-dependencies-and-return-types)
  - [6.4. Notation System](#64-notation-system)
    - [6.4.1. Infix, Prefix, and Postfix Notation](#641-infix-prefix-and-postfix-notation)
    - [6.4.2. Bracket Notation and Custom Symbols](#642-bracket-notation-and-custom-symbols)
    - [6.4.3. Operator Precedence](#643-operator-precedence)
  - [6.5. Synonyms and Antonyms](#65-synonyms-and-antonyms)
    - [6.5.1. Definition and Usage](#651-definition-and-usage)
    - [6.5.2. Mathematical Notation Enhancement](#652-mathematical-notation-enhancement)
  - [6.6. Symbol Management](#66-symbol-management)
    - [6.6.1. Scope and Visibility Rules](#661-scope-and-visibility-rules)
    - [6.6.2. Import Behavior and Conflicts](#662-import-behavior-and-conflicts)

## 6.1. Overview

### 6.1.1. Role in Mizar's Mathematical Language

Predicates and functors form the core vocabulary of Mizar's mathematical expressions. They enable the formalization of mathematical concepts by providing:

1. **Predicates**: Relations and properties that can be true or false
   - Type: `pred P(X₁, X₂, ..., Xₙ)` where `Xᵢ` are parameter types
   - Examples: `x in Y`, `X c= Y`, `f is continuous`

2. **Functors**: Operations that construct mathematical objects
   - Type: `func f(X₁, X₂, ..., Xₙ) -> Y` where `Y` is the return type
   - Examples: `x + y`, `sin x`, `X \/ Y`

Both predicates and functors can be:
- **Built-in**: Basic logical and set-theoretic operations (`=`, `<>`, `in`)
- **User-defined**: Declared in articles and imported from modules
- **Overloaded**: Multiple definitions with different type signatures

### 6.1.2. Relationship to First-Order Logic

Mizar's predicates and functors correspond directly to first-order logic constructs:

**Predicates** translate to atomic formulas:
```mizar
x in Y  :: ⟺  In(x, Y)
```

**Functors** translate to function applications:
```mizar
x + y   :: ⟺  plus(x, y)
```

**Type dependencies** create conditional expressions in FOL:
```mizar
let f be Function of X, Y;
let x be Element of X;
f.x     :: ⟺  apply(f, x) 
        :: Note: In Mizar, f.x is always well-formed syntactically,
        :: even when x ∉ dom f. The type system ensures type safety
        :: but does not prevent partial function applications.
```

The type system ensures syntactic well-formedness and generates appropriate proof obligations, but Mizar's partial function semantics allow applications outside the declared domain, following the principle that all functions are total at the implementation level (with unspecified behavior outside their logical domain).

## 6.2. Predicate Definitions

### 6.2.1. Basic Syntax and Semantics

Predicates in Mizar are defined using the `pred` keyword:

```mizar
definition
  let X, Y be set;
  pred X c= Y means
    for x be object st x in X holds x in Y;
end
```

**Basic components:**
- `pred` keyword introduces a predicate definition
- Parameter declarations specify the types of arguments
- `means` clause provides the logical definition
- Predicate symbols can use almost any sequence of printable non-whitespace characters
- Lexer uses longest-match rule among imported symbols

**Semantics:**
- Predicates represent relations that evaluate to true or false
- Parameter types determine the domain of the predicate
- The `means` clause must be a well-formed logical formula

### 6.2.2. Built-in vs User-Defined Predicates

**Built-in predicates** are provided by the Mizar system:
```mizar
x = y          :: Equality
x in X         :: Set membership
x <> y         :: Inequality (antonym of =)
```

**User-defined predicates** are declared in articles:
```mizar
definition
  let m, n be Nat;
  pred m, n are_coprime means
    gcd(m, n) = 1;
end
```

**Import behavior:**
- User-defined predicates become available through import statements
- Symbol precedence follows the rules described in [Chapter 2](./2.lexical_structure.md)
- Conflicts are resolved using namespace qualification

### 6.2.3. Type Dependencies and Parameters

**Simple predicates** with fixed parameter types:
```mizar
definition
  let m, n be Nat;
  pred m divides n means
    ex k be Nat st n = m * k;
end
```

**Dependent predicates** where parameter types depend on previous parameters:
```mizar
definition
  let G be Group;
  let H be Subgroup of G;
  let a, b be Element of G;
  pred a, b are_congruent_mod H means
    a * (b") in H;
end
```

**Multiple parameter predicates**:
```mizar
definition
  let X be set;
  let R be Relation of X;
  let x, y, z be Element of X;
  pred R connects x, y via z means
    [x, z] in R & [z, y] in R;
end
```

**Type constraints in parameters:**
```mizar
definition
  let G be non empty associative Magma;
  let a, b be Element of G;
  pred a, b are_commute means
    G.binop(a, b) = G.binop(b, a);
end
```

## 6.3. Functor Definitions

### 6.3.1. Basic Syntax and Semantics

Functors in Mizar are defined using the `func` keyword:

```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z be object holds z in it iff z in X or z in Y;
end
```

**Basic components:**
- `func` keyword introduces a functor definition
- Parameter declarations specify the types of arguments
- Return type specified after `->` 
- `means` clause provides the logical definition using `it` for the result
- Functor symbols can use almost any sequence of printable non-whitespace characters
- Lexer uses longest-match rule among imported symbols

**Semantics:**
- Functors represent operations that construct mathematical objects
- Parameter types determine the domain of the functor
- Return type specifies the codomain
- The `means` clause defines the result using `it` as placeholder

### 6.3.2. Functor Definition Methods

Functors can be defined using two different approaches:

**1. Means definition** - defines the result implicitly:
```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z be object holds z in it iff z in X or z in Y;
end
```

**2. Equals definition** - defines the result explicitly:
```mizar
definition
  let n be Nat;
  func twice(n) -> Nat equals 2 * n;
end
```

**Import behavior:**
- All functors are user-defined (no built-in functors exist in Mizar)
- User-defined functors become available through import statements
- Symbol precedence follows the rules described in [Chapter 2](./2.lexical_structure.md)
- Conflicts are resolved using namespace qualification

### 6.3.3. Partial Functions and Definedness

Functors in Mizar can represent partial functions using conditional definitions:

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func x / y -> Real means
    it * y = x;
end
```

**Definedness conditions:**
- `assume` clauses specify when the functor is defined
- Outside the domain, the functor may return arbitrary values
- Type system ensures syntactic well-formedness but not semantic definedness
- Note: Definedness checking is more complex than type checking and poses implementation challenges

**Total vs Partial:**
```mizar
:: Total functor - always defined
definition
  let n be Nat;
  func twice(n) -> Nat equals 2 * n;
end

:: Partial functor - conditionally defined  
definition
  let f be Function;
  assume f is one-to-one;
  func f" -> Function means
    dom it = rng f & for x, y be object holds 
    [x, y] in it iff [y, x] in f;
end
```

### 6.3.4. Type Dependencies and Return Types

**Simple functors** with fixed parameter and return types:
```mizar
definition
  let m, n be Nat;
  func gcd(m, n) -> Nat means
    it divides m & it divides n &
    for k be Nat st k divides m & k divides n holds k divides it;
end
```

**Dependent return types** based on parameters:
```mizar
definition
  let G be Group;
  func center(G) -> Subgroup of G means
    for x be Element of G holds x in it iff
    for y be Element of G holds x, y are_commute;
end
```

**Multiple parameter functors** with complex dependencies:
```mizar
definition
  let G be Group;
  let H, K be Subgroup of G;
  func H * K -> Subset of G means
    for x be Element of G holds x in it iff
    ex h be Element of H ex k be Element of K st x = h * k;
end
```

## 6.4. Notation System

### 6.4.1. Infix, Prefix, and Postfix Notation

Mizar allows direct definition of various notation patterns in predicate and functor definitions:

**Infix notation** for binary predicates:
```mizar
definition
  let x, y be Real;
  pred x <= y means
    x < y or x = y;
end
```

**Infix notation** for binary functors:
```mizar
definition
  let x, y be Real;
  func x + y -> Real means
    it = plus(x, y);
end
```

**Prefix notation** for unary functors:
```mizar
definition
  let x be Real;
  func - x -> Real means
    it + x = 0;
end
```

**Postfix notation** patterns:
```mizar
definition
  let n be Nat;
  func n ! -> Nat equals
    Product(id(Seg n));
end
```

### 6.4.2. Bracket Notation and Custom Symbols

**Left and right bracket functors** using `[:` and `:]`:
```mizar
definition
  let X, Y be set;
  func [: X, Y :] -> set means
    for z be object holds z in it iff
    ex x, y be object st x in X & y in Y & z = [x, y];
end
```

### 6.4.3. Operator Precedence

**Symbol-based precedence declaration** using global annotations:

```mizar
:: Global symbol precedence declarations (range: 0-255, default: 64)
@symbol_precedence(*, 100, left_associative);      :: Multiplication
@symbol_precedence(/, 100, left_associative);      :: Division
@symbol_precedence(+, 80, left_associative);       :: Addition
@symbol_precedence(-, 80, left_associative);       :: Subtraction
```

**Automatic precedence application** in definitions:
```mizar
definition
  let x, y be Real;
  func x + y -> Real means  :: Automatically gets precedence 80, left_associative
    it = real_addition(x, y);
end

definition
  let x, y be Matrix;
  func x * y -> Matrix means  :: Automatically gets precedence 100, left_associative
    it = matrix_multiplication(x, y);
end
```

**Consistency checking** across modules:
```mizar
:: Module A
@symbol_precedence(+, 80, left_associative);

:: Module B - would cause link error
@symbol_precedence(+, 100, left_associative);  :: Error: precedence conflict for '+'
```

**Link-time error handling:**
- All modules must declare identical precedence for the same symbol
- Conflicts detected during module linking phase
- Clear error messages indicating conflicting declarations

**Associativity types:**
- `left_associative`: `x + y + z` = `(x + y) + z`
- `right_associative`: `x ^ y ^ z` = `x ^ (y ^ z)`
- `non_associative`: Relational operators, requires explicit parentheses

## 6.5. Synonyms and Antonyms

### 6.5.1. Definition and Usage

### 6.5.2. Mathematical Notation Enhancement

## 6.6. Symbol Management

### 6.6.1. Scope and Visibility Rules

### 6.6.2. Import Behavior and Conflicts