# 8. Modes

- [8. Modes](#8-modes)
  - [8.1. Definition and Purpose of Modes](#81-definition-and-purpose-of-modes)
  - [8.2. Syntax for Declaring and Using Modes](#82-syntax-for-declaring-and-using-modes)
  - [8.3. Type Inference with Modes](#83-type-inference-with-modes)
  - [8.4. Mode Implementation](#84-mode-implementation)
  - [8.5. Relationship between Modes and Structures](#85-relationship-between-modes-and-structures)
  - [8.6. Design Rationale: Unification of Mode Syntax](#86-design-rationale-unification-of-mode-syntax)
  - [8.7. Dependent Modes](#87-dependent-modes)
  - [8.8. Correctness Conditions](#88-correctness-conditions)

## 8.1. Definition and Purpose of Modes

Modes in Mizar are type constructors that define new types based on existing ones. They serve several key purposes in the type system:

1. **Type Abstraction**: Modes allow for defining abstract mathematical concepts as types, enabling mathematicians to work with familiar mathematical objects directly.

2. **Type Classification**: Modes enable the creation of a rich type hierarchy that mirrors mathematical classification systems.

3. **Type Composition**: Through modes, complex types can be built by composing or restricting existing types.

4. **Dependent Types**: Modes can be parameterized by values, allowing for dependent types that express mathematical relationships.

Modes, along with structures, constitute the radix-types in Mizar's type system. While structures define composite types with explicit fields and properties, modes define types through type expressions and attributes, providing a more abstract approach to type definition.

## 8.2. Syntax for Declaring and Using Modes

#### Mode Definition Syntax

Modes in Mizar are defined using the `is` keyword, which specifies how the new type relates to existing types:

```mizar
definition
  mode <mode_name> is <type_expression>;
end
```

where:
- `<mode_name>` is the name of the new mode
- `<type_expression>` is an expression using existing types and attributes

Examples:

```mizar
definition
  mode Integer is integer Number;
  mode Nat is natural Number;
  mode Real is real Number;
end
```

#### Type Restrictions with Attributes

Attributes can be used to create more specialized modes:

```mizar
definition
  mode Prime is prime Integer;
  mode Group is non empty group_like associative Magma;
end
```

#### Using Modes

Modes are used in variable declarations and type expressions:

```mizar
let G be Group;
let f be Function of REAL, REAL;

theorem
  for n being Integer st n is Prime holds
  n > 1;
```

## 8.3. Type Inference with Modes

Mizar's type inference system works with modes to automatically deduce type information:

#### Basic Type Inference

When a variable is declared with a mode, Mizar automatically recognizes its relationship to parent types:

```mizar
let n be Prime;
:: Mizar knows that n is also a Number
```

#### Inference through Attribute Clusters

Type inference also works through attribute clusters:

```mizar
let S be empty set;
:: The cluster registration "cluster empty -> finite set" allows Mizar to infer
:: that S is finite
```

#### Handling Dependent Modes

For dependent modes, type inference ensures proper parameter matching:

```mizar
let X be set;
let S be Subset of X;
:: Mizar knows that S is a set and S âŠ† X
```

## 8.4. Mode Implementation

In Mizar's type system, each mode is implemented as a combination of a base type and attribute conditions. This approach offers several advantages:

1. **Uniform Type Representation**: All types in Mizar follow a consistent internal representation.

2. **Simplified Type Checking**: Type checking becomes a matter of verifying attribute conditions.

3. **Efficient Type Inference**: Type inference leverages attribute clusters for deducing type relationships.

The internal implementation of a mode declaration:

```mizar
definition
  mode M is <attribute_chain> <type_expressoin>;
end
```

is equivalent to defining:

1. A predicate that verifies whether an object belongs to the mode
2. A cluster registration that establishes the relationship between the mode and its base type with attributes

## 8.5. Relationship between Modes and Structures

Modes and structures are complementary type definition mechanisms in Mizar:

1. **Structural vs. Abstract Definition**:
    - Structures define types by explicitly specifying their components (fields and properties)
    - Modes define types through type expressions and attributes, focusing on what an object is rather than how it's composed

2. **Usage Context**:
   - Structures are appropriate for mathematical objects with explicit components (e.g., vector spaces with carriers, operations)
   - Modes are suitable for abstract mathematical concepts or classifications (e.g., prime numbers, continuous functions)

3. **Relationship**:
    - Modes can be defined based on structures: `mode Ring is add_associative mul_associative DoubleLoopStr;`
    - Structures can use modes in field types: `field coefficients -> Sequence of REAL;`

4. **Type Conversion**:
    - Objects of a mode defined from a structure can be converted to the structure using the `qua` operator
    - This allows accessing the structural components when needed

Example of interaction between modes and structures:

```mizar
definition
  struct MetricStruct where
    field carrier -> set;
    field distance -> Function of [:carrier, carrier:], REAL;
  end
end

definition
  mode MetricSpace is reflective discerning symmetric triangle MetricStruct;
end

theorem
  for M being MetricSpace
  for x,y being Element of M
  holds M.distance.(x,y) >= 0;
```

In this example, `MetricSpace` is defined as a mode based on the `MetricStruct` structure with specific attributes.

## 8.6. Design Rationale: Unification of Mode Syntax

The redesigned Mizar language adopts a unified approach to mode definition by standardizing on the `is` syntax and removing the legacy `means` syntax. This design decision was made for several compelling reasons:

1. **Simplified Type Inference**:
    - The `is` syntax directly expresses hierarchical relationships between types
    - Type inference becomes more deterministic and follows a clearer pattern
    - The compiler can more efficiently determine subtype relationships

2. **Language Consistency**:
    - A single approach to mode definition creates a more coherent language design
    - Reduces cognitive load for users, as they only need to learn one pattern
    - Creates better alignment with the attribute system

3. **Improved Error Diagnostics**:
    - Allows for more specific and helpful error messages
    - Enables better localization of type errors
    - Simplifies the implementation of the type checking algorithm

4. **Alternative Approaches**:

The functionality previously provided by the `means` syntax can be achieved through combinations of modes and attributes:

a) **Standard Cases**: Most uses of `means` syntax can be directly replaced with attribute definitions:

For example, instead of:
```mizar
definition
mode Prime means
  it is Nat & it > 1 &
  for n being Nat st 1 < n < it holds
  not n divides it;
end
```

The redesigned approach uses:
```mizar
definition
  let n be Nat;
  attr n is prime means
    n > 1 & for m being Nat st 1 < m < n holds
      not m divides n;

  mode Prime is prime Integer;
end
```

b) **Recursive Definitions**: For recursive type definitions, which were previously expressed using `means`, the redesigned Mizar uses a combination of structures and attributes:

```mizar
definition
  struct BinaryTreeNode where
    field value -> object;
    field left -> object;
    field right -> object;
  end
end
  
definition
  let T be object;
  attr T is binary_tree means
    T = {} or
    ex n being BinaryTreeNode st
      T = n & n.left is binary_tree & n.right is binary_tree;
end

definition
  mode BinaryTree is binary_tree set;
end

definition
  let T be BinaryTree;
  mode Leaf of T is terminal Element of T;
end
```

This approach maintains the full expressivity of the previous system while bringing greater consistency and clarity to the type system.

The redesigned Mizar's unified approach to mode definition maintains the full expressive power of the language while improving its coherence, implementability, and user experience.

## 8.7. Dependent Modes

Modes can be parameterized using `over` or `of` keywords within the `is` syntax as syntactic sugar for templates:

```mizar
definition
  mode Polynomial over R is polynomial_like set;
  mode Subset of X is X-subset_like set;
end
```

**Parameter syntax:**
- `mode Name over T is <attribute_chain> <type_expression>;`
- `mode Name of T is <attribute_chain> <type_expression>;`
- Multiple parameters: `mode Name over T, U is <attribute_chain> <type_expression>;`
- Parameterized attributes: `mode Name is (m,n)-size structure over R;`

**Usage:**
```mizar
let p be Polynomial over REAL;        :: Equivalent to Polynomial[REAL]
let S be Subset of NAT;               :: Equivalent to Subset[NAT]
let A be Matrix over COMPLEX;         :: Equivalent to Matrix[COMPLEX]
```

**Complex examples:**
```mizar
definition
  mode Matrix over R is matrix_like set;
  mode FinDimVectorSpace over F, n is n-dimensional vector_space_like structure over F;
end

let A be (3,4)-size Matrix over REAL;
let V be FinDimVectorSpace over COMPLEX, 5;
```

**Template equivalence:** Dependent mode declarations are internally processed as template definitions, maintaining the unified `is` syntax while enabling parameterization.

## 8.8. Correctness Conditions

Mode existence is ensured through attribute existential cluster registrations.

```mizar
registration
  cluster prime Integer;  :: Existential registration
  existence
  proof
    take 2;
    thus 2 is prime;
  end
end

definition
  mode Prime is prime Integer;  :: Existence guaranteed by above registration
end
```

**Warning elimination**: To avoid warnings about unproven mode existence, provide appropriate existential cluster registrations before mode definitions.

**See also**: [Chapter 10: Clusters](./10.clusters.md) for detailed information on existential registrations.
