# 14. Advanced Term Expressions

- [14. Advanced Term Expressions](#14-advanced-term-expressions)
  - [14.1 Structure Expressions](#141-structure-expressions)
  - [14.2 Set Comprehension (Fraenkel Operator)](#142-set-comprehension-fraenkel-operator)
  - [14.3 Type Qualification (`qua`)](#143-type-qualification-qua)
  - [14.4 Operator Precedence and Associativity](#144-operator-precedence-and-associativity)
  - [14.5 Logic Encoding Details](#145-logic-encoding-details)
  - [14.6 Complete Syntax (EBNF)](#146-complete-syntax-ebnf)

## 14.1 Structure Expressions

Structure expressions allow construction and manipulation of structured data values based on user-defined `struct` types (see [Chapter 6](./06.structures.md)).

**Syntax (EBNF)**:

```ebnf
structure_expression ::= struct_constructor | selector_access ;
struct_constructor   ::= struct_name "(" [ field_assignment_list ] ")" ;
field_assignment_list ::= field_assignment { "," field_assignment } ;
field_assignment     ::= field_name ":" term_expression ;
selector_access      ::= term_expression "." field_name ;
```

### 14.1.1 Structure Constructor

A structure value is created by supplying field-value pairs.

**Example**:

```mizar
:: Define a Point structure with default values (from Ch.6)
struct Point where
  field x -> Real := 0.0;
  field y -> Real := 0.0;
end;

:: Construct with all fields specified
let p = Point(x: 3.0, y: 4.0);

:: Omit fields that have defaults
let origin = Point();              :: x = 0.0, y = 0.0
let on_x_axis = Point(x: 5.0);    :: x = 5.0, y = 0.0
```

**Default Value Syntax**:

Fields may declare default values using `:=` in the struct definition:

```ebnf
field_decl ::= "field" identifier "->" type_expression [ ":=" term_expression ] ";" ;
```

**Rules**:
- All fields without defaults must be specified in the constructor
- Fields with defaults may be omitted (the default value is used)
- Field names must match the structure's declaration
- Order of fields in the constructor is irrelevant
- Type of each field value must match the declared type

### 14.1.2 Selector Access

Fields of a structure are accessed using dot notation.

**Example**:

```mizar
let p = Point(x: 3.0, y: 4.0);
p.x + p.y = 7.0;  :: Field access

:: Chained access for nested structures
let line = Line(start: Point(x: 0.0, y: 0.0), end: Point(x: 1.0, y: 1.0));
line.start.x = 0.0;
line.end.y = 1.0;
```

> [!IMPORTANT]
> The traditional Mizar selector syntax `the x of p` is **deprecated**. Use dot notation `p.x` exclusively. This provides a more concise and universally familiar syntax while avoiding syntactic ambiguity with the definite description operator `the`.

### 14.1.3 Structure Update

Structure values are immutable; updates create new values.

**Example**:

```mizar
let p = Point(x: 3.0, y: 4.0);
let q = Point(x: p.x + 1.0, y: p.y);  :: New point with updated x
```

## 14.2 Set Comprehension (Fraenkel Operator)

The Fraenkel operator constructs sets by comprehension.

**Syntax (EBNF)**:

```ebnf
set_comprehension ::= "{" term_expression "where" typed_var_list [ ":" formula ] "}" ;
typed_var_list    ::= typed_var { "," typed_var } ;
typed_var         ::= identifier "is" type_expression ;
```

> [!IMPORTANT]
> **Set-hood constraint**: The generator variables must range over elements of a **set** (e.g., `Element of S`), not over an arbitrary type. This ensures the result is a set rather than a proper class.
>
> ```mizar
> :: OK: x ranges over elements of a set
> { x where x is Element of NAT : x < 10 }
>
> :: NG: Group is a type (class), not a set
> { G where G is Group : G is abelian }  :: REJECTED
> ```

### 14.2.1 Basic Comprehension

**Example**:

```mizar
:: Even natural numbers
{ n where n is Element of NAT : n mod 2 = 0 }

:: Squares of naturals
{ n * n where n is Element of NAT : n < 10 }

:: Elements of a function's range (condition omitted = all elements)
{ f.x where x is Element of dom f }
```

> [!NOTE]
> When the condition is omitted, all elements satisfying the generator type are included. There is no `true` keyword; simply omit the `: formula` part.

### 14.2.2 Multiple Generators

**Example**:

```mizar
:: Cartesian product elements (no filter needed)
{ [x, y] where x is Element of A, y is Element of B }

:: Pairs satisfying a condition
{ [x, y] where x is Element of NAT, y is Element of NAT : x + y = 10 }
```

### 14.2.3 Nested Comprehensions

**Example**:

```mizar
:: Set of sets
{ { y where y is Element of NAT : y < x }
  where x is Element of NAT : x < 5 }
```

## 14.3 Type Qualification (`qua`)

The `qua` operator explicitly views a value as a specific type without changing the value itself.

**Syntax (EBNF)**:

```ebnf
qua_expression ::= "(" term_expression "qua" type_expression ")" ;
```

### 14.3.1 Usage

**Example**:

```mizar
let R be DoubleLoopStr;

:: View R as AddLoopStr to access additive properties
(R qua AddLoopStr) is associative;

:: View R as MulLoopStr to access multiplicative properties
(R qua MulLoopStr) is commutative;
```

### 14.3.2 Restrictions

- The target type must be a supertype or compatible structural type (widening)
- For narrowing (casting to more specific type), use `reconsider` with proof

> [!NOTE]
> For `reconsider` statement syntax, see [Chapter 9 (Type Inference and Conversion)](./09.type_inference_and_conversion.md) and [Chapter 17 (Statements), §17.5.1](./17.statements.md#1751-type-reconsideration-reconsider).

## 14.4 Operator Precedence and Associativity

User-defined functors can have explicit precedence and associativity declarations.

**Syntax (EBNF)**:

```ebnf
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value      ::= integer ;  (* 0-255 *)
associativity         ::= "left_associative" | "right_associative" | "non_associative" ;
```

### 14.4.1 Precedence Rules

Each symbolic functor has an associated precedence level (0–255). Higher values bind more tightly.

**Example**:

```mizar
@symbol_precedence(+, 80, left_associative);
@symbol_precedence(*, 90, left_associative);
@symbol_precedence(^, 95, right_associative);
@symbol_precedence(=, 50, non_associative);
```

With these declarations:
- `a + b * c` parses as `a + (b * c)` (higher precedence binds tighter)
- `a * b + c` parses as `(a * b) + c`
- `a + b = c + d` parses as `(a + b) = (c + d)` (precedence determines inter-operator grouping)

### 14.4.2 Associativity

| Type | Grouping | Example |
| --- | --- | --- |
| `left_associative` | Left-to-right | `a + b + c` → `(a + b) + c` |
| `right_associative` | Right-to-left | `a ^ b ^ c` → `a ^ (b ^ c)` |
| `non_associative` | Requires parentheses | `a = b = c` → **error** |

> [!NOTE]
> `non_associative` only prohibits chaining the **same** operator (e.g., `a = b = c`). The `precedence_value` is still required because it determines how the operator interacts with **other** operators. For example, `=` at precedence 50 and `+` at precedence 80 ensures `a + b = c` parses as `(a + b) = c`.

### 14.4.3 Disambiguation Guidelines

- Use parentheses when precedence is unclear
- Use qualified names to disambiguate overloaded symbols
- Avoid relying on implicit grouping for complex expressions

## 14.5 Logic Encoding Details

This section describes how advanced term expressions map to First-Order Logic.

### 14.5.1 Structure Constructor Encoding

Structure constructors are encoded as FOL function applications:

| Mizar Source | FOL Encoding |
| --- | --- |
| `Point(x: 3, y: 4)` | `make_Point(3, 4)` |
| `Rect(w: a, h: b)` | `make_Rect(a, b)` |

### 14.5.2 Selector Access Encoding

Selectors are encoded as FOL functions:

| Mizar Source | FOL Encoding |
| --- | --- |
| `p.x` | `Point_x(p)` |
| `line.start.x` | `Point_x(Line_start(line))` |

### 14.5.3 Set Comprehension Encoding

Set comprehensions are encoded using the Replacement axiom schema. The generator variable must range over elements of a set, guaranteeing the result is a set:

```
{ f(x) where x is Element of S : P(x) }
⇒  ∃Z. ∀y. (y ∈ Z ↔ ∃x. x ∈ S ∧ P(x) ∧ y = f(x))
```

When the condition is omitted:

```
{ f(x) where x is Element of S }
⇒  ∃Z. ∀y. (y ∈ Z ↔ ∃x. x ∈ S ∧ y = f(x))
```

**Example**:

| Mizar Source | FOL Encoding |
| --- | --- |
| `{ n where n is Element of NAT : n < 10 }` | `{ y : ∃n. n ∈ NAT ∧ n < 10 ∧ y = n }` |
| `{ n*n where n is Element of NAT : n < 5 }` | `{ y : ∃n. n ∈ NAT ∧ n < 5 ∧ y = n*n }` |
| `{ f.x where x is Element of dom f }` | `{ y : ∃x. x ∈ dom(f) ∧ y = f(x) }` |

### 14.5.4 `qua` Operator Encoding

The `qua` operator generates a type assertion premise:

```
(x qua T).field
⇒  Precondition: is_T(x)
⇒  Result: T_field(x)
```

## 14.6 Complete Syntax (EBNF)

Summary of advanced term expression syntax.

```ebnf
(* Structure Expressions *)
structure_expression ::= struct_constructor | selector_access ;
struct_constructor   ::= struct_name "(" [ field_assignment_list ] ")" ;
field_assignment_list ::= field_assignment { "," field_assignment } ;
field_assignment     ::= field_name ":" term_expression ;
selector_access      ::= term_expression "." field_name ;

(* Field Declaration with Optional Default - see Chapter 6 *)
field_decl           ::= "field" identifier "->" type_expression [ ":=" term_expression ] ";" ;

(* Set Comprehension *)
set_comprehension    ::= "{" term_expression "where" typed_var_list [ ":" formula ] "}" ;
typed_var_list       ::= typed_var { "," typed_var } ;
typed_var            ::= identifier "is" type_expression ;  (* type must be Element of <set> *)

(* Type Qualification *)
qua_expression       ::= "(" term_expression "qua" type_expression ")" ;

(* Operator Precedence *)
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value      ::= integer ;  (* 0-255 *)
associativity         ::= "left_associative" | "right_associative" | "non_associative" ;
```
