# 7. Expressions

- [7. Expressions](#7-expressions)
    - [7.1. Primary Expressions](#71-primary-expressions)
        - [7.1.1. Variable Identifiers](#711-variable-identifiers)
        - [7.1.3. The `it` Keyword](#713-the-it-keyword)
        - [7.1.4. Parenthesized Expressions](#714-parenthesized-expressions)
    - [7.2. Functor Applications](#72-functor-applications)
        - [7.2.1. Infix Functor Application](#721-infix-functor-application)
        - [7.2.2. Prefix and Postfix Functor Application](#722-prefix-and-postfix-functor-application)
        - [7.2.3. Function-style Application](#723-function-style-application)
        - [7.2.4. Bracket Functor Application](#724-bracket-functor-application)
    - [7.3. Structure Expressions](#73-structure-expressions)
        - [7.3.1. Structure Constructor](#731-structure-constructor)
        - [7.3.2. Structure Reference](#732-structure-reference)
        - [7.3.3. Selector Access](#733-selector-access)
    - [7.4. Set Construction Expressions](#74-set-construction-expressions)
        - [7.4.1. Fraenkel Operator (Set Comprehension)](#741-fraenkel-operator-set-comprehension)
        - [7.4.2. Set of All Construction](#742-set-of-all-construction)
    - [7.5. Choice and Definite Description](#75-choice-and-definite-description)
        - [7.5.1. The Type Expression](#751-the-type-expression)
        - [7.5.2. The Selector Expression](#752-the-selector-expression)
    - [7.6. Type Conversion](#76-type-conversion)
        - [7.6.1. Qua Operator](#761-qua-operator)
    - [7.7. Operator Precedence and Associativity](#77-operator-precedence-and-associativity)
        - [7.7.1. Precedence Rules](#771-precedence-rules)
        - [7.7.2. Associativity Rules](#772-associativity-rules)
        - [7.7.3. Disambiguation Techniques](#773-disambiguation-techniques)

## 7.1. Primary Expressions

Primary expressions are the most fundamental syntactic elements in Mizar's expression system. They represent atomic values, references, and basic constructs that form the building blocks for more complex expressions.

### 7.1.1. Variable Identifiers

A variable identifier refers to a variable declared in the current scope.

**Syntax** (as defined in [2.6.1](./2.lexical_structure.md#261-syntax-and-usage)):

```bnf
Identifier = (Letter | "_") { Letter | Digit | "_" | "'" } .
Letter = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z" .
Digit  = "0" | "1" | ... | "9" .
```

**Resolution Order**: A variable identifier is resolved according to the following scoping rules:

1. The innermost proof-level declarations
2. Outer proof scopes
3. Module-level `reserve` declarations

**Example**:

```mizar
reserve x for Real;

theorem
  for x being Nat holds x >= 0
proof
  let x be Nat;  :: `x` here refers to the Nat variable
  x >= 0;
end;
```

### 7.1.3. The `it` Keyword

The keyword `it` is a special identifier used only within function definitions to refer to the result being defined.

**Syntax**:

```bnf
"it"
```

**Permitted Context**:

* Within a `func` block (function definitions)

**Example**:

```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z be object holds z in it iff z in X or z in Y;
end;
```

**Restrictions**:

* `it` may only be used to refer to the object currently being defined.
* Usage of `it` outside a definition block results in an error.

### 7.1.4. Parenthesized Expressions

Parenthesized expressions allow grouping of sub-expressions to override default operator precedence or improve readability.

**Syntax:**
```bnf
"(" Term-Expression ")"
```

**Purpose:**
1. **Precedence override:**
   ```mizar
   (a + b) * c      :: Addition performed before multiplication
   a * (b + c)      :: Grouping for clarity
   ```

2. **Complex expression grouping:**
   ```mizar
   ((a + b) * c) / (d - e)
   ```

3. **Readability improvement:**
   ```mizar
   (x > 0) & (y > 0)    :: Logical grouping for clarity
   ```

**Nesting:**
Arbitrary levels of nesting are supported:
```mizar
(((a + b) * c) + (d / (e - f)))
```

**Type preservation:**
Parenthesized expressions preserve the type of their contained expression:
```mizar
let x be Real;
let result = (x + 1);    :: result has type Real
```

**Note:** While parentheses can always be used for grouping, they are only necessary when the default precedence rules would produce different results. See [Section 7.7: Operator Precedence and Associativity](#77-operator-precedence-and-associativity) for detailed precedence rules.

## 7.2. Functor Applications

### 7.2.1. Infix Functor Application

### 7.2.2. Prefix and Postfix Functor Application

### 7.2.3. Function-style Application

### 7.2.4. Bracket Functor Application

## 7.3. Structure Expressions

### 7.3.1. Structure Constructor

### 7.3.2. Structure Reference

### 7.3.3. Selector Access

## 7.4. Set Construction Expressions

### 7.4.1. Fraenkel Operator (Set Comprehension)

### 7.4.2. Set of All Construction

## 7.5. Choice and Definite Description

### 7.5.1. The Type Expression

### 7.5.2. The Selector Expression

## 7.6. Type Conversion

### 7.6.1. Qua Operator

## 7.7. Operator Precedence and Associativity

### 7.7.1. Precedence Rules

### 7.7.2. Associativity Rules

### 7.7.3. Disambiguation Techniques