# 7. Expression Syntax

- [7. Expression Syntax](#7-expression-syntax)
    - [7.1. Primary Expressions](#71-primary-expressions)
        - [7.1.1. Identifiers and Variables](#711-identifiers-and-variables)
        - [7.1.2. Numerals](#712-numerals)
        - [7.1.3. Parenthesized Expressions](#713-parenthesized-expressions)
    - [7.2. Function Application Expressions](#72-function-application-expressions)
        - [7.2.1. Prefix Application](#721-prefix-application)
        - [7.2.2. Infix Application](#722-infix-application)
        - [7.2.3. Postfix Application](#723-postfix-application)

## 7.1. Primary Expressions

Primary expressions are the basic building blocks of all expressions in Mizar. They represent the most fundamental syntactic elements that can appear in expression contexts.

### 7.1.1. Identifiers and Variables

**Syntax:**
```bnf
Identifier = (Letter | "_") { Letter | Digit | "_" | "'" } .
Letter = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z" .
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" .
```

**Usage:**
Identifiers serve multiple roles in expressions:
- Variable references
- Constant references (from `set` declarations)
- Parameter references in local scopes

**Examples:**
```mizar
x          :: Simple variable reference
x'         :: Variable with apostrophe
my_var     :: Variable with underscore
_temp      :: Variable starting with underscore
```

**Scope Resolution:**
When an identifier appears in an expression, Mizar resolves it according to scoping rules defined in [Chapter 4: Variables and Constants](./4.variables_and_constants.md).

### 7.1.2. Numerals

**Syntax:**
```bnf
Numeral = "0" | NonZeroDigit { Digit } .
NonZeroDigit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" .
```

**Type:**
- All numerals have type `natural Number`
- Type inference is automatic

**Examples:**
```mizar
0, 1, 42, 999, 12345
```

**Note:** For detailed lexical rules, see [Section 2.5: Numerals and Literals](./2.lexical_structure.md#25-numerals-and-literals).

### 7.1.3. Parenthesized Expressions

**Syntax:**
```bnf
ParenthesizedExpression = "(" Expression ")" .
```

**Purpose:**
- Override default operator precedence
- Improve readability
- Group complex expressions

**Examples:**
```mizar
(x + y)
(a * b + c)
((x + y) * z)
```

**Nested Parentheses:**
Arbitrary nesting levels are supported:
```mizar
(((a + b) * c) + d)
```

## 7.2. Function Application Expressions

Function application expressions represent the invocation of functors (functions) with arguments. Mizar supports multiple syntactic forms for function application to accommodate mathematical notation conventions.

### 7.2.1. Prefix Application

**Syntax:**
```bnf
PrefixApplication = FunctorSymbol "(" ArgumentList ")" .
FunctorSymbol = Identifier | Symbol .
ArgumentList = [ Expression { "," Expression } ] .
```

**Usage:**
Standard function call syntax with the functor name followed by parenthesized arguments.

**Examples:**
```mizar
sin(x)                    :: Single argument
max(a, b)                 :: Multiple arguments
dom(f)                    :: Domain of function f
card(X)                   :: Cardinality of set X
BinOp(S, T)              :: Binary operation constructor
```

**Nested Applications:**
```mizar
sin(cos(x))              :: Composition
max(a, min(b, c))        :: Nested calls
```

### 7.2.2. Infix Application

**Syntax:**
```bnf
InfixApplication = Expression InfixSymbol Expression .
InfixSymbol = Symbol .
```

**Usage:**
Binary functors can be used in infix notation when defined with appropriate syntax patterns.

**Examples:**
```mizar
a + b                    :: Addition
x * y                    :: Multiplication  
A \/ B                   :: Set union
f .: X                   :: Image of set X under function f
x in S                   :: Set membership (predicate, but similar syntax)
```

**Chaining:**
Multiple infix operations follow precedence and associativity rules:
```mizar
a + b * c                :: Equivalent to a + (b * c)
x \/ Y \/ Z              :: Left associative: (x \/ Y) \/ Z
```

### 7.2.3. Postfix Application

**Syntax:**
```bnf
PostfixApplication = Expression PostfixSymbol .
PostfixSymbol = Symbol .
```

**Usage:**
Unary functors applied after their argument, typically used for mathematical operations like inverse or transpose.

**Examples:**
```mizar
f"                       :: Function inverse
M~                       :: Matrix transpose
G*                       :: Group of units
```

**Selector Access:**
Structure field and property access uses postfix dot notation:
```mizar
G.carrier                :: Access carrier field of structure G
R.zero                   :: Access zero property of structure R
L.add                    :: Access addition operation of structure L
```

**Method-style Notation:**
Some functors support method-style syntax:
```mizar
X.card                   :: Equivalent to card(X)
f.dom                    :: Equivalent to dom(f)
S.elements               :: Elements of set S
```