# 12. Symbol Management

- [12. Symbol Management](#12-symbol-management)
  - [12.1 Synonyms and Antonyms](#121-synonyms-and-antonyms)
  - [12.2 Scope and Visibility](#122-scope-and-visibility)
  - [12.3 Import Behavior and Conflict Resolution](#123-import-behavior-and-conflict-resolution)
  - [12.4 Public and Private Symbols](#124-public-and-private-symbols)
  - [12.5 Logic Encoding Details](#125-logic-encoding-details)
  - [12.6 Complete Syntax (EBNF)](#126-complete-syntax-ebnf)

## 12.1 Synonyms and Antonyms

Mizar allows the definition of **synonyms** and **antonyms** for predicates, functors, modes, and attributes. These provide alternative notations while maintaining semantic equivalence.

**Syntax (EBNF)**:

```ebnf
synonym_def  ::= "synonym" alt_pattern "for" original_pattern ";" ;
antonym_def  ::= "antonym" alt_pattern "for" original_pattern ";" ;
alt_pattern  ::= pred_pattern | func_pattern | mode_pattern | attr_pattern ;
```

### 12.1.1 Predicate Synonyms and Antonyms

```mizar
definition
  let a, b be Real;
  pred LessThanDef: a < b means ...;
  synonym b > a for a < b;
  antonym a >= b for a < b;
end;
```

### 12.1.2 Functor Synonyms

```mizar
definition
  let f be Function;
  func InverseDef: f" -> Function means ...;
  synonym inv(f) for f";
end;
```

### 12.1.3 Mode Synonyms

```mizar
definition
  let G be set;
  mode FinSequenceDef: FinSequence of G is ...;
  synonym FinSeq of G for FinSequence of G;
end;
```

### 12.1.4 Attribute Synonyms and Antonyms

```mizar
definition
  let R be Ring;
  attr CommutativeDef: R is commutative means ...;
  synonym R is abelian for R is commutative;
end;

definition
  let S be set;
  attr FiniteDef: S is finite means ...;
  antonym S is infinite for S is finite;
end;
```

### 12.1.5 Benefits

| Benefit | Description |
| --- | --- |
| **Alternative notations** | Support different mathematical conventions |
| **Natural negation** | Express negation without explicit `non` or `not` |
| **Semantic equivalence** | Maintain logical identity while improving readability |
| **Compatibility** | Match conventions from different mathematical traditions |

## 12.2 Scope and Visibility

### 12.2.1 Scope Hierarchy

Symbols are visible according to the following hierarchy:

| Level | Description | Example |
| --- | --- | --- |
| **Local** | Defined within current proof block | `deffunc`, `defpred` |
| **Module** | Defined at module level | `pred`, `func`, `mode`, `attr` |
| **Imported** | Made available via `import` | `import mml.algebra.group` |

### 12.2.2 Module-Level Definitions

```mizar
definition
  let x, y be Integer;
  pred DivisibilityDef: x divides y means ex k be Integer st y = x * k;
end;
```

### 12.2.3 Imported Symbols

```mizar
import mml.algebra.group;
import mml.topology.space as top;
```

### 12.2.4 Precedence Rules

1. **Local definitions** take precedence over module-level definitions
2. **Module-level definitions** take precedence over imported symbols
3. **Later imports** take precedence over earlier imports (when unqualified)
4. **Redefinitions** require the `redefine` keyword

## 12.3 Import Behavior and Conflict Resolution

**Syntax (EBNF)**:

```ebnf
import_stmt    ::= "import" module_path [ "as" alias ] ";" ;
module_path    ::= identifier { "." identifier } ;
alias          ::= identifier ;
qualified_name ::= [ module_path "." ] symbol_name ;
```

### 12.3.1 Import Syntax

```mizar
import mml.algebra.group;           :: direct import
import mml.topology.space as top;   :: aliased import
```

### 12.3.2 Conflict Resolution Strategies

**1. Namespace Qualification**

```mizar
import mml.algebra.group;
import mml.topology.topological_group as top_grp;

let G be mml.algebra.group.Group;
let T be top_grp.Group;
```

**2. Module Precedence**

```mizar
import mml.set_theory.cardinal;

definition
  let A, B be set;
  :: Local definition takes precedence over imported cardinal.card_leq
  pred LocalCardLeq: A card_leq B means card A c= card B;
end;
```

**3. Longest-Match Rule**

During lexical analysis, the longest matching token is selected:

```mizar
:: Suppose + and ++ are both defined symbols
a ++ b   :: Parsed as (a) (++) (b), not (a) (+) (+) (b)
```

## 12.4 Public and Private Symbols

**Syntax (EBNF)**:

```ebnf
visibility   ::= [ "private" ] ;
private_def  ::= "private" ( pred_def | func_def | mode_def | attr_def ) ;
```

### 12.4.1 Visibility Defaults

| Symbol Type | Default Visibility |
| --- | --- |
| `pred`, `func`, `mode`, `attr`, `struct` | Public |
| `theorem`, `lemma` | Public |
| `synonym`, `antonym` | Follows base symbol |

### 12.4.2 Private Declarations

```mizar
definition
  let x, y be Real;
  private pred HelperPred: helper(x, y) means x * x + y * y < 1;
end;

definition
  let x be Real;
  private func IntermediateFunc: intermediate(x) -> Real equals x * x + 1;
end;
```

### 12.4.3 Private Symbol Behavior

* Excluded from public module interface
* Not accessible via import from other modules
* Not re-exported by dependent modules
* Useful for internal helper definitions

## 12.5 Logic Encoding Details

This section describes how symbol management constructs map to First-Order Logic.

### 12.5.1 Synonym Encoding

Synonyms are encoded as logical equivalences:

| Mizar Source | FOL Encoding |
| --- | --- |
| `synonym b > a for a < b` | `∀a,b. (b > a) ↔ (a < b)` |
| `synonym inv(f) for f"` | `∀f. inv(f) = inverse(f)` |
| `synonym FinSeq of G for FinSequence of G` | `∀G,x. is_FinSeq(x,G) ↔ is_FinSequence(x,G)` |

### 12.5.2 Antonym Encoding

Antonyms are encoded as logical negations:

| Mizar Source | FOL Encoding |
| --- | --- |
| `antonym a >= b for a < b` | `∀a,b. (a >= b) ↔ ¬(a < b)` |
| `antonym S is infinite for S is finite` | `∀S. is_infinite(S) ↔ ¬is_finite(S)` |

### 12.5.3 Visibility Encoding

Private symbols are not exported to the logical interface:

```
private pred helper(x, y) means φ
⇒  (internal only, not in exported theory)
```

Public symbols generate exported axioms:

```
pred P(x, y) means φ
⇒  forall x, y (P(x, y) ↔ φ)  [exported]
```

### 12.5.4 Import Encoding

Imports make external axioms available in the current theory:

```
import mml.algebra.group
⇒  Include all exported axioms from mml.algebra.group
```

## 12.6 Complete Syntax (EBNF)

Summary of symbol management syntax.

```ebnf
(* Synonyms and Antonyms *)
synonym_def    ::= "synonym" alt_pattern "for" original_pattern ";" ;
antonym_def    ::= "antonym" alt_pattern "for" original_pattern ";" ;

(* Import Statements *)
import_stmt    ::= "import" module_path [ "as" alias ] ";" ;
module_path    ::= identifier { "." identifier } ;
alias          ::= identifier ;
qualified_name ::= [ module_path "." ] symbol_name ;

(* Visibility *)
visibility     ::= [ "private" ] ;
private_pred   ::= "private" pred_def ;
private_func   ::= "private" func_def ;
private_mode   ::= "private" mode_def ;
private_attr   ::= "private" attr_def ;

(* Symbol Patterns *)
pred_pattern   ::= [ loci ] predicate_symbol [ loci ] ;
func_pattern   ::= [ loci ] functor_symbol [ loci ] ;
mode_pattern   ::= mode_name [ type_params ] ;
attr_pattern   ::= [ param_prefix ] attribute_name ;
```
