# 12. Symbol Management

- [12. Symbol Management](#12-symbol-management)
    - [12.1. Definition and Usage](#121-definition-and-usage)
    - [12.2. Benefits of Synonyms and Antonyms](#122-benefits-of-synonyms-and-antonyms)
    - [12.3. Scope and Visibility Rules](#123-scope-and-visibility-rules)
    - [12.4. Import Behavior and Conflicts](#124-import-behavior-and-conflicts)

## 12.1. Definition and Usage

Mizar supports synonyms and antonyms for different language constructs:

**Predicate synonyms and antonyms**:
```mizar
definition
  let a, b be Real;
  pred a < b means ...;
  synonym b > a for a < b;
  antonym b >= a for a < b;
end
```

**Functor synonyms**:
```mizar
definition
  let f be Function;
  func f" -> Function means ...;
  synonym inv f for f";
end
```

**Mode synonyms**:
```mizar
definition
  let G be set;
  mode FinSequence of G is ...;
  synonym FinSeq of G for FinSequence of G;
end
```

**Attribute synonyms and antonyms**:
```mizar
definition
  let R be Ring;
  attr R is commutative means ...;
  synonym R is abel for R is commutative;
end

definition
  let a be set;
  attr a is finite means ...;
  antonym a is infinite for a is finite;
end
```

## 12.2. Benefits of Synonyms and Antonyms

Synonyms and antonyms provide several key advantages:
- Enable multiple standard mathematical notations for the same concept
- Allow transformation between different operator positions (infix ↔ prefix ↔ postfix)
- Provide natural negation without explicit `not` or `non` usage
- Support argument order changes in predicates and functors
- Maintain semantic equivalence while enhancing readability
- Facilitate compatibility with various mathematical conventions

## 12.3. Scope and Visibility Rules

**Symbol scope hierarchy** in Mizar:

**Module-level symbols** (predicates, functors, modes, attributes, structures):
```mizar
definition
  let x, y be Real;
  pred x divides y means ...;  :: Symbol visible throughout module
end
```

**Imported symbols** from other modules:
```mizar
import mml.algebra.group;
:: All public symbols (Group, associative, etc.) become available
```

**Symbol precedence rules**:
- Module-defined symbols take precedence over imported symbols with the same name
- Redefinition of symbols within a module requires explicit `redefine` keyword
- Identifiers take precedence over symbols when forming valid identifier patterns

## 12.4. Import Behavior and Conflicts

**Symbol import process**:
```mizar
import mml.algebra.group;         :: Import all public symbols
import mml.topology.space as top; :: Import with alias to avoid conflicts
```

**Conflict resolution strategies**:

1. **Namespace qualification**:
  ```mizar
  import mml.algebra.group;
  import mml.topology.group as top_group;
  
  let G be algebra.group.Group;    :: Full path to avoid ambiguity
  let T be top_group.Group;        :: Using alias
  ```

2. **Module symbol precedence**:
  ```mizar
  import mml.set_theory.cardinal;  :: contains predicate card_leq
  
  definition
    let A, B be set;
    pred A card_leq B means 
      card A <= card B;    :: Local definition takes precedence
  end

  let X, Y be set;
  X card_leq Y;                    :: Uses the local definition
  X cardinal.card_leq Y;           :: Uses the imported symbol explicitly
  ```

3. **Lexer longest-match rule**:
  - When multiple symbols could match, lexer selects the longest matching symbol
  - Example: If both `+` and `++` are defined, `a++b` matches `++` operator

**Import visibility**:
- All symbols are importable unless explicitly marked as `private`
- Private symbols remain invisible to importing modules
- Synonyms and antonyms are imported along with their original symbols

**Private symbol declarations**:
```mizar
definition
  private pred internal_helper(x, y) means ...;  :: Not importable
  
  let x, y be Real;
  func x + y -> Real means ...;                   :: Public, importable
  
  private func compute_intermediate(x) -> Real    :: Not importable
    equals x * internal_helper_constant;
end
```

Private symbols can be applied to:
- Predicates (`pred`)
- Functors (`func`) 
- Modes (`mode`)
- Attributes (`attr`)
- Structures (`struct`)
- Theorems and other constructs (as described in [Chapter 3](./3.modules_and_namespaces.md))

**Advanced conflict resolution**:
For detailed information on overload resolution and complex disambiguation mechanisms, see [Chapter 13: Type Conversion and Overload Resolution](./13.type_conversion_and_overload_resolution.md).