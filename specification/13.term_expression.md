# 13. Term Expressions

- [13. Term Expressions](#13-term-expressions)
  - [13.1 Primary Expressions](#131-primary-expressions)
  - [13.2 Functor Applications](#132-functor-applications)
  - [13.3 Structure Expressions](#133-structure-expressions)
  - [13.4 Set Expressions](#134-set-expressions)
  - [13.5 Type Qualification (`qua`)](#135-type-qualification-qua)
  - [13.6 Operator Precedence and Associativity](#136-operator-precedence-and-associativity)
  - [13.7 Logic Encoding Details](#137-logic-encoding-details)
  - [13.8 Complete Syntax (EBNF)](#138-complete-syntax-ebnf)

## 13.1 Primary Expressions

Primary expressions represent atomic values, references, and basic constructs that form the building blocks of more complex terms.

**Syntax (EBNF)**:

```ebnf
primary_expression ::= variable_identifier
                     | "it"
                     | "(" term_expression ")"
                     | numeral ;
variable_identifier ::= identifier ;
numeral            ::= digit+ ;
```

### 13.1.1 Variable Identifiers

Variable identifiers are references to previously declared variables. Their usage follows the general scoping rules of the language.

See [Chapter 4 (Variables and Constants)](./04.variables_and_constants.md) for detailed rules on variable declaration, scope, shadowing, and reserved identifiers.

**Example**:

```mizar
let x be Nat;
let y be Nat;
x + y;
```

### 13.1.2 The `it` Keyword

`it` refers to the object currently being defined within a `func` block using the `means` style.

**Example**:

```mizar
definition
  let X, Y be set;
  func UnionDef: X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end;
```

**Restrictions**:
- Only allowed inside a `func` definition with `means`
- Refers exclusively to the return object being defined
- Not available in `equals` definitions (the value is explicit)

### 13.1.3 Parenthesized Expressions

Used for grouping and precedence control.

**Example**:

```mizar
(a + b) * c           :: Override default precedence
(x > 0) & (y > 0)     :: Group formula parts
(((a + b) * c) + d)   :: Arbitrary nesting
```

**Semantics**:
- Parentheses override default operator precedence
- Arbitrary nesting is supported
- Type of expression is preserved through parenthesization

### 13.1.4 Numerals

Numeric literals for natural numbers.

**Example**:

```mizar
0
42
1000
```

## 13.2 Functor Applications

Functor applications construct terms by applying user-defined functors to arguments.

**Syntax (EBNF)**:

```ebnf
functor_application ::= [ functor_loci ] functor_symbol [ functor_loci ]
                      | left_bracket loci right_bracket
                      | inline_functor_application ;
functor_loci       ::= locus | "(" loci ")" ;
loci               ::= locus { "," locus } ;
locus              ::= term_expression ;
inline_functor_application ::= inline_func_name "(" loci ")" ;  (* mandatory parens *)
```

> [!NOTE]
> For symbolic functors, parentheses are **optional for single arguments** and **required for multiple arguments**. Inline functors always require parentheses.

### 13.2.1 Classification of Functors

| Type | Declaration | Scope | Example |
| --- | --- | --- | --- |
| **Symbolic** | `func Label: pattern -> type ...` | Module-level | `x + y`, `|.x.|` |
| **Inline** | `deffunc name(args) -> type equals ...` | Proof-local | `double(n)` |

### 13.2.2 Symbolic Functor Applications

Symbolic functors support multiple notation styles:

| Notation | Pattern | Example |
| --- | --- | --- |
| **Prefix** | `symbol x` or `symbol(x, y)` | `- x`, `max(a, b)` |
| **Infix** | `x symbol y` | `x + y`, `X \/ Y` |
| **Postfix** | `x symbol` | `n !`, `f "` |
| **Bracket** | `left x, y right` | `[: X, Y :]`, `|. x .|` |

> [!NOTE]
> For single arguments, parentheses are optional: `sin x` and `sin(x)` are equivalent.
> For multiple arguments, parentheses are required: `max(a, b)`.

```mizar
:: Prefix (single arg - parens optional)
- x
card X
sin x       :: equivalent to sin(x)
sin(x)

:: Prefix (multi-arg - parens required)
max(a, b)
min(x, y, z)

:: Infix
x + y
X \/ Y

:: Postfix
n !

:: Bracket
[: A, B :]
|. x .|
```

### 13.2.3 Inline Functor Applications

Inline functors (defined with `deffunc`) are local to proof blocks.

**Definition Syntax**:

```ebnf
inline_func_def ::= "deffunc" identifier "(" typed_param_list ")" "->" type_expression
                    "equals" term_expression ";" ;
typed_param_list ::= typed_param { "," typed_param } ;
typed_param      ::= identifier "be" type_expression ;
```

> [!IMPORTANT]
> Inline functors **require parentheses** in both definition and application, even for single arguments.

**Example**:

```mizar
proof
  deffunc double(n be Nat) -> Nat equals n + n;
  deffunc triple(n be Nat) -> Nat equals n + n + n;
  
  A1: double(3) = 6;
  A2: triple(3) = 9;
  ...;
end;
```

**Semantics**:
- Inline functors are expanded by substitution
- Not visible outside the defining proof block
- Useful for proof-local abbreviations

> [!NOTE]
> For detailed information on `deffunc`, see [Chapter 17 (Statements), §17.2.3](./17.statements.md#1723-inline-function-definition-deffunc).

## 13.3 Structure Expressions

Structure expressions allow construction and manipulation of structured data values based on user-defined `struct` types (see [Chapter 7](./07.structures.md)).

**Syntax (EBNF)**:

```ebnf
structure_expression ::= struct_constructor | selector_access ;
struct_constructor   ::= struct_name "(" [ field_assignment_list ] ")" ;
field_assignment_list ::= field_assignment { "," field_assignment } ;
field_assignment     ::= field_name ":" term_expression ;
selector_access      ::= term_expression "." field_name ;
```

### 13.3.1 Structure Constructor

A structure value is created by supplying field-value pairs.

**Example**:

```mizar
:: Define a Point structure with default values (from Ch.7)
struct Point where
  field x -> Real := 0.0;
  field y -> Real := 0.0;
end;

:: Construct with all fields specified
let p = Point(x: 3.0, y: 4.0);

:: Omit fields that have defaults
let origin = Point();              :: x = 0.0, y = 0.0
let on_x_axis = Point(x: 5.0);    :: x = 5.0, y = 0.0
```

**Default Value Syntax**:

Fields may declare default values using `:=` in the struct definition:

```ebnf
field_decl ::= "field" identifier "->" type_expression [ ":=" term_expression ] ";" ;
```

**Rules**:
- All fields without defaults must be specified in the constructor
- Fields with defaults may be omitted (the default value is used)
- Field names must match the structure's declaration
- Order of fields in the constructor is irrelevant
- Type of each field value must match the declared type

### 13.3.2 Selector Access

Fields of a structure are accessed using dot notation.

**Example**:

```mizar
let p = Point(x: 3.0, y: 4.0);
p.x + p.y = 7.0;  :: Field access

:: Chained access for nested structures
let line = Line(start: Point(x: 0.0, y: 0.0), end: Point(x: 1.0, y: 1.0));
line.start.x = 0.0;
line.end.y = 1.0;
```

> [!IMPORTANT]
> The traditional Mizar selector syntax `the x of p` is **deprecated**. Use dot notation `p.x` exclusively. This provides a more concise and universally familiar syntax while avoiding syntactic ambiguity with the definite description operator `the`.

### 13.3.3 Structure Update

Structure values are immutable; updates create new values.

**Example**:

```mizar
let p = Point(x: 3.0, y: 4.0);
let q = Point(x: p.x + 1.0, y: p.y);  :: New point with updated x
```

## 13.4 Set Expressions

Set expressions construct sets by enumeration or comprehension.

**Syntax (EBNF)**:

```ebnf
set_expression    ::= set_enumeration | set_comprehension ;
set_enumeration   ::= "{" [ term_list ] "}" ;
set_comprehension ::= "{" term_expression "where" typed_var_list [ ":" formula ] "}" ;
term_list         ::= term_expression { "," term_expression } ;
typed_var_list    ::= typed_var { "," typed_var } ;
typed_var         ::= identifier "is" type_expression ;
```

### 13.4.1 Set Enumeration

Explicit listing of set elements.

**Example**:

```mizar
{}              :: empty set
{ a }           :: singleton
{ a, b, c }     :: finite set
```

### 13.4.2 Set Comprehension (Fraenkel Operator)

Constructs sets by specifying a mapping and filter over elements of a set.

> [!IMPORTANT]
> **Set-hood constraint**: The generator variables must range over elements of a **set** (e.g., `Element of S`), not over an arbitrary type. This ensures the result is a set rather than a proper class.
>
> ```mizar
> :: OK: x ranges over elements of a set
> { x where x is Element of NAT : x < 10 }
>
> :: NG: Group is a type (class), not a set
> { G where G is Group : G is abelian }  :: REJECTED
> ```

**Example**:

```mizar
:: Even natural numbers
{ n where n is Element of NAT : n mod 2 = 0 }

:: Squares of naturals
{ n * n where n is Element of NAT : n < 10 }

:: All elements (condition omitted)
{ f.x where x is Element of dom f }
```

> [!NOTE]
> When the condition is omitted, all elements satisfying the generator type are included. Simply omit the `: formula` part.

### 13.4.3 Multiple Generators

**Example**:

```mizar
:: Cartesian product elements (no filter needed)
{ [x, y] where x is Element of A, y is Element of B }

:: Pairs satisfying a condition
{ [x, y] where x is Element of NAT, y is Element of NAT : x + y = 10 }
```

### 13.4.4 Nested Comprehensions

**Example**:

```mizar
:: Set of sets
{ { y where y is Element of NAT : y < x }
  where x is Element of NAT : x < 5 }
```

## 13.5 Type Qualification (`qua`)

The `qua` operator explicitly views a value as a specific type without changing the value itself.

**Syntax (EBNF)**:

```ebnf
qua_expression ::= "(" term_expression "qua" type_expression ")" ;
```

### 13.5.1 Usage

**Example**:

```mizar
let R be DoubleLoopStr;

:: View R as AddLoopStr to access additive properties
(R qua AddLoopStr) is associative;

:: View R as MulLoopStr to access multiplicative properties
(R qua MulLoopStr) is commutative;
```

### 13.5.2 Restrictions

- The target type must be a supertype or compatible structural type (widening)
- For narrowing (casting to more specific type), use `reconsider` with proof

> [!NOTE]
> For `reconsider` statement syntax, see [Chapter 8 (Type Inference)](./08.type_inference.md) and [Chapter 17 (Statements), §17.5.1](./17.statements.md#1751-type-reconsideration-reconsider).

## 13.6 Operator Precedence and Associativity

User-defined functors can have explicit precedence and associativity declarations.

**Syntax (EBNF)**:

```ebnf
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value      ::= integer ;  (* 0-255 *)
associativity         ::= "left_associative" | "right_associative" | "non_associative" ;
```

### 13.6.1 Precedence Rules

Each symbolic functor has an associated precedence level (0–255). Higher values bind more tightly.

**Example**:

```mizar
@symbol_precedence(+, 80, left_associative);
@symbol_precedence(*, 90, left_associative);
@symbol_precedence(^, 95, right_associative);
@symbol_precedence(=, 50, non_associative);
```

With these declarations:
- `a + b * c` parses as `a + (b * c)` (higher precedence binds tighter)
- `a * b + c` parses as `(a * b) + c`
- `a + b = c + d` parses as `(a + b) = (c + d)` (precedence determines inter-operator grouping)

### 13.6.2 Associativity

| Type | Grouping | Example |
| --- | --- | --- |
| `left_associative` | Left-to-right | `a + b + c` → `(a + b) + c` |
| `right_associative` | Right-to-left | `a ^ b ^ c` → `a ^ (b ^ c)` |
| `non_associative` | Requires parentheses | `a = b = c` → **error** |

> [!NOTE]
> `non_associative` only prohibits chaining the **same** operator (e.g., `a = b = c`). The `precedence_value` is still required because it determines how the operator interacts with **other** operators. For example, `=` at precedence 50 and `+` at precedence 80 ensures `a + b = c` parses as `(a + b) = c`.

### 13.6.3 Disambiguation Guidelines

- Use parentheses when precedence is unclear
- Use qualified names to disambiguate overloaded symbols
- Avoid relying on implicit grouping for complex expressions

## 13.7 Logic Encoding Details

This section describes how term expressions map to First-Order Logic.

### 13.7.1 Variable References

Variables are encoded as FOL variables with type guards:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be Nat; x` | `x` (with context `is_Nat(x)`) |

### 13.7.2 The `it` Keyword

In `means` definitions, `it` is replaced by the function application:

```
func F(x) -> T means P(it)
⇒  forall x (P(F(x)))
```

### 13.7.3 Functor Applications

Functor applications are encoded as FOL function applications:

| Mizar Source | FOL Encoding |
| --- | --- |
| `x + y` | `add(x, y)` |
| `- x` | `neg(x)` |
| `n !` | `factorial(n)` |
| `[: A, B :]` | `cartesian_product(A, B)` |

### 13.7.4 Structure Constructor Encoding

Structure constructors are encoded as FOL function applications:

| Mizar Source | FOL Encoding |
| --- | --- |
| `Point(x: 3, y: 4)` | `make_Point(3, 4)` |
| `Rect(w: a, h: b)` | `make_Rect(a, b)` |

### 13.7.5 Selector Access Encoding

Selectors are encoded as FOL functions:

| Mizar Source | FOL Encoding |
| --- | --- |
| `p.x` | `Point_x(p)` |
| `line.start.x` | `Point_x(Line_start(line))` |

### 13.7.6 Set Expression Encoding

**Enumeration**:

| Mizar Source | FOL Encoding |
| --- | --- |
| `{}` | `empty_set` |
| `{ a }` | `singleton(a)` |
| `{ a, b }` | `union(singleton(a), singleton(b))` |

**Comprehension** (encoded using the Replacement axiom schema):

```
{ f(x) where x is Element of S : P(x) }
⇒  ∃Z. ∀y. (y ∈ Z ↔ ∃x. x ∈ S ∧ P(x) ∧ y = f(x))
```

When the condition is omitted:

```
{ f(x) where x is Element of S }
⇒  ∃Z. ∀y. (y ∈ Z ↔ ∃x. x ∈ S ∧ y = f(x))
```

### 13.7.7 `qua` Operator Encoding

The `qua` operator generates a type assertion premise:

```
(x qua T).field
⇒  Precondition: is_T(x)
⇒  Result: T_field(x)
```

### 13.7.8 Parenthesization

Parentheses do not affect FOL encoding; they only control parsing:

| Mizar Source | FOL Encoding |
| --- | --- |
| `(a + b) * c` | `mul(add(a, b), c)` |
| `a + (b * c)` | `add(a, mul(b, c))` |

## 13.8 Complete Syntax (EBNF)

Summary of all term expression syntax.

```ebnf
(* Term Expressions *)
term_expression    ::= primary_expression
                     | functor_application
                     | structure_expression
                     | set_expression
                     | qua_expression ;

(* Primary Expressions *)
primary_expression ::= variable_identifier
                     | "it"
                     | "(" term_expression ")"
                     | numeral ;
variable_identifier ::= identifier ;
numeral            ::= digit+ ;

(* Functor Applications *)
functor_application ::= [ functor_loci ] functor_symbol [ functor_loci ]
                      | left_bracket loci right_bracket
                      | inline_functor_application ;
functor_loci       ::= locus | "(" loci ")" ;
loci               ::= locus { "," locus } ;
locus              ::= term_expression ;
inline_functor_application ::= inline_func_name "(" loci ")" ;  (* mandatory parens *)

(* Inline Functor Definition - see Chapter 17 *)
inline_func_def    ::= "deffunc" identifier "(" typed_param_list ")" "->" type_expression
                       "equals" term_expression ";" ;
typed_param_list   ::= typed_param { "," typed_param } ;
typed_param        ::= identifier "be" type_expression ;

(* Structure Expressions *)
structure_expression ::= struct_constructor | selector_access ;
struct_constructor   ::= struct_name "(" [ field_assignment_list ] ")" ;
field_assignment_list ::= field_assignment { "," field_assignment } ;
field_assignment     ::= field_name ":" term_expression ;
selector_access      ::= term_expression "." field_name ;

(* Field Declaration with Optional Default - see Chapter 7 *)
field_decl           ::= "field" identifier "->" type_expression [ ":=" term_expression ] ";" ;

(* Set Expressions *)
set_expression       ::= set_enumeration | set_comprehension ;
set_enumeration      ::= "{" [ term_list ] "}" ;
set_comprehension    ::= "{" term_expression "where" typed_var_list [ ":" formula ] "}" ;
term_list            ::= term_expression { "," term_expression } ;
typed_var_list       ::= typed_var { "," typed_var } ;
typed_var            ::= identifier "is" type_expression ;  (* type must be Element of <set> *)

(* Type Qualification *)
qua_expression       ::= "(" term_expression "qua" type_expression ")" ;

(* Operator Precedence *)
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value      ::= integer ;  (* 0-255 *)
associativity         ::= "left_associative" | "right_associative" | "non_associative" ;
```
