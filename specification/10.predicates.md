# 10. Predicates and Functors: Basics

- [10. Predicates and Functors: Basics](#10-predicates-and-functors-basics)
        - [6.1.1. Role in Mizar's Mathematical Language](#611-role-in-mizars-mathematical-language)
        - [6.1.2. Relationship to First-Order Logic](#612-relationship-to-first-order-logic)
    - [6.2. Predicate Definitions](#62-predicate-definitions)
        - [6.2.1. Basic Syntax and Semantics](#621-basic-syntax-and-semantics)
        - [6.2.2. Built-in vs User-Defined Predicates](#622-built-in-vs-user-defined-predicates)
        - [6.2.3. Type Dependencies and Parameters](#623-type-dependencies-and-parameters)
        - [6.2.4. Predicate Redefinition](#624-predicate-redefinition)
    - [6.3. Functor Definitions](#63-functor-definitions)
        - [6.3.1. Basic Syntax and Semantics](#631-basic-syntax-and-semantics)
        - [6.3.2. Functor Definition Methods](#632-functor-definition-methods)
        - [6.3.3. Partial Functions and Definedness](#633-partial-functions-and-definedness)
        - [6.3.4. Type Dependencies and Return Types](#634-type-dependencies-and-return-types)
        - [6.3.5. Functor Redefinition](#635-functor-redefinition)
        - [6.3.6. Correctness Conditions](#636-correctness-conditions)

## 10.1. Overview of Predicates

Predicates are relations and properties that can be true or false
- Type: `pred P(X₁, X₂, ..., Xₙ)` where `Xᵢ` are parameter types
- Examples: `x in Y`, `X c= Y`, `f is continuous`

Predicates can be:
- **Built-in**: Basic logical and set-theoretic operations (`=`, `<>`, `in`)
- **User-defined**: Declared in articles and imported from modules
- **Overloaded**: Multiple definitions with different type signatures

Mizar's predicates correspond directly to first-order logic constructs:

```mizar
x in Y  :: ⟺  In(x, Y)
```

The type system ensures syntactic well-formedness and generates appropriate proof obligations, but Mizar's partial function semantics allow applications outside the declared domain, following the principle that all functions are total at the implementation level (with unspecified behavior outside their logical domain).

## 10.2. Predicate Definitions

### 10.2.1. Basic Syntax and Semantics

Predicates in Mizar are defined using the `pred` keyword:

```mizar
definition
  let X, Y be set;
  pred X c= Y means
    for x be object st x in X holds x in Y;
end
```

**Basic components:**
- `pred` keyword introduces a predicate definition
- Parameter declarations specify the types of arguments
- `means` clause provides the logical definition
- Predicate symbols can use almost any sequence of printable non-whitespace characters
- Lexer uses longest-match rule among imported symbols

**Semantics:**
- Predicates represent relations that evaluate to true or false
- Parameter types determine the domain of the predicate
- The `means` clause must be a well-formed logical formula

### 10.2.2. Built-in vs User-Defined Predicates

**Built-in predicates** are provided by the Mizar system:
```mizar
x = y          :: Equality
x in X         :: Set membership
x <> y         :: Inequality (antonym of =)
```

**User-defined predicates** are declared in articles:
```mizar
definition
  let m, n be Nat;
  pred m, n are_coprime means
    gcd(m, n) = 1;
end
```

**Import behavior:**
- User-defined predicates become available through import statements
- Symbol precedence follows the rules described in [Chapter 2](./2.lexical_structure.md)
- Conflicts are resolved using namespace qualification

### 10.2.3. Type Dependencies and Parameters

**Simple predicates** with fixed parameter types:
```mizar
definition
  let m, n be Nat;
  pred m divides n means
    ex k be Nat st n = m * k;
end
```

**Dependent predicates** where parameter types depend on previous parameters:
```mizar
definition
  let G be Group;
  let H be Subgroup of G;
  let a, b be Element of G;
  pred a, b are_congruent_mod H means
    a * (b") in H;
end
```

**Multiple parameter predicates**:
```mizar
definition
  let X be set;
  let R be Relation of X;
  let x, y, z be Element of X;
  pred R connects x, y via z means
    [x, z] in R & [z, y] in R;
end
```

**Type constraints in parameters:**
```mizar
definition
  let G be non empty associative Magma;
  let a, b be Element of G;
  pred a, b are_commute means
    G.binop(a, b) = G.binop(b, a);
end
```

### 10.2.4. Predicate Redefinition

Predicate redefinition allows for providing alternative logical definitions of existing predicates for more specialized types. This mechanism enables more efficient or natural characterizations while maintaining logical equivalence.

**Basic Redefinition Syntax**

The `redefine` keyword is used to modify an existing predicate definition:

```mizar
definition
  let <parameters>;
  redefine pred <predicate_pattern> means
    <alternative_definition>;
  coherence with <label_reference>
  proof
    <equivalence_proof>
  end
end
```

**Key characteristics:**
- `redefine` keyword indicates modification of an existing predicate
- The predicate must already be defined for the parameter types or their parent types
- The new definition must be logically equivalent to the original definition
- Labels can be used to reference specific parent definitions

**Example: Simplifying Conditions Through Type Specialization**

```mizar
definition
  let x be object, f be Function;
  pred x is_a_fixpoint_of f means
    :fixpoint_general: x in dom f & x = f.x;
end

definition
  let A be non empty set, a be Element of A, f be Function of A, A;
  redefine pred a is_a_fixpoint_of f means
    a = f.a;
  coherence with fixpoint_general
  proof
    :: Since f: A -> A and a ∈ A, we have a ∈ dom f automatically
    :: Therefore the domain check is redundant
  end
end
```

This redefinition eliminates the domain membership check since the type `Function of A, A` guarantees that `a ∈ dom f` for any `a ∈ A`.

**Usage Benefits**

Through predicate redefinition:
1. **Simplified Proofs**: Specialized definitions often require fewer proof steps
2. **Type Safety**: Leverages type system to eliminate redundant conditions  
3. **Computational Efficiency**: More direct characterizations for specific contexts
4. **Mathematical Clarity**: Provides the most natural definition for each type context
