# 10. Predicates

- [10. Predicates](#10-predicates)
  - [10.1 Overview and Syntax](#101-overview-and-syntax)
  - [10.2 Predicates vs Attributes](#102-predicates-vs-attributes)
  - [10.3 Definition Styles: Symbolic vs Phrase](#103-definition-styles-symbolic-vs-phrase)
  - [10.4 Dependent and Typed Parameters](#104-dependent-and-typed-parameters)
  - [10.5 Correctness Conditions](#105-correctness-conditions)
  - [10.6 Predicate Redefinition](#106-predicate-redefinition)
  - [10.7 Notation Styles](#107-notation-styles)
  - [10.8 Symbol Resolution and Imports](#108-symbol-resolution-and-imports)
  - [10.9 Logic Encoding Details](#109-logic-encoding-details)
  - [10.10 Complete Syntax (EBNF)](#1010-complete-syntax-ebnf)

## 10.1 Overview and Syntax

Predicates express properties and relations. Each predicate has a name, typed parameters, and a logical definition. Predicates always yield boolean values (true or false).

**Syntax (EBNF)**:

```ebnf
pred_def         ::= "pred" label ":" pred_pattern "means" formula ";" ;
label            ::= identifier ;
pred_pattern     ::= [ loci ] predicate_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
predicate_symbol ::= identifier | symbolic_pred ;
symbolic_pred    ::= symbol_char+ ;
```

**Example**:

```mizar
definition
  let X, Y be set;
  pred SubsetDef: X c= Y means
    for x being object st x in X holds x in Y;
end;
```

Predicates can be:

* **Built-in**: e.g., `x in X`, `x = y`, `x <> y`
* **User-defined**: declared with `pred` and `means`
* **Overloaded**: disambiguated by parameter types

> [!NOTE]
> For **inline predicate definitions** within proofs (`defpred`), see [Chapter 17 (Statements), §17.2.4](./17.statements.md#1724-inline-predicate-definition-defpred).

## 10.2 Predicates vs Attributes

Predicates and attributes are both logical assertions, but serve different purposes:

| Aspect | Predicates (`pred`) | Attributes (`attr`) |
| --- | --- | --- |
| **Purpose** | Express general relations between terms | Refine types by adding properties |
| **Arity** | Any (unary, binary, n-ary) | Unary (applied to a single subject) |
| **Syntax** | `x c= y`, `a divides b` | `x is even`, `G is associative` |
| **Type system role** | Used in formulas and proofs | Used in type expressions and clustering |
| **Clustering** | Not clusterable | Participates in cluster registrations |

**When to use predicates**:
- Expressing relations between multiple objects: `x c= y`
- Defining mathematical relations: `a divides b`
- General logical assertions in proofs

**When to use attributes**:
- Refining types: `let n be positive even Integer`
- Enabling type inference through clusters
- Properties that should be inherited via subtyping

**Example comparison**:

```mizar
:: As an attribute (for type refinement)
definition
  let n be Integer;
  attr EvenAttr: n is even means 2 divides n;
end;

:: As a predicate (for general use)
definition
  let a, b be Integer;
  pred DividesDef: a divides b means
    ex k be Integer st b = a * k;
end;

:: Attributes participate in type expressions
let n be positive even Integer;

:: Predicates are used in formulas
assume 2 divides n;
```

> [!NOTE]
> Detailed attribute syntax and semantics are defined in [Chapter 7 (Attributes)](./07.attributes.md).

## 10.3 Definition Styles: Symbolic vs Phrase

Mizar supports two styles of predicate patterns:

### 10.3.1 Symbolic Predicates

Use symbolic operators for mathematical notation:

```mizar
definition
  let x, y be Real;
  pred LessOrEqualDef: x <= y means
    x < y or x = y;
end;
```

### 10.3.2 Phrase Predicates

Use word-based patterns for readability:

```mizar
definition
  let n be Nat;
  pred EvenDef: n is_even means ex k be Nat st n = 2 * k;
end;

definition
  let G be Group, a, b be Element of G;
  pred CommuteDef: a, b are_commute means
    G.binop(a, b) = G.binop(b, a);
end;
```

### 10.3.3 Multi-argument Predicates

Predicates can take multiple arguments on either or both sides of the symbol:

```mizar
definition
  let X, Y, Z be set;
  pred PartitionDef: X, Y partition Z means
    X \/ Y = Z & X /\ Y = {};
end;
```

> [!NOTE]
> Since `pred_pattern` allows only a single predicate symbol, patterns like `a < b < c` (with the symbol appearing twice) are **not** supported. Use conjunctions in the defining formula instead: `pred BetweenDef: (a, b, c) are_between means a < b & b < c;`

## 10.4 Dependent and Typed Parameters

Parameter types can depend on earlier parameters:

```mizar
definition
  let G be Group;
  let H be Subgroup of G;
  let a, b be Element of G;
  pred CongruenceDef: a, b are_congruent_mod H means
    a * b" in H;
end;
```

You may also constrain types using attributes:

```mizar
definition
  let G be non empty associative Magma;
  let a, b be Element of G;
  pred CommuteDef: a, b are_commute means
    G.binop(a, b) = G.binop(b, a);
end;
```

Domain restrictions via `assume`:

```mizar
definition
  let n, m be Integer;
  assume m <> 0;
  pred DivisibleDef: m divides n means
    ex k be Integer st n = m * k;
end;
```

## 10.5 Correctness Conditions

Unlike functors, predicates defined via `means` do **not** require existence or uniqueness proofs because they directly specify a boolean condition.

However, the following conditions apply:

| Condition | Description |
| --- | --- |
| **Well-formedness** | The defining formula must be syntactically valid |
| **Type correctness** | All terms in the formula must be type-correct |
| **Definedness** | If `assume` is used, the predicate is undefined outside the assumed domain |

> [!NOTE]
> Predicates do not have a uniqueness requirement like functors, since they simply evaluate to true or false.

## 10.6 Predicate Redefinition

Existing predicates can be redefined for more specific types. This improves clarity and removes redundant conditions.

**Syntax**:

```ebnf
redefine_pred  ::= "redefine" "pred" pred_pattern "means" formula ";"
                   "coherence" [ "with" label ] proof_or_refs ";" ;
proof_or_refs  ::= proof_block | "by" references ";" ;
```

**Example**:

```mizar
definition
  let x be object, f be Function;
  pred fixpoint_general: x is_a_fixpoint_of f means
    x in dom f & x = f.x;
end;

definition
  let A be non empty set, a be Element of A, f be Function of A, A;
  redefine pred a is_a_fixpoint_of f means
    a = f.a;
  coherence with fixpoint_general
  proof
    :: dom f = A, so membership is implied
    ...;
  end;
end;
```

Redefinition requirements:

* Use `redefine pred`
* Refer to original using a label (e.g., `fixpoint_general`)
* Provide a `coherence` proof to show logical equivalence under the new parameter types

## 10.7 Notation Styles

Supported notations:

| Notation | Pattern | Example |
| --- | --- | --- |
| **Infix** | `x symbol y` | `x c= y`, `a divides b` |
| **Prefix** | `symbol x` | `is_prime n` |
| **Postfix** | `x symbol` | `n is_even` |
| **Multi-infix** | `x, y symbol z` | `a, b partition c` |

**Symbolic examples**:

```mizar
pred SubsetDef: X c= Y means ...;       :: infix symbolic
pred ElementDef: x in X means ...;      :: infix symbolic
pred EqualsDef: x = y means ...;        :: infix symbolic
pred LessThanDef: x < y means ...;      :: infix symbolic
```

**Phrase examples**:

```mizar
pred DividesDef: m divides n means ...;      :: infix phrase
pred PrimeDef: is_prime n means ...;         :: prefix phrase
pred CommuteDef: a, b are_commute means ...; :: multi-infix phrase
```

> [!NOTE]
> Unlike functors, **predicates do not have operator precedence or associativity**. Predicate applications are parsed as atomic formulas and combined using logical connectives (`&`, `or`, `implies`, etc.) which have their own fixed precedence. See [Chapter 16 (Quantification and Logical Connectives)](./16.quantification_and_logical_connectives.md) for logical operator precedence.

## 10.8 Symbol Resolution and Imports

User-defined predicates are made available by importing their defining modules. Conflicts between names are resolved by:

* **Longest-match rule** during lexing
* **Qualified names** when needed:

```mizar
import algebra.group as grp;
let G be set;
assume grp.is_subgroup(H, G);
```

Ambiguous predicate symbols can also be resolved using qualified names:

```mizar
let R be DoubleLoopStr;
let a, b be Element of R.carrier;
assume algebra.additive.are_commute(a, b);  :: addition commutativity
assume algebra.multiplicative.are_commute(a, b);  :: multiplication commutativity
```

> [!NOTE]
> For attribute disambiguation using the `qua` operator, see [Chapter 7 (Attributes), §7.6](./07.attributes.md#76-disambiguation).

> [!NOTE]
> Predicate symbols must be unambiguous only when they are actually used. For **synonyms** and **antonyms** of predicates, see [Chapter 12 (Symbol Management), §12.1](./12.symbol_management.md#121-synonyms-and-antonyms).

## 10.9 Logic Encoding Details

This section describes how predicates map to First-Order Logic.

### 10.9.1 Predicates as FOL Predicates

Each user-defined predicate is encoded as an FOL predicate symbol.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x c= y` | `subset(x, y)` |
| `m divides n` | `divides(m, n)` |
| `a, b are_commute` | `are_commute(a, b)` |

### 10.9.2 Built-in Predicates

The built-in predicates have standard FOL encodings:

| Mizar Source | FOL Encoding | Description |
| --- | --- | --- |
| `x in X` | `x ∈ X` | Set membership |
| `x = y` | `x = y` | Equality (with standard axioms) |
| `x <> y` | `x ≠ y` (i.e., `¬(x = y)`) | Inequality |

These built-in predicates are primitive and do not have `means` definitions.

### 10.9.3 Predicate Definitions as Bi-conditionals

A predicate definition generates a universally quantified bi-conditional axiom:

```
pred X c= Y means for x st x in X holds x in Y
⇒  forall X, Y (subset(X, Y) ↔ forall x (x ∈ X → x ∈ Y))
```

More generally:

```
pred P(x1, ..., xn) means φ
⇒  forall x1, ..., xn (P(x1, ..., xn) ↔ φ)
```

### 10.9.4 Typed Parameters as Guards

Type constraints on parameters are encoded as antecedents:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x, y be Real; pred x < y means ...` | `forall x, y (is_Real(x) ∧ is_Real(y) → (less(x, y) ↔ ...))` |
| `let G be Group; let a be Element of G; pred ...` | `forall G, a (is_Group(G) ∧ is_Element(a, G) → ...)` |

### 10.9.5 Domain Restrictions (`assume`)

When a predicate uses `assume`, the condition becomes an additional antecedent:

```
let n, m be Integer;
assume m <> 0;
pred m divides n means ...

⇒  forall m, n (is_Integer(m) ∧ is_Integer(n) ∧ m ≠ 0 → (divides(m, n) ↔ ...))
```

### 10.9.6 Negation Encoding

Predicate negation is encoded as logical negation:

| Mizar Source | FOL Encoding |
| --- | --- |
| `x does not divide y` | `¬divides(x, y)` |
| `a, b do not are_commute` | `¬are_commute(a, b)` |

### 10.9.7 Redefinition Encoding

A redefinition generates an equivalence axiom under restricted types:

```
redefine pred a is_a_fixpoint_of f means a = f.a;
⇒  forall A, a, f (
     is_non_empty_set(A) ∧ is_Element(a, A) ∧ is_Function_of(f, A, A)
     → (fixpoint(a, f) ↔ a = f(a))
   )
```

## 10.10 Complete Syntax (EBNF)

Summary of predicate-related syntax.

```ebnf
(* Predicate Definition *)
pred_def         ::= "pred" label ":" pred_pattern "means" formula ";" ;
label            ::= identifier ;
pred_pattern     ::= [ loci ] predicate_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
predicate_symbol ::= identifier | symbolic_pred ;
symbolic_pred    ::= symbol_char+ ;

(* Predicate Redefinition *)
redefine_pred    ::= "redefine" "pred" pred_pattern "means" formula ";"
                     "coherence" [ "with" label ] proof_or_refs ";" ;
proof_or_refs    ::= proof_block | "by" references ";" ;

(* Predicate Application - see Chapter 15 *)
predicate_application ::= [ term_list ] [ negation ] predicate_symbol [ term_list ] ;
negation         ::= "does" "not" | "do" "not" ;
term_list        ::= term_expression { "," term_expression } ;

(* Built-in Predicates *)
builtin_pred     ::= "in" | "=" | "<>" ;
```
