# 5. Type System

This chapter provides an overview of Mizar's soft typing system. Detailed definitions for structures, attributes, and modes are given in Chapters 6–8.

* [5. Type System](#5-type-system)
  * [5.1 Overview](#51-overview)
  * [5.2 Core Concepts](#52-core-concepts)
  * [5.3 Type Expressions](#53-type-expressions)
  * [5.4 Built-in Types](#54-built-in-types)
  * [5.5 Subtyping and Widening](#55-subtyping-and-widening)
  * [5.6 Clusters (Overview)](#56-clusters-overview)
  * [5.7 Logic Encoding Details](#57-logic-encoding-details)
  * [5.8 Complete Syntax (EBNF)](#58-complete-syntax-ebnf)

## 5.1 Overview

Mizar Evolution adopts a **soft typing system** layered on untyped set theory. Types serve as syntactic guides and are not part of the logical foundation. All expressions ultimately denote sets, and type checking is implemented as generation of proof obligations in first-order logic.

> Freek Wiedijk. [Mizar's Soft Type System](https://cs.ru.nl/F.Wiedijk/mizar/miztype.pdf) TPHOLs 2007

**Design Principles**:

* **Mathematical alignment**: Types match mathematical practice.
* **Separation of concerns**: Types guide readability and verification but are erased for logical core.
* **Efficiency**: Syntax and inference mechanisms are optimized for fast checking.
* **Consistency**: All typing constructs follow unified syntax and semantics.

## 5.2 Core Concepts

| Concept | Description | Defined In |
| --- | --- | --- |
| **Radix-types** | Root types: built-ins (`object`, `set`) and user-defined (`mode`, `struct`) | §5.4, Ch.6, Ch.8 |
| **Attributes** | Predicates (possibly parameterized) that refine existing types | Ch.7 |
| **Modes** | Type constructors: attribute chains applied to radix-types | Ch.8 |
| **Structures** | Composite radix-types with named fields and properties | Ch.6 |
| **Clusters** | Registration mechanisms for type inference | §5.6, Ch.21 |

## 5.3 Type Expressions

A **type expression** specifies how a value is classified.

**Syntax (EBNF)**:

```ebnf
type_expression   ::= attribute_chain radix_type ;
attribute_chain   ::= { [ "non" ] attribute_name } ;
radix_type        ::= builtin_type
                    | mode_name [ type_args ]
                    | struct_name [ type_args ] ;
type_args         ::= ( "of" | "over" ) argument_list ;
argument_list     ::= term_expression { "," term_expression } ;
builtin_type      ::= "object" | "set" ;
```

**Examples**:

```mizar
set                           :: Built-in radix-type
non empty set                 :: Attribute + radix-type
positive Integer              :: Attribute + mode
Element of G                  :: Dependent mode
associative unital Magma      :: Multiple attributes + mode
Polynomial over R             :: Parameterized structure
```

## 5.4 Built-in Types

Mizar provides two built-in radix-types:

| Type | Description |
| --- | --- |
| `object` | Universal type. All values in the Mizar universe, including structures. |
| `set` | Subtype of `object`. Mathematical sets in the ZFC sense. |

**Type Hierarchy**:

```
object
├── set
│   └── (user-defined modes based on set)
└── (user-defined structures)
```

* Structures defined via `struct` are subtypes of `object` but **not** of `set`.
* This distinction allows separation of abstract algebraic structures from general sets.

## 5.5 Subtyping and Widening

**Subtyping** (`<:`) holds when one type's membership implies another's.

* **Widening**: Automatically convert a value to a supertype.
* **Narrowing**: Convert to a subtype (requires `reconsider` with proof obligation).

**Examples**:

```mizar
:: Widening (automatic)
let n be Nat;
:: n can be used where Integer is expected

:: Narrowing (explicit)
let x be Integer such that x >= 0;
reconsider x as Nat by XREAL_1:1;  :: Proof required
```

**Subtype Relations**:

```mizar
Prime <: Integer <: Number
non empty set <: set <: object
```

## 5.6 Clusters (Overview)

Clusters are registration mechanisms that enable automatic type inference and propagation.

| Cluster Type | Purpose | Example |
| --- | --- | --- |
| **Existential** | Prove existence of typed values | `cluster empty finite set;` |
| **Conditional** | Declare attribute implications | `cluster empty -> finite set;` |
| **Functor** | Assign types to functor results | `cluster f(x) -> positive for Real;` |

Detailed syntax and examples are provided in **Chapter 21 (Clusters)**.

## 5.7 Logic Encoding Details

This section describes how types map to First-Order Logic.

### 5.7.1 Types as Predicates

Each type `T` is encoded as a unary predicate `is_T(x)`.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is Real` | `is_Real(x)` |
| `x is positive Real` | `is_Real(x) ∧ is_positive(x)` |
| `x is Element of G` | `is_Element_of(x, G)` |

### 5.7.2 Subtyping as Implication

Subtype relationships are encoded as implications:

```
S <: T  ⇔  ∀x. is_S(x) ⇒ is_T(x)
```

**Example**:

```
Prime <: Integer
⇔  ∀x. is_Prime(x) ⇒ is_Integer(x)
```

### 5.7.3 Type Erasure for ATPs

When exporting to ATPs (TPTP format), types are erased:

1. Variable declarations become untyped: `let x be Real` → `x`
2. Type assumptions become hypotheses: `is_Real(x) ⇒ ...`
3. Attribute chains become conjunctions

## 5.8 Complete Syntax (EBNF)

Summary of type-related syntax from this chapter.

```ebnf
(* Type Expressions *)
type_expression   ::= attribute_chain radix_type ;
attribute_chain   ::= { [ "non" ] attribute_name } ;

radix_type        ::= builtin_type
                    | mode_name [ type_args ]
                    | struct_name [ type_args ] ;

type_args         ::= ( "of" | "over" ) argument_list ;
argument_list     ::= term_expression { "," term_expression } ;

builtin_type      ::= "object" | "set" ;

attribute_name    ::= identifier ;  (* See Chapter 7 for attribute definitions *)

(* Mode syntax: see Chapter 8 *)
(* Attribute syntax: see Chapter 7 *)
(* Structure syntax: see Chapter 6 *)
```
