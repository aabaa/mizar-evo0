# 3. Modules and Namespaces

## 3.1 Module Structure and Namespace Rules

In the redesigned Mizar system, modules play a role in organizing and structuring mathematical knowledge. A module represents a cohesive unit of mathematical content, typically focusing on a specific concept, theory, or related group of definitions and theorems.

### Definition and Purpose

A module is a self-contained unit of formalized mathematics that:
    - Encapsulates related mathematical concepts, definitions, and theorems
    - Provides a mechanism for organizing and structuring large mathematical formalizations
    - Facilitates code reuse and maintenance
    - Enables collaborative development of mathematical libraries

### Correspondence with Directories and Files

There is a direct one-to-one correspondence between modules and `.miz` files:
    1. Each `.miz` file represents exactly one module.
    2. The module name typically matches the file name (without the .miz extension).
    3. The file's location in the directory structure determines its namespace.
    4. For example, a file located at `/mml/algebra/group.miz` defines the `group` module in the `mml.algebra` namespace.

### Namespace Derivation and Hierarchy

1. **Root Namespace**: The root directory of the Mizar library corresponds to the global namespace.
2. **Subdirectories**: Each subdirectory adds a level to the namespace hierarchy.
3. **Dot Notation**: Namespaces use dot notation to represent hierarchy levels (e.g., `mml.algebra.group`).

### Repository Structure and Namespaces

The Mizar system is organized into three main repositories, each with its own namespace:

1. **Mizar Mathematical Library (MML)**: `/mml`
   - This is the main repository for formalized mathematics.
   - Namespaces in MML follow the directory structure, e.g., `/mml/algebra/group/group.miz` corresponds to the `mml.algebra.group` namespace and the `group` module.

2. **Formalized Mathematics (FM)**: `/fm`
   - This repository is used for publishing articles in the journal "Formalized Mathematics".
   - Articles are organized by year, e.g., `/fm/y2024/ndiff12.miz` corresponds to the `fm.y2024` namespace and the `ndiff12` module.

3. **User Repository**: `/user`
   - This space is allocated for individual users to develop and store their own formalizations.
   - User namespaces are prefixed with their GitHub username, e.g., `/user/@aabaa/myproject/abc.miz` corresponds to the `user.@aabaa.myproject` namespace and the `abc` module.

### Naming Conventions

1. **Valid Characters**: Module and namespace names should consist of lowercase letters, numbers, and underscores.
2. **Descriptive Names**: Use clear, descriptive names that reflect the mathematical concepts contained within.
3. **Avoiding Conflicts**: Ensure that module and namespace names do not conflict with reserved keywords or built-in Mizar constructs.

## 3.2 Import Statements

Import statements in Mizar allow modules to use definitions, theorems, and other elements from other modules.

### Basic Import Syntax

The basic syntax for importing in Mizar is as follows:

```mizar
from <module_path> import <element>;
```

Where `<module_path>` is the dot-separated path to the module, and `<element>` is the specific item you want to import.

Example:
```mizar
:: Here we assume `mode Group` is defined in `/mml/algebra/group.miz`
from mml.algebra.group import Group;
```

You can import multiple elements from a module in a single statement:

```mizar
from <module_path> import <element1>, <element2>, <element3>;
```

Example:
```mizar
:: Assume `mode Group`, `attr commutative` and `attr order`
:: are defined in `/mml/algebra/group.miz`
from mml.algebra.group import Group, commutative, order;
```

### Importing Modules with Entire Paths

To import a module with entire paths, you can use the following syntax:

```mizar
:: Assume `mode Group` is defined in `/mml/algebra/group.miz`
import <module_path>;
```

Example:
```mizar
import mml.algebra.group;
```

This allows you to use all public elements from the module by prefixing them with the module name:

```mizar
let G be mml.algebra.group.Group;
```

### Importing Modules with Aliases

To avoid long namespaces or potential naming conflicts, you can use aliases:

```mizar
import <module_path> as <alias>;
```

Example:
```mizar
import mml.algebra.group as grp;
```

Now you can use the alias instead of the full module path:

```mizar
let G be grp.Group;
```

### Importing Modules with Relative Paths

For imports within the same repository, you can use relative paths:

```mizar
from ..<module_name> import <element>;
```

Example:
```mizar
:: Assume the following code is in `/mml/algebra/ring.miz`
:: and `Group` is declared in `/mml/algebra/group.miz`
from ..group import Group;
```

### Importing from Multiple Levels

You can import from multiple levels of the module hierarchy in a single statement:

```mizar
from mml.algebra import group.Group, ring.Ring;
```

This imports `group.Group` and `ring.Ring` from `mml.algebra`.

```mizar
let G be group.Group;
let R be ring.Ring;
```

### Wildcard Imports

While generally discouraged due to potential namespace pollution, you can import all public elements from a module using a wildcard:

```mizar
from <module_path> import *;
```

Example:
```mizar
from mml.algebra.group import *;
```

### Importing from Multiple Paths

Mizar allows you to import from multiple paths in a single import statement using curly braces `{}`.

```mizar
from <module_path>.{<submodule1>,<submodule2>,...} import *;
```

or

```mizar
from <module_path>.{<submodule1>,<submodule2>,...} import <element1>, <element2>, ...;
```

Example:
```mizar
from mml.algebra.{group,ring} import *;
```

This imports all public elements from both `mml.algebra.group` and `mml.algebra.ring`.

You can also selectively import specific elements from multiple paths:

```mizar
from mml.algebra.{group,ring} import Group, Ring;
```

This imports `Group` from `mml.algebra.group` and `Ring` from `mml.algebra.ring`.

Usage:
```mizar
let G be Group;
let R be Ring;
```

### Best Practices

1. Prefer specific imports over importing entire modules or using wildcards.
2. Use aliases for long module paths to improve readability.
3. Group related imports together.
4. Avoid circular dependencies between modules.
5. Use multiple path specification when importing related elements from different submodules of the same parent module.

## 3.3 Export Statements

## 3.4 Privacy and Visibility

## 3.5 Best Practices and Common Pitfalls
