# 14. Formulas

- [14. Formulas](#14-formulas)
  - [14.1 Overview](#141-overview)
  - [14.2 Atomic Formulas](#142-atomic-formulas)
  - [14.3 Logical Connectives](#143-logical-connectives)
  - [14.4 Quantified Formulas](#144-quantified-formulas)
  - [14.5 Special Formula Forms](#145-special-formula-forms)
  - [14.6 Precedence and Associativity](#146-precedence-and-associativity)
  - [14.7 Logic Encoding Details](#147-logic-encoding-details)
  - [14.8 Complete Syntax (EBNF)](#148-complete-syntax-ebnf)

## 14.1 Overview

A formula is a syntactic representation of a logical proposition. Unlike term expressions ([Chapter 13](./13.term_expression.md)), which denote mathematical objects, formulas denote boolean-valued statements used within theorems, proofs, and control structures.

Formulas are constructed from three layers:

1. **Atomic formulas** — predicate applications, type assertions, attribute assertions
2. **Compound formulas** — combinations via logical connectives (`&`, `or`, `implies`, `iff`, `not`)
3. **Quantified formulas** — universal (`for ... holds`) and existential (`ex ... st`)

**Syntax (EBNF)**:

```ebnf
formula ::= atomic_formula
          | compound_formula
          | quantified_formula
          | "(" formula ")"
          | "not" formula
          | "contradiction"
          | "thesis" ;
```

## 14.2 Atomic Formulas

Atomic formulas are the simplest formulas, formed by predicate applications and type/attribute assertions.

**Syntax (EBNF)**:

```ebnf
atomic_formula ::= predicate_application
                 | inline_predicate_application
                 | type_assertion
                 | attribute_assertion ;

predicate_application        ::= [ term_expr_list ] [ negation ] predicate_symbol [ term_expr_list ] ;
inline_predicate_application ::= inline_pred_name "(" [ term_expr_list ] ")" ;
type_assertion               ::= term_expression "is" type_expression ;
attribute_assertion          ::= term_expression "is" [ "not" ] adjective_chain ;

adjective_chain  ::= adjective { adjective } ;
adjective        ::= [ "non" ] attribute_name ;
negation         ::= "does" "not" | "do" "not" ;
term_expr_list   ::= term_expression { "," term_expression } ;
```

### 14.2.1 Predicate Applications

A predicate may be applied to one or more arguments using symbolic or phrase notation as defined in [Chapter 9 (Predicates)](./09.predicates.md). The `does not` / `do not` modifier negates the predicate at the syntactic level.

**Example**:

```mizar
:: Symbolic predicates
x in X;
x = y;
x c= Y;

:: Phrase predicates
a divides b;
a, b are_commute;

:: Negated predicate applications
x does not divide y;
x, y do not are_commute;
```

> [!NOTE]
> For predicate definition syntax (`pred`), see [Chapter 9 (Predicates)](./09.predicates.md).
> For inline predicate definitions within proofs (`defpred`), see [Chapter 15 (Statements), §15.2.4](./15.statements.md#1524-inline-predicate-definition-defpred).

### 14.2.2 Inline Predicate Applications

Inline predicates (defined with `defpred` in proof blocks) always require parentheses.

**Example**:

```mizar
proof
  defpred IsSmall(n be Nat) means n < 10;

  A1: IsSmall(3);       :: true
  A2: not IsSmall(100); :: true
  ...;
end;
```

### 14.2.3 Type Assertions

Type assertions check whether a term belongs to a given type. They use the `is` keyword.

**Example**:

```mizar
x is Nat;
x is Element of A;
f is Function of A, B;
```

### 14.2.4 Attribute Assertions

Attribute assertions check whether a term has one or more attributes. Multiple adjectives form an attribute chain interpreted **conjunctively**. The `non` modifier negates individual attributes; `not` negates the entire assertion.

**Example**:

```mizar
:: Single attribute
n is even;

:: Multiple attributes (conjunctive)
y is positive even Integer;
:: equivalent to: y is positive & y is even & y is Integer

:: Negated attributes
G is non empty;         :: attribute-level negation: G has the property "non empty"
x is not finite;        :: formula-level negation: equivalent to not (x is finite)
```

> [!IMPORTANT]
> `non` and `not` have different semantics:
> - `x is non empty` — `non empty` is a single adjective (the negation of the attribute `empty`)
> - `x is not finite` — the formula `x is finite` is negated (equivalent to `not (x is finite)`)

## 14.3 Logical Connectives

Logical connectives combine simpler formulas into compound formulas.

**Syntax (EBNF)**:

```ebnf
compound_formula ::= formula "&" formula
                   | formula "&" "..." "&" formula
                   | formula "or" formula
                   | formula "or" "..." "or" formula
                   | formula "implies" formula
                   | formula "iff" formula ;
```

### 14.3.1 Conjunction (`&`)

Binary conjunction represents logical "and". Left-associative.

**Example**:

```mizar
x is Nat & x > 0;
x > 0 & y > 0 & z > 0;   :: parsed as ((x > 0) & (y > 0)) & (z > 0)
```

**Repetition form** (`& ... &`): A shorthand for a series of similar conjuncts that vary over a range of integer constants.

```mizar
assume m <> 0 & ... & m <> 3;
:: expanded to: m <> 0 & m <> 1 & m <> 2 & m <> 3
```

> [!NOTE]
> The repetition forms (`& ... &`, `or ... or`) rely on the system recognizing a pattern between the left and right formulas. The varying parameter must differ by an integer offset.

### 14.3.2 Disjunction (`or`)

Binary disjunction represents logical "or". Left-associative.

**Example**:

```mizar
x = 0 or x = 1;
x = 0 or y = 0 or z = 0;  :: parsed as ((x = 0) or (y = 0)) or (z = 0)
```

**Repetition form**:

```mizar
x mod 2 = 0 or ... or x mod 7 = 0;
```

### 14.3.3 Implication (`implies`)

Represents logical implication (if-then). Right-associative by convention.

**Example**:

```mizar
x > 0 implies x^2 > 0;
x > 0 implies y > 0 implies x + y > 0;
:: parsed as x > 0 implies (y > 0 implies x + y > 0)
```

### 14.3.4 Bi-implication (`iff`)

Represents logical equivalence (if and only if). Non-associative (parentheses required for chaining).

**Example**:

```mizar
x in A iff x is Element of A;
(P iff Q) iff (P implies Q) & (Q implies P);
```

### 14.3.5 Negation (`not`)

Unary prefix operator. Binds more tightly than any binary connective.

**Example**:

```mizar
not x in A;
not (x > 0 or y < 0);
not x > 0 & y > 0;      :: parsed as (not x > 0) & y > 0
```

> [!NOTE]
> The syntactic form `x is not finite` is also allowed as shorthand for `not (x is finite)`. See §14.2.4.

### 14.3.6 Special Constants

| Constant | Semantics | FOL Encoding | Usage |
| --- | --- | --- | --- |
| `thesis` | Current proof goal | (context-dependent) | `thus thesis;` in proofs |
| `contradiction` | Always false | `⊥` | Proofs by contradiction |

**Example**:

```mizar
:: Proof by contradiction
assume not thesis;
...;
thus contradiction;

:: Goal reference
A1: P & Q;
thus thesis by A1;
```

## 14.4 Quantified Formulas

Quantified formulas express logical universality (`for`) and existence (`ex`).

**Syntax (EBNF)**:

```ebnf
quantified_formula  ::= universal_formula | existential_formula ;
universal_formula   ::= "for" qualified_vars [ "st" formula ] ( "holds" formula | quantified_formula ) ;
existential_formula ::= "ex" qualified_vars "st" formula ;

qualified_vars    ::= explicit_vars [ "," implicit_vars ] | implicit_vars ;
explicit_vars     ::= qualified_segment { "," qualified_segment } ;
qualified_segment ::= var_list ( "being" | "be" ) type_expression ;
implicit_vars     ::= var_list ;
var_list          ::= identifier { "," identifier } ;
```

### 14.4.1 Universal Quantification (`for`)

The `for ... holds` construct expresses that a formula holds for all values of the quantified variables.

**Example**:

```mizar
:: Simple universal
for x being Nat holds x + 1 > x;

:: With condition (restricted quantification)
for x being Real st x > 0 holds x^2 > 0;

:: Multiple variables
for x, y being Real holds x + y = y + x;

:: Mixed typed and reserved variables
for a being Nat, b holds a + b = b + a;  :: b typed by reserve
```

### 14.4.2 Nested Quantification

Multiple `for` quantifiers can be nested without repeating `holds`. The innermost `holds` applies to the entire chain.

**Example**:

```mizar
:: Nested quantification
for x being Real st x > 0
  for y being Real st y > x
    holds x + y > 0;

:: Equivalent expanded form
for x being Real st x > 0 holds
  for y being Real st y > x holds x + y > 0;
```

### 14.4.3 Existential Quantification (`ex`)

The `ex ... st` construct asserts the existence of a value satisfying a condition.

**Example**:

```mizar
:: Simple existence
ex n being Nat st n > 100;

:: Multiple variables
ex x, y being Real st x^2 + y^2 = 1;

:: Nested quantifiers with existence
for x being Real st x > 0
  ex y being Real st y^2 = x;
```

### 14.4.4 Qualified Variable Syntax

Variables in quantified formulas may be explicitly typed or implicitly typed. Implicit variables rely on prior `reserve` declarations.

| Form | Meaning | Example |
| --- | --- | --- |
| `x being T` | Explicit type | `for x being Nat holds ...` |
| `x be T` | Explicit type (shorthand) | `for x be Nat holds ...` |
| `x` (unqualified) | Implicit type from `reserve` | `for n holds ...` |

```mizar
:: reserve declares implicit types
reserve n for Nat;
reserve x, y for Real;

:: Implicit typing: n is Nat, x is Real
for n holds n + 1 > n;
for x, y holds x + y = y + x;
```

## 14.5 Special Formula Forms

### 14.5.1 Qualified Attribute Tests

When attributes are defined in the context of a structure hierarchy, an attribute might need qualification to resolve ambiguity.

**Example**:

```mizar
:: Qualified attribute: specify the structure context
G is Group.associative;

:: Using qua to specify the type context
(G qua Magma) is associative;
```

> [!NOTE]
> For the `qua` operator, see [Chapter 13 (Term Expressions), §13.5](./13.term_expression.md#135-type-qualification-qua).

### 14.5.2 Equality and Inequality

The built-in equality (`=`) and inequality (`<>`) predicates are atomic formulas with special status.

```mizar
x = y;                 :: equality
x <> y;                :: inequality (syntactic sugar for not x = y)
```

### 14.5.3 Set Membership

The built-in membership predicate `in` is an atomic formula.

```mizar
x in X;
x in dom f;
[a, b] in [:A, B:];
```

### 14.5.4 Composite Formulas in Practice

Complete examples combining multiple formula constructs:

```mizar
:: Theorem statement: injectivity of a function
for f being Function st f is one-to-one holds
  for x, y being object st x in dom f & y in dom f
    holds f.x = f.y implies x = y;

:: Axiom of extensionality
for X, Y being set holds
  X = Y iff for z being object holds z in X iff z in Y;

:: Existence with nested structure
ex G being strict Group st
  the carrier of G = NAT &
  ex e being Element of G st
    for a being Element of G holds G.binop(e, a) = a;
```

## 14.6 Precedence and Associativity

Formula operators have a fixed precedence hierarchy. Quantifiers have the lowest binding power.

| Priority | Operator | Associativity | Example |
| --- | --- | --- | --- |
| 1 (highest) | Atomic formulas | — | `x is Nat`, `a divides b` |
| 2 | `not` | Unary (prefix) | `not x > 0` |
| 3 | `&` | Left | `a & b & c` → `(a & b) & c` |
| 4 | `or` | Left | `a or b or c` → `(a or b) or c` |
| 5 | `implies` | Right | `a implies b implies c` → `a implies (b implies c)` |
| 6 | `iff` | Non-associative | `a iff b` (chaining is an error) |
| 7 (lowest) | `for`, `ex` | — | Bind to the outermost scope |

**Parsing examples**:

```mizar
:: Precedence demonstration
not x > 0 & y > 0;
:: parsed as: (not (x > 0)) & (y > 0)

a or b implies c;
:: parsed as: (a or b) implies c

a & b or c;
:: parsed as: (a & b) or c

for x being Nat holds x > 0 implies x >= 1;
:: parsed as: for x being Nat holds (x > 0 implies x >= 1)

:: Use parentheses for clarity
(x implies y) implies z;
(a or b) & (c or d);
```

> [!TIP]
> Use parentheses whenever precedence is not obvious to the reader.

## 14.7 Logic Encoding Details

This section describes how formula constructs map to First-Order Logic (FOL).

### 14.7.1 Atomic Formulas

| Mizar Source | FOL Encoding |
| --- | --- |
| `x in X` | `x ∈ X` |
| `x = y` | `x = y` |
| `x <> y` | `¬(x = y)` |
| `x divides y` | `divides(x, y)` |
| `x does not divide y` | `¬divides(x, y)` |
| `IsSmall(n)` (inline) | `IsSmall(n)` (expanded by substitution) |

### 14.7.2 Type and Attribute Assertions

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is Nat` | `is_Nat(x)` |
| `x is Element of A` | `is_Element_of(x, A)` |
| `x is positive even Integer` | `is_positive(x) ∧ is_even(x) ∧ is_Integer(x)` |
| `G is non empty` | `¬is_empty(G)` |
| `x is not finite` | `¬is_finite(x)` |

> [!NOTE]
> `non` in adjective chains produces negation of the attribute predicate (`¬is_empty`), while `not` in `x is not finite` produces formula-level negation of the entire assertion (`¬is_finite(x)`). Both result in logical negation, but `non` targets a single adjective within a chain, whereas `not` negates the whole `attribute_assertion`.

### 14.7.3 Logical Connectives

| Mizar Source | FOL Encoding |
| --- | --- |
| `P & Q` | `P ∧ Q` |
| `P or Q` | `P ∨ Q` |
| `P implies Q` | `P → Q` |
| `P iff Q` | `P ↔ Q` |
| `not P` | `¬P` |
| `contradiction` | `⊥` |

### 14.7.4 Repetition Forms

The `& ... &` and `or ... or` forms expand to finite conjunctions/disjunctions:

```
m <> 0 & ... & m <> 3
⟹  m ≠ 0 ∧ m ≠ 1 ∧ m ≠ 2 ∧ m ≠ 3

x mod 2 = 0 or ... or x mod 5 = 0
⟹  x mod 2 = 0 ∨ x mod 3 = 0 ∨ x mod 4 = 0 ∨ x mod 5 = 0
```

### 14.7.5 Quantified Formulas

| Mizar Source | FOL Encoding |
| --- | --- |
| `for x being T holds P(x)` | `∀x. (is_T(x) → P(x))` |
| `for x being T st Q(x) holds P(x)` | `∀x. (is_T(x) ∧ Q(x) → P(x))` |
| `ex x being T st P(x)` | `∃x. (is_T(x) ∧ P(x))` |
| `for x being T, y holds P(x, y)` | `∀x, y. (is_T(x) → P(x, y))` (y's type from reserve) |

**Nested quantification encoding**:

```
for x being Real st x > 0
  for y being Real st y > x
    holds x + y > 0

⟹  ∀x. (is_Real(x) ∧ x > 0 →
      ∀y. (is_Real(y) ∧ y > x → x + y > 0))
```

### 14.7.6 Special Constants

| Mizar Source | FOL Encoding | Notes |
| --- | --- | --- |
| `thesis` | (current goal formula) | Resolved by proof assistant |
| `contradiction` | `⊥` | Falsum constant |

### 14.7.7 Composite Encoding Example

A complete theorem encoding:

```mizar
for X, Y being set holds
  X c= Y iff for z being object holds z in X implies z in Y;
```

Encodes to:

```
∀X, Y. (is_set(X) ∧ is_set(Y) →
  (subset(X, Y) ↔ ∀z. (is_object(z) → (z ∈ X → z ∈ Y))))
```

## 14.8 Complete Syntax (EBNF)

Summary of all formula syntax.

```ebnf
(* Formulas *)
formula              ::= atomic_formula
                       | compound_formula
                       | quantified_formula
                       | "(" formula ")"
                       | "not" formula
                       | "contradiction"
                       | "thesis" ;

(* Atomic Formulas *)
atomic_formula       ::= predicate_application
                       | inline_predicate_application
                       | type_assertion
                       | attribute_assertion ;

predicate_application        ::= [ term_expr_list ] [ negation ] predicate_symbol [ term_expr_list ] ;
inline_predicate_application ::= inline_pred_name "(" [ term_expr_list ] ")" ;
type_assertion               ::= term_expression "is" type_expression ;
attribute_assertion          ::= term_expression "is" [ "not" ] adjective_chain ;

adjective_chain              ::= adjective { adjective } ;
adjective                    ::= [ "non" ] attribute_name ;
negation                     ::= "does" "not" | "do" "not" ;
term_expr_list               ::= term_expression { "," term_expression } ;
(* For predicate definitions, see Chapter 9 (Predicates) *)
(* For defpred, see Chapter 15 (Statements) *)

(* Compound Formulas *)
compound_formula     ::= formula "&" formula
                       | formula "&" "..." "&" formula
                       | formula "or" formula
                       | formula "or" "..." "or" formula
                       | formula "implies" formula
                       | formula "iff" formula ;

(* Quantified Formulas *)
quantified_formula   ::= universal_formula | existential_formula ;
universal_formula    ::= "for" qualified_vars [ "st" formula ]
                         ( "holds" formula | quantified_formula ) ;
existential_formula  ::= "ex" qualified_vars "st" formula ;

(* Qualified Variables *)
qualified_vars       ::= explicit_vars [ "," implicit_vars ] | implicit_vars ;
explicit_vars        ::= qualified_segment { "," qualified_segment } ;
qualified_segment    ::= var_list ( "being" | "be" ) type_expression ;
implicit_vars        ::= var_list ;
var_list             ::= identifier { "," identifier } ;
```
