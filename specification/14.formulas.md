# 14. Formulas

- [14. Formulas](#14-formulas)
  - [14.1 Overview](#141-overview)
  - [14.2 Atomic Formulas](#142-atomic-formulas)
  - [14.3 Logical Connectives](#143-logical-connectives)
  - [14.4 Quantified Formulas](#144-quantified-formulas)
  - [14.5 Special Formula Forms](#145-special-formula-forms)
  - [14.6 Precedence and Associativity](#146-precedence-and-associativity)
  - [14.7 Logic Encoding Details](#147-logic-encoding-details)
  - [14.8 Complete Syntax (EBNF)](#148-complete-syntax-ebnf)

## 14.1 Overview

A formula is a syntactic representation of a logical proposition. Unlike term expressions (Chapter 13), which denote mathematical objects, formulas denote boolean-valued statements used within theorems, proofs, and control structures.

**Syntax (EBNF)**:

```ebnf
formula ::= atomic_formula
          | compound_formula
          | quantified_formula
          | "(" formula ")"
          | "not" formula
          | "contradiction"
          | "thesis" ;
```

## 14.2 Atomic Formulas

Atomic formulas are the simplest formulas, formed by predicate applications and type assertions.

**Syntax (EBNF)**:

```ebnf
atomic_formula ::= predicate_application
                 | inline_predicate_application
                 | type_assertion
                 | attribute_assertion ;

predicate_application        ::= [ term_expr_list ] [ negation ] predicate_symbol [ term_expr_list ] ;
inline_predicate_application ::= inline_pred_name "(" [ term_expr_list ] ")" ;
type_assertion               ::= term_expression "is" type_expression ;
attribute_assertion          ::= term_expression "is" adjective_chain ;

negation       ::= "does" "not" | "do" "not" ;
term_expr_list ::= term_expression { "," term_expression } ;
```

### 14.2.1 Predicate Applications

A predicate may be applied to one or more arguments. The `does not` / `do not` modifier negates the predicate.

**Example**:

```mizar
x divides y;
x does not divide y;
x, y do not are_commute;
```

### 14.2.2 Type and Attribute Assertions

Type assertions use the `is` keyword. Multiple adjectives form an attribute chain interpreted conjunctively.

**Example**:

```mizar
x is Nat;
y is positive even Integer;
x is not finite;                :: equivalent to not (x is finite)
```

## 14.3 Logical Connectives

Logical connectives combine simpler formulas into compound formulas.

**Syntax (EBNF)**:

```ebnf
compound_formula ::= formula "&" formula
                   | formula "&" "..." "&" formula
                   | formula "or" formula
                   | formula "or" "..." "or" formula
                   | formula "implies" formula
                   | formula "iff" formula ;
```

### 14.3.1 Conjunction (`&`)

```mizar
x is Nat & x > 0;
```

The `& ... &` form is a repetition syntax for a series of similar conjuncts over a range:

```mizar
assume m <> 0 & ... & m <> 3;
:: equivalent to: m <> 0 & m <> 1 & m <> 2 & m <> 3
```

### 14.3.2 Disjunction (`or`)

```mizar
x = 0 or x = 1;
x mod 2 = 0 or ... or x mod 7 = 0;
```

### 14.3.3 Implication (`implies`)

```mizar
x > 0 implies x^2 > 0;
```

### 14.3.4 Bi-implication (`iff`)

```mizar
x in A iff x is Element of A;
```

### 14.3.5 Negation (`not`)

Unary operator. Binds more tightly than any binary connective.

```mizar
not x in A;
not (x > 0 or y < 0);
```

> [!NOTE]
> The syntactic form `x is not finite` is allowed as shorthand for `not (x is finite)`.

### 14.3.6 Special Constants

- **`thesis`**: Denotes the current goal in a proof block (tautological in context)
- **`contradiction`**: Always false; used in proofs by contradiction

## 14.4 Quantified Formulas

**Syntax (EBNF)**:

```ebnf
quantified_formula ::= universal_formula | existential_formula ;
universal_formula  ::= "for" qualified_vars [ "st" formula ] ( "holds" formula | quantified_formula ) ;
existential_formula ::= "ex" qualified_vars "st" formula ;

qualified_vars    ::= explicit_vars [ "," implicit_vars ] | implicit_vars ;
explicit_vars     ::= qualified_segment { "," qualified_segment } ;
qualified_segment ::= var_list ( "being" | "be" ) type_expression ;
implicit_vars     ::= var_list ;
var_list          ::= identifier { "," identifier } ;
```

### 14.4.1 Universal Quantification (`for`)

```mizar
for x being Nat holds x + 1 > x;
```

An optional `st` condition restricts the range:

```mizar
for x being Real st x > 0 holds x^2 > 0;
```

Nesting is allowed:

```mizar
for x being Real st x > 0
  for y being Real st y > x
    holds x + y > 0;
```

### 14.4.2 Existential Quantification (`ex`)

```mizar
ex n being Nat st n > 100;
```

### 14.4.3 Qualified Variable Syntax

Variable types may be omitted if declared via `reserve`:

```mizar
for x, y being Real holds ...;
for a being Nat, b holds ...;  :: b is typed by reserve
```

## 14.5 Special Formula Forms

### 14.5.1 Qualified Attribute Tests

```mizar
G is Group.associative;
(G qua Magma) is associative;
```

### 14.5.2 Negated Type Assertions

```mizar
x is not finite;   :: equivalent to not (x is finite)
```

## 14.6 Precedence and Associativity

| Operator | Precedence | Associativity | Example |
| --- | --- | --- | --- |
| `not` | Highest | Unary (prefix) | `not x > 0` |
| `&` | High | Left | `a & b & c` → `(a & b) & c` |
| `or` | Medium | Left | `a or b or c` → `(a or b) or c` |
| `implies` | Low | Left | `a implies b implies c` → `(a implies b) implies c` |
| `iff` | Lowest | Left | `a iff b` |

**Examples**:

```mizar
not x > 0 & y > 0;          :: parsed as (not x > 0) & y > 0
a or b implies c;            :: parsed as (a or b) implies c
(x implies y) implies z;     :: parenthesized for clarity
```

> [!TIP]
> Use parentheses for clarity whenever precedence is not obvious.

## 14.7 Logic Encoding Details

### 14.7.1 Atomic Formulas

| Mizar Source | FOL Encoding |
| --- | --- |
| `x divides y` | `divides(x, y)` |
| `x does not divide y` | `¬divides(x, y)` |
| `x is Nat` | `is_Nat(x)` |
| `x is positive even Integer` | `is_positive(x) ∧ is_even(x) ∧ is_Integer(x)` |

### 14.7.2 Logical Connectives

| Mizar Source | FOL Encoding |
| --- | --- |
| `P & Q` | `P ∧ Q` |
| `P or Q` | `P ∨ Q` |
| `P implies Q` | `P → Q` |
| `P iff Q` | `P ↔ Q` |
| `not P` | `¬P` |
| `contradiction` | `⊥` |

### 14.7.3 Quantified Formulas

| Mizar Source | FOL Encoding |
| --- | --- |
| `for x being T holds P(x)` | `∀x. (is_T(x) → P(x))` |
| `for x being T st Q(x) holds P(x)` | `∀x. (is_T(x) ∧ Q(x) → P(x))` |
| `ex x being T st P(x)` | `∃x. (is_T(x) ∧ P(x))` |

## 14.8 Complete Syntax (EBNF)

Summary of all formula syntax.

```ebnf
(* Formulas *)
formula              ::= atomic_formula
                       | compound_formula
                       | quantified_formula
                       | "(" formula ")"
                       | "not" formula
                       | "contradiction"
                       | "thesis" ;

(* Atomic Formulas *)
atomic_formula       ::= predicate_application
                       | inline_predicate_application
                       | type_assertion
                       | attribute_assertion ;

predicate_application        ::= [ term_expr_list ] [ negation ] predicate_symbol [ term_expr_list ] ;
inline_predicate_application ::= inline_pred_name "(" [ term_expr_list ] ")" ;
type_assertion               ::= term_expression "is" type_expression ;
attribute_assertion          ::= term_expression "is" adjective_chain ;
negation                     ::= "does" "not" | "do" "not" ;
term_expr_list               ::= term_expression { "," term_expression } ;

(* Compound Formulas *)
compound_formula     ::= formula "&" formula
                       | formula "&" "..." "&" formula
                       | formula "or" formula
                       | formula "or" "..." "or" formula
                       | formula "implies" formula
                       | formula "iff" formula ;

(* Quantified Formulas *)
quantified_formula   ::= universal_formula | existential_formula ;
universal_formula    ::= "for" qualified_vars [ "st" formula ]
                         ( "holds" formula | quantified_formula ) ;
existential_formula  ::= "ex" qualified_vars "st" formula ;

(* Qualified Variables *)
qualified_vars       ::= explicit_vars [ "," implicit_vars ] | implicit_vars ;
explicit_vars        ::= qualified_segment { "," qualified_segment } ;
qualified_segment    ::= var_list ( "being" | "be" ) type_expression ;
implicit_vars        ::= var_list ;
var_list             ::= identifier { "," identifier } ;
```
