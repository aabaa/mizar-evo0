# 16. Theorems and Proofs

- [16. Theorems and Proofs](#16-theorems-and-proofs)
  - [16.1 Theorem Classes](#161-theorem-classes)
  - [16.2 Syntax of Theorem Declarations](#162-syntax-of-theorem-declarations)
  - [16.3 Proof Skeleton and Natural Deduction](#163-proof-skeleton-and-natural-deduction)
    - [16.3.1 Skeleton Extraction](#1631-skeleton-extraction)
    - [16.3.2 The `thesis` Keyword](#1632-the-thesis-keyword)
    - [16.3.3 Skeleton Decomposition Rules](#1633-skeleton-decomposition-rules)
  - [16.4 Proof Structure and Scope](#164-proof-structure-and-scope)
    - [16.4.1 Proof Blocks](#1641-proof-blocks)
    - [16.4.2 Scope and Visibility](#1642-scope-and-visibility)
    - [16.4.3 Diffuse Reasoning (Nested Proofs)](#1643-diffuse-reasoning-nested-proofs)
  - [16.5 Type System Proof Obligations](#165-type-system-proof-obligations)
    - [16.5.1 Existence and Uniqueness](#1651-existence-and-uniqueness)
    - [16.5.2 Coherence and Compatibility](#1652-coherence-and-compatibility)
    - [16.5.3 Cluster Registration Obligations](#1653-cluster-registration-obligations)
    - [16.5.4 Consistency](#1654-consistency)
  - [16.6 Logic Encoding Details](#166-logic-encoding-details)
    - [16.6.1 Theorem Declarations](#1661-theorem-declarations)
    - [16.6.2 Proof Obligations](#1662-proof-obligations)
    - [16.6.3 Skeleton Encoding](#1663-skeleton-encoding)
  - [16.7 Complete Syntax (EBNF)](#167-complete-syntax-ebnf)
  - [16.8 Implementation Notes](#168-implementation-notes)

## 16.1 Theorem Classes

Mizar Evolution distinguishes declarative logical units based on their verification status and parameterization.

**Syntax (EBNF):**

```ebnf
theorem_item  ::= ( "theorem" | "conjecture" ) label_identifier ":" formula [ justification ] ";" ;
justification ::= simple_justification | proof ;
```

**Theorem classes:**

| Class | Justification | Can Reference Conjectures | Semantics |
|---|---|---|---|
| `theorem` | Optional (verifier auto-proves if omitted) | No (verifier error) | Fully verified proposition |
| `conjecture` | Optional | Yes | Assertion that may depend on unverified assumptions |

**Example:**

```mizar
:: Theorem with proof
theorem Th1:
  for n being Nat holds n + 0 = n
proof
  let n be Nat;
  thus thesis by mml.number.natural.Nat_add_zero;
end;

:: Theorem without explicit justification (auto-proved by verifier)
theorem Trivial: 0 = 0;

:: Conjecture without proof (unverified assertion)
conjecture Goldbach:
  for n being even Nat st n > 2
    ex p, q being Prime st n = p + q;

:: Conjecture with proof that references another conjecture
conjecture Even_Goldbach:
  for n being even Nat st n > 4
    ex p, q being odd Prime st n = p + q
  by Goldbach, mml.number.prime.Odd_prime_except_2;
```

> [!NOTE]
> Parameterized reasoning templates (`scheme`) are syntactically expressed as template theorems. See [Chapter 18 (Templates), §18.8](./18.templates.md#188-template-for-theorems-theorem--scheme) for syntax, and [Chapter 19 (Reasoning Patterns)](./19.reasoning_patterns.md) for application patterns.

> [!NOTE]
> For ATP integration, solver selection, and hint annotations (e.g., `@[hint]`, `@[simp]`), see [Chapter 23 (Source Code Annotation)](./23.source_code_annotation.md).

## 16.2 Syntax of Theorem Declarations

**Syntax (EBNF):**

```ebnf
theorem_item  ::= ( "theorem" | "conjecture" ) label_identifier ":" formula [ justification ] ";" ;

justification ::= simple_justification | proof ;
proof         ::= "proof" reasoning "end" ;
reasoning     ::= { statement } ;
```

- **Label**: Mandatory. Enables the theorem to be referenced from other proofs via `by` justifications.
- **Formula**: The proposition Φ to be proved. See [Chapter 14 (Formulas)](./14.formulas.md) for formula syntax.
- **Justification**: Optional. Either a `by` reference list, a full `proof ... end` block, or omitted entirely. When omitted, the verifier attempts automatic proof. See [Chapter 15 (Statements)](./15.statements.md) for statement syntax within proofs.

**Example:**

```mizar
:: Theorem with a full proof
theorem Lagrange:
  for G being finite Group, H being Subgroup of G
    holds card H divides card G
proof
  let G be finite Group;
  let H be Subgroup of G;
  consider I being Left_Cosets of H by mml.group.Left_Cosets_def;
  card G = card H * card I by mml.group.Coset_partition;
  hence thesis by mml.number.natural.Nat_divides_def;
end;

:: Theorem with simple justification (derived from existing results)
theorem Cor1:
  for G being finite Group, H being Subgroup of G
    holds card H <= card G
  by Lagrange, mml.number.natural.Nat_divides_le;
```

**Conjecture Propagation:**

A `theorem` must not reference any `conjecture` (directly or transitively). The verifier emits an error if this rule is violated. To derive from a conjecture, the result must itself be declared as `conjecture`.

```mizar
conjecture C1: for n being Nat holds P[n];

:: ERROR: theorem must not depend on conjecture
theorem Th2: P[42] by C1;
:: Verifier error: "Th2 depends on unverified conjecture C1"

:: OK: conjecture may depend on conjecture
conjecture C2: P[42] by C1;
```

## 16.3 Proof Skeleton and Natural Deduction

Mizar adopts **Jaśkowski-style natural deduction**, a declarative proof framework where the logical structure of the theorem being proved determines the shape of the proof. Rather than procedurally transforming a goal (as in tactic-based systems), the proof author writes a series of declarations that mirror the formula structure.

### 16.3.1 Skeleton Extraction

When a `proof ... end` block begins, the verifier analyses the formula Φ to be proved and extracts a **proof skeleton** — a tree of nested blocks determined by the outermost logical connectives of Φ. Each node in the skeleton corresponds to a structural decomposition rule, and each leaf is a **terminal obligation** that must be justified.

**Example:**

Given the theorem:

```mizar
theorem Th2:
  for x being Real st x > 0 holds x^2 > 0
```

The formula has the structure `∀x:Real. (x > 0 → x² > 0)`. The skeleton is:

```
Skeleton of: ∀x:Real. (x > 0 → x² > 0)
├─ [∀-intro]  let x be Real;
│  └─ [→-intro]  assume x > 0;
│     └─ [leaf]  ⊢ x² > 0        ← terminal obligation
```

The corresponding Mizar proof mirrors this skeleton:

```mizar
proof
  let x be Real;                   :: ∀-intro: introduce x
  assume A1: x > 0;                :: →-intro: assume antecedent
  thus x^2 > 0                     :: terminal obligation: justify conclusion
    by A1, mml.number.real.Square_positive;
end;
```

The proof is **declarative**: each statement declares a structural fact about the formula rather than issuing a command to modify a goal state. The verifier checks that the sequence of declarations matches the structure of Φ and that each terminal obligation is properly justified.

### 16.3.2 The `thesis` Keyword

The keyword `thesis` is a dynamic constant that evaluates to the **current terminal obligation** — the formula that remains to be concluded at the current position in the proof skeleton.

```mizar
theorem Th3:
  for n being Nat holds n >= 0
proof
  let n be Nat;
  thus thesis by mml.number.natural.Nat_nonneg;   :: thesis = (n >= 0)
end;
```

- After `let x be T;`, `thesis` is updated to the body of the universally quantified formula.
- After `assume φ;`, `thesis` is updated to the consequent of the implication.
- If the remaining obligation is a conjunction φ ∧ ψ, `thesis` refers to the entire remaining conjunction until a `thus` discharges one component.
- `thesis` allows writing generic justifications without restating the full formula.

> [!NOTE]
> For the `thesis` constant in formula syntax, see [Chapter 14 (Formulas), §14.6](./14.formulas.md#146-special-formula-forms).

### 16.3.3 Skeleton Decomposition Rules

The following rules define how each logical connective in a formula determines the corresponding proof skeleton element. If a statement does not match the expected structure of the formula, a verification error occurs.

**1. Universal Quantification (`let`)**

| | |
|---|---|
| **Formula** | ∀x:T. φ(x) |
| **Skeleton** | `let y be T;` — introduces a fresh variable |
| **Remaining Obligation** | φ(y) |

```mizar
:: Formula: for x being Real holds x + 0 = x
let x be Real;
:: Obligation becomes: x + 0 = x
```

**2. Implication (`assume`)**

| | |
|---|---|
| **Formula** | φ → ψ |
| **Skeleton** | `assume φ;` — declares the antecedent as a local fact |
| **Remaining Obligation** | ψ |

```mizar
:: Formula: x > 0 implies x^2 > 0
assume A1: x > 0;
:: Obligation becomes: x^2 > 0
```

**3. Conjunction — sequential discharge (`thus`)**

| | |
|---|---|
| **Formula** | φ ∧ ψ |
| **Skeleton** | Two sequential `thus` statements |
| **Obligations** | First φ, then ψ |

```mizar
:: Formula: x > 0 & x < 10
thus x > 0 by A1;            :: discharges first conjunct
:: Obligation becomes: x < 10
thus x < 10 by A2;           :: discharges second conjunct
:: All obligations discharged
```

**4. Direct Conclusion (`thus`)**

| | |
|---|---|
| **Formula** | φ (atomic or non-decomposable) |
| **Skeleton** | `thus φ by J;` — justifies the terminal obligation |
| **Result** | Obligation discharged |

**5. Existential Quantification (`take`)**

| | |
|---|---|
| **Formula** | ∃x:T. φ(x) |
| **Skeleton** | `take t;` — provides a witness term |
| **Remaining Obligation** | φ(t) |

```mizar
:: Formula: ex n being Nat st n > 100
take 101;
:: Obligation becomes: 101 > 100
thus thesis;
```

**6. Equivalence (`iff`)**

| | |
|---|---|
| **Formula** | φ ↔ ψ |
| **Skeleton** | Two sub-proofs: φ → ψ and ψ → φ |
| **Obligations** | Each direction proved independently |

```mizar
:: Formula: x in A /\ B iff x in A & x in B
thus x in A /\ B implies x in A & x in B
proof
  assume x in A /\ B;
  hence thesis by mml.set.Intersection_def;
end;
thus x in A & x in B implies x in A /\ B
proof
  assume that A1: x in A and A2: x in B;
  hence thesis by A1, A2, mml.set.Intersection_def;
end;
```

**7. Case Analysis (`per cases`)**

| | |
|---|---|
| **Formula** | φ (any form, when the proof requires case splitting) |
| **Skeleton** | `per cases by J;` followed by `case` sub-blocks |
| **Obligations** | Prove φ under each case assumption |

```mizar
:: Formula: |x| >= 0
per cases;
case x >= 0;
  thus |x| = x & x >= 0;
end;
case x < 0;
  thus |x| = -x & -x > 0;
end;
```

> [!NOTE]
> For details on `let`, `assume`, `thus`, `take`, and `per cases` syntax, see [Chapter 15 (Statements)](./15.statements.md).

**Composite Skeleton Example:**

```mizar
:: Formula: ∀x:Real. (x > 0 → ∃y:Real. (y > 0 ∧ y < x))
theorem Th5:
  for x being Real st x > 0
    ex y being Real st y > 0 & y < x
proof
  let x be Real;                    :: ∀-intro
  assume A1: x > 0;                 :: →-intro
  take y = x / 2;                   :: ∃-intro (witness)
  thus y > 0                        :: ∧-left obligation
    by A1, mml.number.real.Half_positive;
  thus y < x                        :: ∧-right obligation
    by A1, mml.number.real.Half_less;
end;
```

Skeleton tree:

```
∀x:Real. (x > 0 → ∃y:Real. (y > 0 ∧ y < x))
├─ [∀-intro]  let x be Real;
│  └─ [→-intro]  assume x > 0;
│     └─ [∃-intro]  take x/2;
│        ├─ [leaf]  ⊢ x/2 > 0     (by Half_positive)
│        └─ [leaf]  ⊢ x/2 < x     (by Half_less)
```

## 16.4 Proof Structure and Scope

### 16.4.1 Proof Blocks

A `proof` block creates a new logical scope for the skeleton decomposition of the formula being proved.

**Syntax (EBNF):**

```ebnf
proof     ::= "proof" reasoning "end" ;
reasoning ::= { statement } ;
```

- **Input**: Inherits the formula from the preceding `theorem`, `definition`, or correctness condition.
- **Output**: All terminal obligations must be discharged. Any unjustified `thesis` at `end` triggers a "Not proven" error.

**Example:**

```mizar
theorem Th4:
  for x being Real holds x * 0 = 0
proof
  let x be Real;
  thus x * 0 = x * (1 - 1)
            .= x * 1 - x * 1 by mml.number.real.Distributive
            .= 0;
end;
```

### 16.4.2 Scope and Visibility

- **Labels**: Labels defined inside a proof (e.g., `A1:`) are **local** to that proof block. They cannot be accessed from outside.
- **Variables**: Variables introduced via `let`, `given`, or `consider` are local to the enclosing block.
- **Same-scope uniqueness**: Duplicate labels and duplicate variable names within the same scope are forbidden (compile error).
- **Inner-scope shadowing**: A variable in an inner block may shadow an outer variable of the same name.

> [!NOTE]
> For detailed scoping and shadowing rules, see [Chapter 4 (Variables and Constants), §4.6](./04.variables_and_constants.md#46-scoping-and-shadowing).

### 16.4.3 Diffuse Reasoning (Nested Proofs)

Complex proofs often require sub-arguments. These are handled via diffuse statements, which behave as anonymous theorems with local scope.

**`now ... end`**: Creates a labeled reasoning block whose collected conclusions become a referenceable proposition.

```mizar
A1: now
  assume x > 0;
  thus x^2 > 0 by mml.number.real.Square_positive;
end;
:: A1 refers to: x > 0 implies x^2 > 0

thus thesis by A1;
```

**`hereby ... end`**: Syntactic sugar for `thus now ... end`. Asserts the result of the block as a partial conclusion of the current obligation.

```mizar
hereby
  assume x > 0;
  thus x^2 > 0 by mml.number.real.Square_positive;
end;
:: Equivalent to: thus (x > 0 implies x^2 > 0) proof ... end;
```

> [!NOTE]
> For `now` and `hereby` syntax, see [Chapter 15 (Statements), §15.6](./15.statements.md#156-proof-organization).

## 16.5 Type System Proof Obligations

Definitions in Mizar (`func`, `pred`, `mode`, `attr`, `cluster`) generate implicit proof obligations that must be discharged. These are called **correctness conditions**.

### 16.5.1 Existence and Uniqueness

For a functor definition using `means`:

```mizar
definition
  let x be A;
  func F(x) -> B means
    :: it is the result value
    P[it, x];
  existence
  proof
    :: Must prove: ex y being B st P[y, x]
    ...
  end;
  uniqueness
  proof
    :: Must prove: for y1, y2 being B st P[y1, x] & P[y2, x] holds y1 = y2
    ...
  end;
end;
```

| Condition | FOL Obligation |
|---|---|
| `existence` | `∀x. (is_A(x) → ∃y. (is_B(y) ∧ P(y, x)))` |
| `uniqueness` | `∀x. (is_A(x) → ∀y₁,y₂. (is_B(y₁) ∧ is_B(y₂) ∧ P(y₁,x) ∧ P(y₂,x) → y₁ = y₂))` |

> [!NOTE]
> For `equals`-style functor definitions, uniqueness is trivially satisfied and can be omitted. See [Chapter 10 (Functors), §10.6](./10.functors.md#106-correctness-conditions).

### 16.5.2 Coherence and Compatibility

When redefining a functor or attribute, logical consistency must be proved.

**Attribute Redefinition:**

```mizar
definition
  let B be A;  :: B is a subtype of A
  redefine attr B is Name means P'[it];
  coherence
  proof
    :: Must prove: for x being B holds (OriginalDef[x] iff P'[x])
    ...
  end;
end;
```

| Condition | FOL Obligation |
|---|---|
| `coherence` (attribute) | `∀x. (is_B(x) → (OriginalDef(x) ↔ P'(x)))` |
| `coherence` (result type) | `∀x. is_B(F(x))` (when narrowing return type from A to B) |

> [!NOTE]
> For predicate correctness conditions, see [Chapter 9 (Predicates), §9.5](./09.predicates.md#95-correctness-conditions).

### 16.5.3 Cluster Registration Obligations

Cluster registrations generate proof obligations to ensure type-theoretic consistency.

**Conditional Cluster:**

```mizar
registration
  cluster empty -> finite for set;
  coherence
  proof
    :: Must prove: for x being set st x is empty holds x is finite
    let x be set;
    assume x is empty;
    thus x is finite by mml.set.Empty_is_finite;
  end;
end;
```

| Registration Type | FOL Obligation |
|---|---|
| Conditional | `∀x. (is_T(x) ∧ is_A(x) → is_B(x))` |
| Existential | `∃x. (is_T(x) ∧ is_A(x))` |
| Functorial | `∀args. is_A(F(args))` |

> [!NOTE]
> For cluster syntax and registration details, see [Chapter 17 (Clusters and Registrations)](./17.clusters_and_registrations.md).

### 16.5.4 Consistency

Functor definitions using `means` with an `otherwise` clause (partial definitions with a default case) must prove that the defining conditions are **mutually consistent** — i.e., the conditions in the main clause and the `otherwise` clause do not overlap.

**Example:**

```mizar
definition
  let x be Real;
  func SignDef: sgn(x) -> Integer means
    (x > 0 implies it = 1) &
    (x = 0 implies it = 0) &
    (x < 0 implies it = -1)
  otherwise it = 0;
  existence proof ... end;
  uniqueness proof ... end;
  consistency
  proof
    :: Must prove: the main condition and `otherwise` do not produce
    :: conflicting values for any input in their overlap
    let x be Real;
    assume A1: not (x > 0 or x = 0 or x < 0);
    thus contradiction by A1, mml.number.real.Real_trichotomy;
  end;
end;
```

| Condition | FOL Obligation |
|---|---|
| `consistency` | The main defining formula and the `otherwise` default cannot both assign different values for the same input |

> [!NOTE]
> `consistency` is required only when `otherwise` is used. Standard `means` definitions without `otherwise` do not need this condition.

## 16.6 Logic Encoding Details

This section describes how theorem declarations and proof structures map to First-Order Logic (FOL). For formula encoding, see [Chapter 14 (Formulas), §14.7](./14.formulas.md#147-logic-encoding-details). For statement encoding, see [Chapter 15 (Statements), §15.11](./15.statements.md#1511-logic-encoding-details).

### 16.6.1 Theorem Declarations

| Mizar Source | FOL Encoding |
|---|---|
| `theorem Th: φ proof ... end;` | Adds `φ` to the axiom set after verification |
| `conjecture C: φ;` | Adds `φ` to the axiom set (unverified, with warning) |
| `theorem Th: for x being T holds P(x) proof ... end;` | `∀x. (is_T(x) → P(x))` |

### 16.6.2 Proof Obligations

| Correctness Condition | FOL Obligation |
|---|---|
| `existence` (functor `F(x) -> B means P[it, x]`) | `∀x. (is_A(x) → ∃y. (is_B(y) ∧ P(y, x)))` |
| `uniqueness` (functor `F(x) -> B means P[it, x]`) | `∀x. (is_A(x) → ∀y₁,y₂. (is_B(y₁) ∧ is_B(y₂) ∧ P(y₁,x) ∧ P(y₂,x) → y₁ = y₂))` |
| `coherence` (attribute redefine) | `∀x. (is_B(x) → (Orig(x) ↔ New(x)))` |
| `coherence` (result type redefine) | `∀x. is_B(F(x))` |
| `coherence` (conditional cluster) | `∀x. (is_T(x) ∧ is_A(x) → is_B(x))` |
| `existence` (existential cluster) | `∃x. (is_T(x) ∧ is_A(x))` |
| `consistency` (functor with `otherwise`) | Main condition and default do not conflict |

### 16.6.3 Skeleton Encoding

The proof skeleton maps to Jaśkowski-style natural deduction derivations:

| Skeleton Element | Natural Deduction Rule |
|---|---|
| `let x be T;` | ∀-introduction: introduce fresh variable with type guard |
| `assume φ;` | →-introduction: declare antecedent as local fact |
| `thus φ by J;` | Direct derivation: Γ ⊢ φ (using justification J) |
| `take t;` | ∃-introduction: provide witness `t` |
| `per cases; case φᵢ;` | ∨-elimination: prove obligation under each case |
| `given x such that φ;` | ∃-elimination: instantiate existential |

**Complete example:**

```mizar
theorem Th5:
  for x being Real st x > 0
    ex y being Real st y > 0 & y < x
proof
  let x be Real;                    :: ∀-intro
  assume A1: x > 0;                 :: →-intro
  take y = x / 2;                   :: ∃-intro with witness
  thus y > 0 by A1, mml.number.real.Half_positive;
  thus y < x by A1, mml.number.real.Half_less;
end;
```

FOL encoding of the theorem:

```
∀x. (is_Real(x) ∧ x > 0 → ∃y. (is_Real(y) ∧ y > 0 ∧ y < x))
```

Derivation (Jaśkowski-style):

```
│ 1. let x : Real                          [∀-intro, type guard]
│ │ 2. assume x > 0                        [→-intro, assume A1]
│ │ 3. x/2 > 0                             [from 2, by Half_positive]
│ │ 4. x/2 < x                             [from 2, by Half_less]
│ │ 5. is_Real(x/2) ∧ x/2 > 0 ∧ x/2 < x   [∧-intro: 3, 4, type inference]
│ │ 6. ∃y. (is_Real(y) ∧ y > 0 ∧ y < x)    [∃-intro with witness x/2]
│ 7. x > 0 → ∃y. (...)                     [→-intro closing: 2–6]
8. ∀x. (is_Real(x) → x > 0 → ∃y. (...))   [∀-intro closing: 1–7]
```

## 16.7 Complete Syntax (EBNF)

Summary of all theorem and proof-related syntax from this chapter.

```ebnf
(* === Theorem Declarations === *)
theorem_item  ::= ( "theorem" | "conjecture" ) label_identifier ":" formula [ justification ] ";" ;

(* === Proof Blocks === *)
justification   ::= simple_justification | proof ;
proof           ::= "proof" reasoning "end" ;
reasoning       ::= { statement } ;

(* === Correctness Conditions === *)
correctness_conditions ::= { correctness_condition } ;
correctness_condition  ::= existence_block
                         | uniqueness_block
                         | coherence_block
                         | compatibility_block
                         | consistency_block ;
existence_block     ::= "existence" proof ;
uniqueness_block    ::= "uniqueness" proof ;
coherence_block     ::= "coherence" proof ;
compatibility_block ::= "compatibility" proof ;
consistency_block   ::= "consistency" proof ;

(* For statement syntax, see Chapter 15 (Statements) *)
(* For formula syntax, see Chapter 14 (Formulas) *)
(* For justification and reference syntax, see Chapter 15, §15.8 *)
```

## 16.8 Implementation Notes

- **Verification Order**: Proofs are verified top-down. Unjustified `conjecture` declarations are added to the axiom set without verification.
- **Conjecture Propagation**: A `theorem` must not reference any `conjecture`. The verifier emits an error if this rule is violated. A `conjecture` may reference other conjectures.
- **Automatic Proof**: When justification is omitted, the verifier attempts to prove the formula automatically (e.g., trivially true propositions, type-theoretic tautologies).
- **Error Handling**:
    - If a `proof` block contains unjustified terminal obligations, the theorem is marked as invalid.
    - Referencing a `conjecture` in a `theorem` emits a verifier error.
    - Unproved correctness conditions block the registration of the definition.
- **Skeleton Matching**: The verifier matches each proof statement against the expected skeleton structure of the formula. Matching is performed modulo definitional expansion; if syntactic matching fails, the verifier attempts to unfold definitions.
- **Thesis Tracking**: The verifier tracks the current `thesis` (terminal obligation) at each skeleton position, and should report it for debugging purposes (accessible via `show thesis` annotation or IDE integration).
