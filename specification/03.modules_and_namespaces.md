# 3. Modules and Namespaces

This chapter defines the structure of Mizar modules, the rules for namespaces, and the mechanisms for dependency management. It establishes how physical files map to logical theories.

* [3. Modules and Namespaces](#3-modules-and-namespaces)
  * [3.1 Module Concept and Logic Encoding](#31-module-concept-and-logic-encoding)
  * [3.2 Repository Layout and Naming](#32-repository-layout-and-naming)
    * [3.2.1 Logical Namespace Roots](#321-logical-namespace-roots)
    * [3.2.2 Mapping Files to Namespaces](#322-mapping-files-to-namespaces)
  * [3.3 Import Statements](#33-import-statements)
    * [3.3.1 Resolution Rules](#331-resolution-rules)
    * [3.3.2 Aliasing](#332-aliasing)
    * [3.3.3 Cyclic Imports](#333-cyclic-imports)
  * [3.4 Export Statements](#34-export-statements)
  * [3.5 Visibility Control (Private/Public)](#35-visibility-control-privatepublic)
    * [3.5.1 Default Visibility](#351-default-visibility)
    * [3.5.2 Visibility Modifiers](#352-visibility-modifiers)
  * [3.6 Logic Encoding and Separate Compilation](#36-logic-encoding-and-separate-compilation)
    * [3.6.1 Opaque Imports](#361-opaque-imports)
    * [3.6.2 Symbol Mangling for ATPs](#362-symbol-mangling-for-atps)
  * [3.7 Complete Syntax (EBNF)](#37-complete-syntax-ebnf)
  * [3.8 Example](#38-example)

## 3.1 Module Concept and Logic Encoding

A **Module** in Mizar serves two distinct roles:

1. **Unit of Compilation**: Corresponds to a single `.miz` source file.
2. **Logical Theory**: Defines a theory $T = (\Sigma, \Gamma)$ in First-Order Logic, where $\Sigma$ is the signature (vocabulary of functors, predicates, types, etc.) and $\Gamma$ is the set of axioms and theorems.

**Namespace Principle**:
There is a **one-to-one mapping** between the logical namespace and the physical file path. Every symbol defined in a module is logically identified by a **Fully Qualified Name (FQN)** derived directly from its file location.

## 3.2 Repository Layout and Naming

Modules are organized hierarchically. To manage trust levels and stability effectively, the system distinguishes between three primary namespace roots.

### 3.2.1 Logical Namespace Roots

* **`std` (Standard Library)**: The core, trusted library maintained by the Mizar team.
* **`pub` (Published)**: Verified articles ("frozen" theories) from the *Journal of Formalized Mathematics*.
* **`loc` (Local)**: The user's local workspace and experimental projects.

### 3.2.2 Mapping Files to Namespaces

The package manager maps these logical roots to physical paths. The logical namespace reflects the directory structure and file name exactly.

* **Format**: `<Root>.<Component>...<Name>`
* **Rule**:
  * The path separator `/` (or `\` on Windows) corresponds to the dot `.` in the namespace.
  * The `.miz` extension is omitted in the namespace identifier.

* **Example**:
  * **File Path**: `/path/to/std/algebra/linear/vector_space.miz` (Assuming root mapping matches)
  * **Logical Root**: `std`
  * **Namespace**: `std.algebra.linear.vector_space`
  * **Module Identifier**: `vector_space` (within `std.algebra.linear`)

## 3.3 Import Statements

The `import` statement declares a dependency on another module.

**Syntax (EBNF)**:

```ebnf
import_stmt       ::= "import" module_alias_decl { "," module_alias_decl } ";" ;
module_alias_decl ::= module_path [ "as" module_identifier ] ;
module_path       ::= [ relative_prefix ] module_identifier { "." module_identifier } ;
relative_prefix   ::= "." | ".." ;
module_identifier ::= identifier ;
```

### 3.3.1 Resolution Rules

1. **Absolute Import**:
  * `import std.algebra.group;`
  * Resolves to `<std_root>/algebra/group.miz`.
2. **Relative Import**:
  * `import .utils;` (Siblings: `./utils.miz`)
  * `import ..common;` (Parent: `../common.miz`)

### 3.3.2 Aliasing

Aliases provide short names for namespaces to avoid verbosity or collision.

```mizar
import std.algebra.group as Grp;
let G be Grp.Group;
```

### 3.3.3 Cyclic Imports

Cyclic dependencies (e.g., A imports B, B imports A) are **forbidden**. The dependency graph must be a Directed Acyclic Graph (DAG) to ensure decidability of the compilation order.

## 3.4 Export Statements

The `export` statement re-publishes imported symbols or namespaces, effectively making the current module a "facade" or "aggregate" module. This allows for creating "prelude" modules that aggregate common definitions.

**Syntax (EBNF)**:
  ```ebnf
  export_stmt ::= "export" module_path { "," module_path } ";" ;
  ```

* **Usage**: `export std.algebra.group;`

## 3.5 Visibility Control (Private/Public)

By default, all definitions and declarations are **public**. Visibility modifiers can restrict access to individual items, either at the top level or within definition blocks.

**Syntax (EBNF)**:
```ebnf
visibility        ::= "private" | "public" ;

(* Top-level declarations *)
top_level_decl    ::= [ visibility ] ( theorem_decl | scheme_decl | notation_decl ) ;

(* Items inside a definition block *)
definitional_item ::= [ visibility ] ( func_def | pred_def | mode_def | attr_def | struct_def ) ;
```

* **Public**: Part of the module's signature $\Sigma$. Accessible by importers.
* **Private**: Internal lemma or helper definition. Only visible within the file.

## 3.6 Logic Encoding and Separate Compilation

To avoid the performance degradation seen in monolithic libraries, Mizar adopts a **Separate Compilation** model.

### 3.6.1 Opaque Imports

When Module A imports Module B:

1. **No Re-verification**: The proofs in Module B are **not** re-checked.
2. **Signature Loading**: Only the logical signature and public theorems are loaded.

### 3.6.2 Symbol Mangling for ATPs

Identifiers are transformed into globally unique symbols for ATPs based on their FQN.

| Mizar Source | Logical Encoding (TPTP Example) |
| --- | --- |
| Namespace `std.algebra.group` | Prefix `std__algebra__group__` |
| Predicate `is_abelian` | `std__algebra__group__is_abelian` |

## 3.7 Complete Syntax (EBNF)

The following EBNF summarizes the module-level structure defined in this chapter.

```ebnf
compilation_unit   ::= { directive } { declaration } ;

directive          ::= import_stmt
                     | export_stmt ;

import_stmt        ::= "import" module_alias_decl { "," module_alias_decl } ";" ;
export_stmt        ::= "export" module_path { "," module_path } ";" ;

module_alias_decl  ::= module_path [ "as" module_identifier ] ;
module_path        ::= [ relative_prefix ] module_identifier { "." module_identifier } ;
relative_prefix    ::= "." | ".." ;
module_identifier  ::= identifier ;

(* Declaration Rules *)
declaration        ::= definition_block         (* Visibility is handled inside *)
                     | [ visibility ] theorem_decl
                     | [ visibility ] scheme_decl
                     | [ visibility ] notation_decl
                     | registration_block ;

visibility         ::= "private" | "public" ;

(* Definition Block Structure *)
definition_block   ::= "definition" { definition_content } "end" ;

definition_content ::= parameter_decl           (* let ... *)
                     | assumption               (* assume ... *)
                     | [ visibility ] definitional_item ;

definitional_item  ::= func_def | pred_def | mode_def | attr_def | struct_def ;

(* Note: Specific syntax for func_def, theorem_decl, etc. is defined in subsequent chapters *)
```

## 3.8 Example

**File**: `/std/algebra/abelian_group.miz`

```mizar
:: Defines module: std.algebra.abelian_group

:: 1. Imports
import std.algebra.group as Grp;
import std.arithmetics.integers;

:: 2. Exports
export Grp;

:: 3. Private Lemma
private theorem CommutativityLemma:
  for a, b being Element of Grp.Group holds ...;

:: 4. Public Definition (Attribute)
definition
  let G be Grp.Group;
  attr G is abelian means
    for a, b being Element of G holds a * b = b * a;
end

:: 5. Public Theorem
theorem AbelianProperties:
  for G being Grp.Group st G is abelian holds ...
  by CommutativityLemma;
```