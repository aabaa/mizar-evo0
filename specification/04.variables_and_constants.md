# 4. Variables and Constants

This chapter defines how variables and local constants are declared, scoped, and mapped to First-Order Logic (FOL).

* [4. Variables and Constants](#4-variables-and-constants)
  * [4.1 Variables and Logic](#41-variables-and-logic)
  * [4.2 Variable Declarations (`let`)](#42-variable-declarations-let)
  * [4.3 Reserved Variables (`reserve`)](#43-reserved-variables-reserve)
  * [4.4 Local Constants (`set`, `reconsider`)](#44-local-constants-set-reconsider)
  * [4.5 Quantified Variables](#45-quantified-variables)
  * [4.6 Scoping and Shadowing](#46-scoping-and-shadowing)
  * [4.7 Logic Encoding Details](#47-logic-encoding-details)
  * [4.8 Complete Syntax (EBNF)](#48-complete-syntax-ebnf)

## 4.1 Variables and Logic

In Mizar, variables serve three distinct roles depending on their context:

1. **Free Variables**: Introduced by `let`. They act as fixed arbitrary constants within a proof block (Skolem constants).
2. **Bound Variables**: Introduced by quantifiers (`for`, `ex`). Their scope is limited to the formula or term.
3. **Local Constants**: Introduced by `set` or `reconsider`. They are names bound to specific values or terms (abbreviations).

**Soft Type System**:
Mizar variables are typed. Logically, a declaration `let x be T` corresponds to treating `x` as an untyped variable in FOL, constrained by a unary predicate `T(x)`.

## 4.2 Variable Declarations (`let`)

The `let` statement introduces a **Free Variable** into the current environment.

**Syntax (EBNF)**:

```ebnf
let_decl        ::= "let" qualified_vars [ "such" "that" formula ] ";" ;
qualified_vars  ::= identifier_list [ "be" type_expression ] ;
identifier_list ::= identifier { "," identifier } ;
```

* **Semantics**: Introduces new arbitrary elements.
* **Type Assumption**: If `be T` is specified, the logical context is augmented with the assumption `x is T`.
* **Such That Clause**: The optional `such that` clause adds an assumption (hypothesis) for the declared variables.

**Examples**:

```mizar
let x be Real;                      :: x is an arbitrary Real
let n, m be Nat;                    :: n and m are Nats
let G be Group;
let a be positive Real;             :: Attributes can be included
let x be Real such that x > 0;      :: x is Real and assumed to be > 0
let p be Prime such that p > 100;   :: p is Prime and assumed > 100
```

## 4.3 Reserved Variables (`reserve`)

The `reserve` directive defines a **default type** for specific identifiers. It is **not** a variable declaration itself but a macro-like hint for the parser.

**Syntax (EBNF)**:

```ebnf
reserve_decl    ::= "reserve" reserve_segment ";" ;
reserve_segment ::= identifier_list "for" type_expression ;
```

**Semantics**:
If `x` is reserved for `Real`:

1. `let x;` is expanded to `let x be Real;`.
2. `for x holds P(x)` is expanded to `for x being Real holds P(x)`.
3. Explicit types override the reservation: `let x be Nat;` is valid (shadows the reservation).

**Example**:

```mizar
reserve i, j for Nat;
reserve x for Real;

let i;      :: Equivalent to: let i be Nat;
let x;      :: Equivalent to: let x be Real;
let i be Integer; :: Valid override.

```

## 4.4 Local Constants (`set`, `reconsider`)

Local constants assign a name to a specific term.

### 4.4.1 Set Statement (`set`)

Assigns a name to a term expression. This is purely a syntactic abbreviation (macro) or an equality axiom.

**Syntax (EBNF)**:

```ebnf
set_decl ::= "set" identifier "=" term_expression ";" ;

```

**Example**:

```mizar
set zero = 0;
set X = {1, 2, 3};
set f = id REAL;

```

* **Logic**: Introduces `identifier` and adds the axiom `identifier = term_expression`.

### 4.4.2 Reconsider Statement (`reconsider`)

Defines a new constant from an existing term, but with a **new type**. This generates a proof obligation (Correctness Condition).

**Syntax (EBNF)**:

```ebnf
reconsider_decl ::= "reconsider" reconsider_target "as" type_expression ";" ;
reconsider_target ::= identifier "=" term_expression
                    | term_expression ;
```

There are two forms:

1. **New Constant Form**: `reconsider P = R as T;` — Creates a new constant `P` equal to `R` with type `T`.
2. **Type Cast Form**: `reconsider x as T;` — Casts an existing variable `x` to type `T` without creating a new name.

**Examples**:

```mizar
set R = { x where x is Real : x > 0 };
reconsider P = R as non empty set;  :: New constant P, must prove R is non empty

let n be Nat;
reconsider n as Integer;            :: Type cast: n is now treated as Integer
```

* **Semantics**: Both forms generate a proof obligation (Correctness Condition) that the term has the specified type.

## 4.5 Quantified Variables

Variables bound by universal (`for`) or existential (`ex`) quantifiers.

**Syntax (EBNF)**:

```ebnf
quantified_var_decl ::= identifier_list [ "being" type_expression ] ;

```

* **Note**: If `being T` is omitted, the `reserve` type is used. If no reservation exists, it is a syntax error (unless context allows untyped, e.g., Set Theory).

**Examples**:

```mizar
for x being Real holds x^2 >= 0;
ex n being Nat st n > 0;
```

## 4.6 Scoping and Shadowing

Mizar employs **Lexical Scoping** with block structures.

### 4.6.1 Scoping Levels

1. **Module Level**: `reserve` directives apply to the whole file (unless shadowed).
2. **Theorem/Definition Block**: `let` variables are valid until the `end` of the block (or `thesis` completion).
3. **Local Block (`now ... end`)**: Variables declared inside are local to the block.

### 4.6.2 Shadowing Rules

* **Allowed**: A variable in an inner scope can have the same name as one in an outer scope. The inner declaration shadows the outer one.
* **Forbidden**: Redeclaring the same variable name within the **same** scope is a syntax error.

```mizar
let x be Real;
now
  let x be Nat;  :: Valid shadowing. Inside this block, x is Nat.
end;
:: Here x is Real again.

let x be Integer; :: Error: Redeclaration in same scope.

```

## 4.7 Logic Encoding Details

This section describes how variables map to ATP inputs (e.g., TPTP format).

### 4.7.1 Type Guards (Relativization)

Since First-Order Logic is typically untyped, Mizar types are encoded as **Type Guard Predicates**.

* **Source**: `let x be Element of G;`
* **Encoding**:
* Variable `x` is treated as a generic variable.
* A hypothesis `is_Element_of(x, G)` is added to the Antecedent.



### 4.7.2 Attributes as Predicates

Adjectives (Attributes) are flattened into conjunctions.

* **Source**: `let x be positive Real;`
* **Encoding**:
  * Hypothesis: `x is Real ∧ x is positive`

### 4.7.3 Constants and Skolemization

* **Global Constants** (`func` with 0 args): Encoded as function symbols with arity 0.
* **Local Constants** (`set x = t`): Encoded as an equality axiom `x = t` in the local scope.

## 4.8 Complete Syntax (EBNF)

Summary of variable-related syntax.

```ebnf
variable_directive ::= reserve_decl
                     | let_decl
                     | set_decl
                     | reconsider_decl ;

(* Reservation *)
reserve_decl       ::= "reserve" reserve_segment ";" ;
reserve_segment    ::= identifier_list "for" type_expression ;

(* Free Variable Declaration *)
let_decl           ::= "let" qualified_vars [ "such" "that" formula ] ";" ;
qualified_vars     ::= identifier_list [ "be" type_expression ] ;

(* Local Constant Declaration *)
set_decl           ::= "set" identifier "=" term_expression ";" ;
reconsider_decl    ::= "reconsider" reconsider_target "as" type_expression ";" ;
reconsider_target  ::= identifier "=" term_expression
                     | term_expression ;

(* Quantifier Binding (used in formulas) *)
quantified_var     ::= identifier_list [ "being" type_expression ] ;

identifier_list    ::= identifier { "," identifier } ;
```
