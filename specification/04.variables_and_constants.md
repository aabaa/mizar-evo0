# 4. Variables and Constants

This chapter defines how variables and local constants are declared, scoped, and mapped to First-Order Logic (FOL).

* [4. Variables and Constants](./#4-variables-and-constants)
  * [4.1 Variables and Logic](./#41-variables-and-logic)
  * [4.2 Variable Declarations (`let`)](./#42-variable-declarations-let)
  * [4.3 Reserved Variables (`reserve`)](./#43-reserved-variables-reserve)
  * [4.4 Local Constants (`set`, `reconsider`)](./#44-local-constants-set-reconsider)
  * [4.5 Quantified Variables](./#45-quantified-variables)
  * [4.6 Scoping and Shadowing](./#46-scoping-and-shadowing)
  * [4.7 Logic Encoding Details](./#47-logic-encoding-details)
  * [4.8 Complete Syntax (EBNF)](./#48-complete-syntax-ebnf)

## 4.1 Variables and Logic

In Mizar, variables serve three distinct roles depending on their context:

1. **Free Variables**: Introduced by `let`. They act as fixed arbitrary constants within a proof block (Skolem constants).
2. **Bound Variables**: Introduced by quantifiers (`for`, `ex`) or set comprehensions (`{ x where ... }`). Their scope is limited to the formula or term.
3. **Local Constants**: Introduced by `set` or `reconsider`. They are names bound to specific values or terms (abbreviations).

**Soft Type System**:
Mizar variables are typed. Logically, a declaration `let x be T` corresponds to treating `x` as an untyped variable in FOL, constrained by a unary predicate `T(x)`.

## 4.2 Variable Declarations (`let`)

The `let` statement introduces a **Free Variable** into the current environment.

**Syntax (EBNF)**:

```ebnf
let_decl ::= "let" identifier_list [ "be" type_expression ] ";" ;
identifier_list ::= identifier { "," identifier } ;

```

* **Semantics**: Introduces new arbitrary elements.
* **Type Assumption**: If `be T` is specified, the logical context is augmented with the assumption `x is T`.

**Examples**:

```mizar
let x be Real;              :: x is an arbitrary Real
let n, m be Nat;            :: n and m are Nats
let G be Group;
let a be positive Real;     :: Attributes can be included

```

## 4.3 Reserved Variables (`reserve`)

The `reserve` directive defines a **default type** for specific identifiers. It is **not** a variable declaration itself but a macro-like hint for the parser.

**Syntax (EBNF)**:

```ebnf
reserve_decl ::= "reserve" reserve_segment { "," reserve_segment } ";" ;
reserve_segment ::= identifier_list "for" type_expression ;

```

**Semantics**:
If `x` is reserved for `Real`:

1. `let x;` is expanded to `let x be Real;`.
2. `for x holds P(x)` is expanded to `for x being Real holds P(x)`.
3. Explicit types override the reservation: `let x be Nat;` is valid (shadows the reservation).

**Example**:

```mizar
reserve i, j for Nat;
reserve x for Real;

let i;      :: Equivalent to: let i be Nat;
let x;      :: Equivalent to: let x be Real;
let i be Integer; :: Valid override.

```

## 4.4 Local Constants (`set`, `reconsider`)

Local constants assign a name to a specific term.

### 4.4.1 Set Statement (`set`)

Assigns a name to a term expression. This is purely a syntactic abbreviation (macro) or an equality axiom.

**Syntax (EBNF)**:

```ebnf
set_decl ::= "set" identifier "=" term_expression ";" ;

```

**Example**:

```mizar
set zero = 0;
set X = {1, 2, 3};
set f = id REAL;

```

* **Logic**: Introduces `identifier` and adds the axiom `identifier = term_expression`.

### 4.4.2 Reconsider Statement (`reconsider`)

Defines a new constant from an existing term, but with a **new type**. This generates a proof obligation (Correctness Condition).

**Syntax (EBNF)**:

```ebnf
reconsider_decl ::= "reconsider" identifier "=" term_expression "as" type_expression ";" ;

```

**Example**:

```mizar
set R = { x where x is Real : x > 0 };
reconsider P = R as non empty set;  :: Must prove R is non empty

```

* **Semantics**: `P` is defined as equal to `R`, but Mizar treats `P` as having type `non empty set`.

## 4.5 Quantified Variables

Variables bound by universal (`for`) or existential (`ex`) quantifiers.

**Syntax (EBNF)**:

```ebnf
quantified_var_decl ::= identifier_list [ "being" type_expression ] ;

```

* **Note**: If `being T` is omitted, the `reserve` type is used. If no reservation exists, it is a syntax error (unless context allows untyped, e.g., Set Theory).

**Examples**:

```mizar
for x being Real holds x^2 >= 0;
ex n being Nat st n > 0;
{ x where x is Real : x > 0 }  :: Set comprehension binding

```

## 4.6 Scoping and Shadowing

Mizar employs **Lexical Scoping** with block structures.

### 4.6.1 Scoping Levels

1. **Module Level**: `reserve` directives apply to the whole file (unless shadowed).
2. **Theorem/Definition Block**: `let` variables are valid until the `end` of the block (or `thesis` completion).
3. **Local Block (`now ... end`)**: Variables declared inside are local to the block.

### 4.6.2 Shadowing Rules

* **Allowed**: A variable in an inner scope can have the same name as one in an outer scope. The inner declaration shadows the outer one.
* **Forbidden**: Redeclaring the same variable name within the **same** scope is a syntax error.

```mizar
let x be Real;
now
  let x be Nat;  :: Valid shadowing. Inside this block, x is Nat.
end;
:: Here x is Real again.

let x be Integer; :: Error: Redeclaration in same scope.

```

## 4.7 Logic Encoding Details

This section describes how variables map to ATP inputs (e.g., TPTP format).

### 4.7.1 Type Guards (Relativization)

Since First-Order Logic is typically untyped, Mizar types are encoded as **Type Guard Predicates**.

* **Source**: `let x be Element of G;`
* **Encoding**:
* Variable `x` is treated as a generic variable.
* A hypothesis `is_Element_of(x, G)` is added to the Antecedent.



### 4.7.2 Attributes as Predicates

Adjectives (Attributes) are flattened into conjunctions.

* **Source**: `let x be positive Real;`
* **Encoding**:
* Hypothesis: `x is Real`  `x is positive`

### 4.7.3 Constants and Skolemization

* **Global Constants** (`func` with 0 args): Encoded as function symbols with arity 0.
* **Local Constants** (`set x = t`): Encoded as an equality axiom `x = t` in the local scope.

## 4.8 Complete Syntax (EBNF)

Summary of variable-related syntax.

```ebnf
variable_directive ::= reserve_decl
                     | let_decl
                     | set_decl
                     | reconsider_decl ;

(* Reservation *)
reserve_decl       ::= "reserve" reserve_segment { "," reserve_segment } ";" ;
reserve_segment    ::= identifier_list "for" type_expression ;

(* Free Variable Declaration *)
let_decl           ::= "let" identifier_list [ "be" type_expression ] ";" ;

(* Local Constant Declaration *)
set_decl           ::= "set" identifier "=" term_expression ";" ;
reconsider_decl    ::= "reconsider" identifier "=" term_expression "as" type_expression ";" ;

(* Quantifier Binding (used in formulas) *)
quantified_var     ::= identifier_list [ "being" type_expression ] ;

identifier_list    ::= identifier { "," identifier } ;
```
