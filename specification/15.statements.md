# 15. Statements

- [15. Statements](#15-statements)
  - [15.1 Overview](#151-overview)
  - [15.2 Variable and Constant Introduction](#152-variable-and-constant-introduction)
    - [15.2.1 Generalization Statement (`let`)](#1521-generalization-statement-let)
    - [15.2.2 Constant Definition (`set`)](#1522-constant-definition-set)
    - [15.2.3 Inline Function Definition (`deffunc`)](#1523-inline-function-definition-deffunc)
    - [15.2.4 Inline Predicate Definition (`defpred`)](#1524-inline-predicate-definition-defpred)
  - [15.3 Assumptions and Assertions](#153-assumptions-and-assertions)
    - [15.3.1 Single Assumption (`assume`)](#1531-single-assumption-assume)
    - [15.3.2 Collective Assumption (`assume that`)](#1532-collective-assumption-assume-that)
    - [15.3.3 Existential Assumption (`given`)](#1533-existential-assumption-given)
    - [15.3.4 Choice Statement (`consider`)](#1534-choice-statement-consider)
  - [15.4 Conclusions and Derivations](#154-conclusions-and-derivations)
    - [15.4.1 Direct Conclusion (`thus`)](#1541-direct-conclusion-thus)
    - [15.4.2 Sequential Conclusion (`hence`)](#1542-sequential-conclusion-hence)
    - [15.4.3 Block Conclusion (`hereby`)](#1543-block-conclusion-hereby)
    - [15.4.4 Witness Introduction (`take`)](#1544-witness-introduction-take)
  - [15.5 Type Management](#155-type-management)
    - [15.5.1 Type Reconsideration (`reconsider`)](#1551-type-reconsideration-reconsider)
  - [15.6 Proof Organization](#156-proof-organization)
    - [15.6.1 Labeled Reasoning Block (`now`)](#1561-labeled-reasoning-block-now)
    - [15.6.2 Case Analysis (`case`)](#1562-case-analysis-case)
    - [15.6.3 Supposition (`suppose`)](#1563-supposition-suppose)
  - [15.7 Iterative Equality](#157-iterative-equality)
  - [15.8 Justification Forms](#158-justification-forms)
    - [15.8.1 Simple Justification](#1581-simple-justification)
    - [15.8.2 Full Proof](#1582-full-proof)
  - [15.9 Statement Modifiers](#159-statement-modifiers)
    - [15.9.1 Sequential Modifier (`then`)](#1591-sequential-modifier-then)
  - [15.10 Scoping and Context Rules](#1510-scoping-and-context-rules)
  - [15.11 Logic Encoding Details](#1511-logic-encoding-details)
  - [15.12 Complete Syntax (EBNF)](#1512-complete-syntax-ebnf)

## 15.1 Overview

Statements in Mizar form the building blocks of mathematical reasoning. They appear within various contexts including theorem proofs and auxiliary reasoning blocks. This chapter describes all statement forms, their syntax, semantics, and proper usage.

Statements can be broadly categorized into:
- **Declarative statements**: Introduce variables, constants, or assumptions
- **Justification statements**: Assert propositions with supporting evidence
- **Structural statements**: Organize proof flow and reasoning patterns
- **Type-related statements**: Handle type conversions and reinterpretations

## 15.2 Variable and Constant Introduction

### 15.2.1 Generalization Statement (`let`)

The `let` statement introduces universally quantified variables with optional constraints.

**Syntax (EBNF):**

```ebnf
generalization    ::= "let" variable_list [ qualification ] [ "such" conditions ] ";" ;
variable_list     ::= identifier { "," identifier } ;
qualification     ::= ( "being" | "be" ) type_expression ;
conditions        ::= "that" proposition { "and" proposition } ;
```

**Example:**

```mizar
let x be Real;
let y, z be Real such that y < z;
let G be Group;
let H be Subgroup of G;
let n be Nat such that n > 0 and n is prime;
```

**Semantics:**
- In proof contexts: introduces arbitrary but fixed values (universal generalization)
- In definition contexts: introduces parameters for the definition
- Inner-scope shadowing is allowed but should be used sparingly for clarity (see [Ch.4 §4.6](./04.variables_and_constants.md#46-scoping-and-shadowing))
- The `such that` clause adds assumptions about the introduced variables
- Multiple variables are allowed only when they share the same type

> [!NOTE]
> For variable declaration and scoping rules, see [Chapter 4 (Variables and Constants)](./04.variables_and_constants.md).
> The `let` statement in proofs corresponds to universal quantification in the proved theorem. See [Chapter 14 (Formulas), §14.4.1](./14.formulas.md#1441-universal-quantification-for) for the `for ... holds` parallel.

### 15.2.2 Constant Definition (`set`)

The `set` statement introduces abbreviations for terms.

**Syntax (EBNF):**

```ebnf
constant_definition ::= "set" identifier "=" term_expression ";" ;
```

**Example:**

```mizar
set x = a + b;
set y = f.x;
set n = card X;
set dom_f = dom f;        :: abbreviation for complex subexpressions
set prod = [:A, B:];
```

**Semantics:**
- Creates syntactic abbreviations expanded during verification
- The type is inferred from the right-hand side expression
- No label is needed (labels are for propositions, not definitions)
- Only single assignments are allowed per `set` statement

### 15.2.3 Inline Function Definition (`deffunc`)

Defines local function abbreviations within proofs.

**Syntax (EBNF):**

```ebnf
inline_functor_definition ::= "deffunc" identifier "(" [ typed_params ] ")" "->" type_expression
                              "equals" term_expression ";" ;
typed_params              ::= typed_param { "," typed_param } ;
typed_param               ::= identifier ( "being" | "be" ) type_expression ;
```

**Example:**

```mizar
proof
  deffunc F(n be Nat) -> Nat equals n * (n + 1);
  deffunc G(x be Real, y be Real) -> Real equals x^2 + y^2;
  ...
  F(3) = 12;              :: by definition expansion
  G(3.0, 4.0) = 25.0;    :: by definition expansion
end;
```

**Semantics:**
- Inline functors are expanded by substitution at each use site
- Scoped to the enclosing proof block — not visible outside
- The return type must be specified explicitly
- Zero-argument definitions are allowed: `deffunc C() -> Nat equals 42;`

> [!NOTE]
> For inline functor **application** syntax, see [Chapter 13 (Term Expressions), §13.2.3](./13.term_expression.md#1323-inline-functor-applications).

### 15.2.4 Inline Predicate Definition (`defpred`)

Defines local predicate abbreviations within proofs.

**Syntax (EBNF):**

```ebnf
inline_predicate_definition ::= "defpred" identifier "(" [ typed_params ] ")" "means" formula ";" ;
```

**Example:**

```mizar
proof
  defpred P(n be Nat) means n is prime & n > 2;
  defpred Q(x be Real, y be Real) means x < y & y < x + 1;
  ...
  P(n) implies n is odd;
  for n being Nat st P(n) holds n is odd;  :: using defpred in quantified formulas
end;
```

**Semantics:**
- Inline predicates are expanded by substitution at each use site
- Scoped to the enclosing proof block — not visible outside
- Zero-argument definitions are allowed: `defpred Trivial() means 0 = 0;`

> [!NOTE]
> For inline predicate **application** syntax, see [Chapter 14 (Formulas), §14.2.2](./14.formulas.md#1422-inline-predicate-applications).

## 15.3 Assumptions and Assertions

### 15.3.1 Single Assumption (`assume`)

Introduces a single proposition as an assumption.

**Syntax (EBNF):**

```ebnf
single_assumption ::= "assume" proposition ";" ;
proposition       ::= [ label_identifier ":" ] formula ;
```

**Example:**

```mizar
assume x > 0;
assume A1: G is abelian;
assume A2: for x being Element of G holds x * x = 1_G;
```

> [!NOTE]
> For the formula syntax used in propositions, see [Chapter 14 (Formulas)](./14.formulas.md).

### 15.3.2 Collective Assumption (`assume that`)

Introduces multiple related assumptions, each of which may have its own label.

**Syntax (EBNF):**

```ebnf
collective_assumption ::= "assume" conditions ";" ;
conditions            ::= "that" proposition { "and" proposition } ;
```

**Example:**

```mizar
assume that A1: x > 0
        and A2: y > 0
        and x < y;
```

> [!IMPORTANT]
> The `and` keyword here is a **statement-level condition separator**, not the formula-level conjunction `&`. Each `and`-separated proposition may have its own label and can be independently referenced in later `by` justifications (e.g., `by A1, A2`). In contrast, `&` joins two formulas into a single formula without sub-labeling. Similarly, `such that` in statements differs from `st` in quantified formulas (Ch.14) — both introduce conditions, but `such that` operates at the statement level with label support. See [Chapter 14 (Formulas), §14.3.1](./14.formulas.md#1431-conjunction-) for the `&` operator.

### 15.3.3 Existential Assumption (`given`)

Introduces existentially quantified variables with properties.

**Syntax (EBNF):**

```ebnf
existential_assumption ::= "given" variable_list [ qualification ] [ "such" conditions ] ";" ;
```

**Example:**

```mizar
given x being Real such that x^2 = 2;
given G being Group such that G is finite and card G = p;
given n being Nat such that A1: n > 0 and A2: n is prime;
```

**Semantics:**
- Introduces Skolem constants satisfying the given conditions
- Equivalent to existential instantiation in natural deduction
- Multiple variables are allowed only when they share the same type
- Used when the existence has already been established as a hypothesis

### 15.3.4 Choice Statement (`consider`)

Introduces a variable satisfying conditions with mandatory justification.

**Syntax (EBNF):**

```ebnf
choice_statement ::= "consider" identifier qualification "such" conditions simple_justification ";" ;
```

**Example:**

```mizar
consider x being Real such that x > 0 and f.x = 0 by A1, Th5;
consider p being Element of NAT such that p is prime and p > n by Euclid;
```

> [!NOTE]
> Only single variable introduction is allowed.
> Unlike `given`, `consider` requires explicit justification (`by` clause) to prove the existence.

## 15.4 Conclusions and Derivations

### 15.4.1 Direct Conclusion (`thus`)

Asserts a proposition that advances the current proof goal, with justification.

**Syntax (EBNF):**

```ebnf
conclusion ::= ( "thus" | "hence" ) proposition justification ";" ;
```

**Example:**

```mizar
thus A3: x > 0 by A1, A2;
thus thesis by Lemma1, Def3;
thus x in A & x in B by A1, A2;  :: concluding a conjunction
```

### 15.4.2 Sequential Conclusion (`hence`)

Equivalent to `then thus` — implicitly references the immediately preceding statement as part of the justification.

**Example:**

```mizar
assume A1: x > 0;
then x^2 > 0 by Square_positive;
hence x^2 + 1 > 1;  :: implicitly uses preceding "x^2 > 0"
```

### 15.4.3 Block Conclusion (`hereby`)

Introduces a reasoning block whose result serves as justification for the current proof goal. Equivalent to `thus ... proof ... end`.

**Syntax (EBNF):**

```ebnf
diffuse_conclusion ::= "hereby" reasoning "end" ;
```

**Example:**

```mizar
hereby
  assume x > 0;
  then x^2 > 0 by Th1;
  hence thesis;
end;
```

### 15.4.4 Witness Introduction (`take`)

Provides a witness for existential claims within a proof.

**Syntax (EBNF):**

```ebnf
exemplification ::= "take" example ";" ;
example         ::= term_expression | identifier "=" term_expression ;
```

**Example:**

```mizar
:: Proving: ex n being Nat st n > 100
proof
  take 101;
  thus 101 > 100;
end;

:: With named witness
proof
  take k = 2 * n + 1;
  thus k is odd;
end;
```

> [!NOTE]
> Only single witness introduction is allowed per `take` statement.

## 15.5 Type Management

### 15.5.1 Type Reconsideration (`reconsider`)

Changes the type view of a term with justification. This is the mechanism for **type narrowing** — viewing a value as a more specific type.

**Syntax (EBNF):**

```ebnf
type_changing_statement ::= "reconsider" reconsider_item "as" type_expression simple_justification ";" ;
reconsider_item         ::= identifier | identifier "=" term_expression ;
```

**Example:**

```mizar
:: Narrowing an existing variable
reconsider x as Element of NAT by A1;

:: Introducing a new constant with a narrowed type
reconsider f = F|A as Function of A, B by Th3;

:: Narrowing after establishing a property
assume A1: n >= 0;
reconsider n as Nat by A1, mml.number.integer.Nat_from_nonneg_Int;
```

**Semantics:**
- Generates a proof obligation: the justification must prove `is_T(x)` for the target type `T`
- Only single reconsideration is allowed per statement
- For automatic type widening (subtype → supertype), no `reconsider` is needed

> [!NOTE]
> For the relationship between narrowing and widening, see [Chapter 3 (Type System), §3.5](./03.type_system.md#35-subtyping-and-widening).
> For type inference details, see [Chapter 8 (Type Inference)](./08.type_inference.md).
> Term reduction (`reduce`) is a registration mechanism and is defined in [Chapter 17 (Clusters and Registrations)](./17.clusters_and_registrations.md).

## 15.6 Proof Organization

### 15.6.1 Labeled Reasoning Block (`now`)

Creates a labeled sub-proof that derives a conclusion for later reference.

**Syntax (EBNF):**

```ebnf
diffuse_statement ::= [ label_identifier ":" ] "now" reasoning "end" ;
```

**Example:**

```mizar
A1: now
  assume x > 0;
  then x^2 > 0 by Square_positive;
  thus x^2 + 1 > 1;
end;
:: A1 now refers to the derived conclusion "x > 0 implies x^2 + 1 > 1"

thus thesis by A1;
```

**Semantics:**
- The `now` block collects all `thus` conclusions into a single conjunction
- The label refers to the formula: `(assumptions) implies (conclusions)`
- Can be referenced later in `by` justifications

### 15.6.2 Case Analysis (`case`)

Structures reasoning by cases. Used within a `per cases` block.

**Syntax (EBNF):**

```ebnf
case_reasoning ::= [ "then" ] "per" "cases" simple_justification ";" ( case_list | suppose_list ) ;
case_list      ::= case_item { case_item } ;
case_item      ::= "case" ( proposition | conditions ) ";" reasoning "end" ;
```

**Example:**

```mizar
:: Prove a property for all natural numbers by splitting into two cases.
:: Nat_cases is a theorem asserting: for n being Nat holds n = 0 or n > 0
let n be Nat;
thus P[n]
proof
  per cases by mml.number.natural.Nat_cases;
  case C1: n = 0;
    thus thesis by C1, Base_case;
  end;
  case C2: n > 0;
    thus thesis by C2, Inductive_step;
  end;
end;
```

**Semantics:**
- The `per cases` justification must prove that the cases are exhaustive (`φ₁ ∨ ... ∨ φₙ`)
- Each `case` introduces its proposition as an assumption and must prove the current goal
- Both `case` and `suppose` accept `proposition`, so both can be labeled (e.g., `case C1: n = 0;`)

### 15.6.3 Supposition (`suppose`)

Alternative case introduction syntax. Used within `per cases` as an alternative to `case`.

**Syntax (EBNF):**

```ebnf
suppose_list ::= suppose_item { suppose_item } ;
suppose_item ::= "suppose" ( proposition | conditions ) ";" reasoning "end" ;
```

**Example:**

```mizar
per cases;
suppose A1: x > 0;
  thus thesis by A1, Positive_case;
end;
suppose A2: x <= 0;
  thus thesis by A2, Non_positive_case;
end;
```

> [!NOTE]
> `case` and `suppose` are syntactically interchangeable — both accept `proposition` (which can include a label) or `conditions`. They may be used based on stylistic preference.

## 15.7 Iterative Equality

Chains equality reasoning steps with intermediate justifications, enabling step-by-step equational derivations.

**Syntax (EBNF):**

```ebnf
iterative_equality ::= [ label_identifier ":" ] term_expression "=" term_expression simple_justification
                       { ".=" term_expression simple_justification } ";" ;
```

**Example:**

```mizar
A1: f.(x + y) = f.x + f.y by Additive
             .= g.x + f.y by A2
             .= g.x + g.y by A3;

:: Can be combined with the then modifier
assume A2: f = g;
then f.x + f.y = g.x + f.y by FuncEq
              .= g.x + g.y by A2;
```

**Semantics:**
- Each `.=` step introduces one equality with its own justification
- The chain derives the overall equality `a = d` from `a = b`, `b = c`, `c = d` by transitivity
- The label (if present) refers to the entire chain (i.e., the overall equality)
- Not an assignment but a justified equality assertion

## 15.8 Justification Forms

Every assertion in Mizar must be justified either by a simple reference list or by a full proof block.

### 15.8.1 Simple Justification

**Syntax (EBNF):**

```ebnf
simple_justification ::= [ "by" references ] ;
references           ::= reference { "," reference } ;
reference            ::= identifier [ template_args ]
                       | qualified_reference [ template_args ] ;
qualified_reference  ::= namespace_path "." identifier ;
namespace_path       ::= identifier { "." identifier } ;
template_args        ::= "[" template_arg { "," template_arg } "]" ;
template_arg         ::= term_expression | formula | type_expression ;
```

**Example:**

```mizar
by A1, A2;
by mml.algebra.group.Lagrange_theorem;
by Math_induction[n, n^2 >= n];
by Well_founded_induction[Nat, <, P];
```

**Reference types:**
- **Local references**: Labels and theorem names within the current proof (e.g., `A1`, `Th5`)
- **Qualified references**: Fully qualified paths using namespace notation (e.g., `mml.algebra.group.Th1`)
- **Template instantiations**: Parameterized theorems with explicit arguments (e.g., `Induction[n, P]`)

### 15.8.2 Full Proof

**Syntax (EBNF):**

```ebnf
justification ::= simple_justification | proof ;
proof         ::= "proof" reasoning "end" ;
```

## 15.9 Statement Modifiers

### 15.9.1 Sequential Modifier (`then`)

The `then` modifier indicates direct derivation from the immediately preceding statement. It implicitly adds the preceding statement's conclusion to the justification.

**Syntax (EBNF):**

```ebnf
statement ::= [ "then" ] linkable_statement | diffuse_statement ;
```

**Example:**

```mizar
assume A1: x > 0;
then x^2 > 0 by Square_positive;
hence x^2 + 1 > 1;
```

> [!NOTE]
> `hence` is syntactic sugar for `then thus`. The `then` modifier can also precede `per cases` for case analysis derived from the preceding statement.

## 15.10 Scoping and Context Rules

1. **Variable Scope**: Variables introduced by `let` are scoped to their enclosing block.
   - **Same-scope redeclaration is forbidden**: Declaring the same variable name twice within the same scope is a compile error.
   - **Inner-scope shadowing is allowed**: A variable in an inner block (e.g., `now ... end`) may shadow an outer variable of the same name. The inner declaration takes precedence within its block.
2. **Label Scope**: Labels are scoped to their enclosing reasoning block.
   - **Same-scope duplicate labels are forbidden**: Using the same label name twice within the same scope is a compile error.
   - **Inner-scope label shadowing is forbidden**: To avoid ambiguous references in `by` justifications, labels must be unique across all visible scopes.
3. **Definition Context**: In definition blocks, `let` introduces definition parameters.
4. **Proof Context**: In proof blocks, `let` introduces arbitrary fixed values.
5. **Inline Definitions**: `deffunc` and `defpred` are scoped to their enclosing proof block and cannot be referenced outside it.

> [!NOTE]
> For detailed scoping and shadowing rules, see [Chapter 4 (Variables and Constants), §4.6](./04.variables_and_constants.md#46-scoping-and-shadowing).

## 15.11 Logic Encoding Details

This section describes how each statement type maps to First-Order Logic (FOL). For type encoding conventions, see [Chapter 3 (Type System), §3.7](./03.type_system.md#37-logic-encoding-details). For formula encoding, see [Chapter 14 (Formulas), §14.7](./14.formulas.md#147-logic-encoding-details).

### 15.11.1 Variable Introduction (`let`)

The `let` statement corresponds to universal quantification in the proved theorem.

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be T;` ... `thus φ;` | `∀x. (is_T(x) → φ)` |
| `let x be T such that A1: ψ;` ... `thus φ;` | `∀x. (is_T(x) ∧ ψ → φ)` |
| `let x, y be T;` ... `thus φ;` | `∀x, y. (is_T(x) ∧ is_T(y) → φ)` |

### 15.11.2 Constant Definition (`set`)

The `set` statement introduces a local abbreviation. No FOL axiom is generated; occurrences of the identifier are substituted with the defining term.

| Mizar Source | FOL Encoding |
| --- | --- |
| `set c = t;` | Substitution: replace `c` with `t` in subsequent formulas |

### 15.11.3 Inline Definitions (`deffunc`, `defpred`)

Inline definitions are expanded by substitution. They generate local abbreviation axioms within the proof scope.

| Mizar Source | FOL Encoding |
| --- | --- |
| `deffunc F(x be T) -> U equals t;` | `∀x. (is_T(x) → F(x) = t)` (local) |
| `defpred P(x be T) means φ;` | `∀x. (is_T(x) → (P(x) ↔ φ))` (local) |

### 15.11.4 Assumptions

Assumptions add antecedents to the current proof context.

| Mizar Source | FOL Encoding |
| --- | --- |
| `assume φ;` | Adds `φ` as antecedent: goal becomes `φ → ψ` |
| `assume that φ₁ and φ₂;` | Adds `φ₁ ∧ φ₂` as antecedent: goal becomes `φ₁ ∧ φ₂ → ψ` |
| `given x be T such that ψ;` | Existential instantiation: `∃x. (is_T(x) ∧ ψ)` → Skolem constant `c` with `is_T(c) ∧ ψ[x/c]` |
| `consider x be T such that ψ by J;` | Justified `∃x. (is_T(x) ∧ ψ)` → Skolem constant `c` |

### 15.11.5 Conclusions

| Mizar Source | FOL Encoding |
| --- | --- |
| `thus φ by J;` | Proves `φ` using justification `J` |
| `hence φ;` | Proves `φ` using preceding statement + `J` |
| `take t;` | Existential witness: instantiate `∃x. ψ` with `ψ[x/t]` |

### 15.11.6 Type Management

| Mizar Source | FOL Encoding |
| --- | --- |
| `reconsider x as T by J;` | Proves `is_T(x)` using justification `J` |
| `reconsider y = t as T by J;` | Introduces `y = t` and proves `is_T(t)` using `J` |

### 15.11.7 Proof Organization

| Mizar Source | FOL Encoding |
| --- | --- |
| `A1: now assume φ; thus ψ; end;` | `A1` ≡ `φ → ψ` |
| `per cases by J; case φ₁; ... case φₙ;` | `J` proves `φ₁ ∨ ... ∨ φₙ`; goal must be proved under each `φᵢ` |
| `a = b by J1 .= c by J2;` | `a = b` (by `J1`) ∧ `b = c` (by `J2`) → `a = c` (by transitivity) |

**Composite example:**

```mizar
theorem Th1:
  for n being Nat holds n + 0 = n
```

FOL encoding:

```
∀n. (is_Nat(n) → n + 0 = n)
```

**Proof encoding example:**

```mizar
theorem Th2:
  for x being Real st x > 0 holds x^2 > 0
proof
  let x be Real;
  assume A1: x > 0;
  thus x^2 > 0 by A1, Square_positive;
end;
```

FOL encoding:

```
∀x. (is_Real(x) → (x > 0 → x² > 0))
```

The proof obligation at the `thus` step is:

```
is_Real(x), x > 0  ⊢  x² > 0    (justified by A1, Square_positive)
```

## 15.12 Complete Syntax (EBNF)

Summary of all statement-related syntax from this chapter.

```ebnf
(* === Main Statement Categories === *)
statement             ::= [ "then" ] linkable_statement
                        | diffuse_statement ;

linkable_statement    ::= compact_statement
                        | choice_statement
                        | type_changing_statement
                        | iterative_equality ;

(* === Variable and Constant Introduction === *)
generalization               ::= "let" variable_list [ qualification ] [ "such" conditions ] ";" ;
constant_definition          ::= "set" identifier "=" term_expression ";" ;
inline_functor_definition    ::= "deffunc" identifier "(" [ typed_params ] ")" "->" type_expression
                                 "equals" term_expression ";" ;
inline_predicate_definition  ::= "defpred" identifier "(" [ typed_params ] ")" "means" formula ";" ;
typed_params                 ::= typed_param { "," typed_param } ;
typed_param                  ::= identifier ( "being" | "be" ) type_expression ;

(* === Assumptions === *)
assumption                   ::= single_assumption
                               | collective_assumption
                               | existential_assumption ;
single_assumption            ::= "assume" proposition ";" ;
collective_assumption        ::= "assume" conditions ";" ;
existential_assumption       ::= "given" variable_list [ qualification ] [ "such" conditions ] ";" ;
choice_statement             ::= "consider" identifier qualification "such" conditions
                                 simple_justification ";" ;

(* === Conclusions === *)
conclusion                   ::= ( "thus" | "hence" ) proposition justification ";"
                               | diffuse_conclusion ;
diffuse_conclusion           ::= "hereby" reasoning "end" ;
exemplification              ::= "take" example ";" ;
example                      ::= term_expression | identifier "=" term_expression ;

(* === Type Management === *)
type_changing_statement      ::= "reconsider" reconsider_item "as" type_expression
                                 simple_justification ";" ;
reconsider_item              ::= identifier | identifier "=" term_expression ;

(* === Structured Statements === *)
compact_statement            ::= proposition justification ";" ;
iterative_equality           ::= [ label_identifier ":" ] term_expression "=" term_expression
                                 simple_justification { ".=" term_expression simple_justification } ";" ;
diffuse_statement            ::= [ label_identifier ":" ] "now" reasoning "end" ;

(* === Case Analysis === *)
case_reasoning               ::= [ "then" ] "per" "cases" simple_justification ";"
                                 ( case_list | suppose_list ) ;
case_list                    ::= case_item { case_item } ;
suppose_list                 ::= suppose_item { suppose_item } ;
case_item                    ::= "case" ( proposition | conditions ) ";" reasoning "end" ;
suppose_item                 ::= "suppose" ( proposition | conditions ) ";" reasoning "end" ;

(* === Supporting Rules === *)
proposition                  ::= [ label_identifier ":" ] formula ;
conditions                   ::= "that" proposition { "and" proposition } ;
variable_list                ::= identifier { "," identifier } ;
qualification                ::= ( "being" | "be" ) type_expression ;

(* === Justification === *)
justification                ::= simple_justification | proof ;
simple_justification         ::= [ "by" references ] ;
proof                        ::= "proof" reasoning "end" ;

references                   ::= reference { "," reference } ;
reference                    ::= identifier [ template_args ]
                               | qualified_reference [ template_args ] ;
qualified_reference          ::= namespace_path "." identifier ;
namespace_path               ::= identifier { "." identifier } ;
template_args                ::= "[" template_arg { "," template_arg } "]" ;
template_arg                 ::= term_expression | formula | type_expression ;

(* For formula syntax, see Chapter 14 (Formulas) *)
(* For type_expression syntax, see Chapter 3 (Type System) *)
(* For term_expression syntax, see Chapter 13 (Term Expressions) *)
```

