# 4. Type System

- [4. Type System](#4-type-system)
  - [4.1. Introduction to Mizar's Type System](#41-introduction-to-mizars-type-system)
    - [4.1.1. Overview of Mizar's Type System](#411-overview-of-mizars-type-system)
    - [4.1.2. Key Concepts](#412-key-concepts)
    - [4.1.3. Relation to First-Order Logic](#413-relation-to-first-order-logic)
    - [4.1.4. Design Philosophy](#414-design-philosophy)
  - [4.2. Basic Types and Type Declarations](#42-basic-types-and-type-declarations)
    - [4.2.1. Built-in Types](#421-built-in-types)
    - [4.2.2. Syntax for Type Declarations](#422-syntax-for-type-declarations)
  - [4.3. Structures](#43-structures)
    - [4.3.1. Concept and Purpose of Structures](#431-concept-and-purpose-of-structures)
    - [4.3.2. Syntax for Defining Structures](#432-syntax-for-defining-structures)
    - [4.3.3. Inheritance Mechanisms](#433-inheritance-mechanisms)
    - [4.3.4. Multiple Inheritance and Diamond Inheritance](#434-multiple-inheritance-and-diamond-inheritance)
    - [4.3.5. Consistency Checks for Inheritance](#435-consistency-checks-for-inheritance)
    - [4.3.6. Examples](#436-examples)
  - [4.4. Attributes](#44-attributes)
    - [4.4.1. Definition and Purpose of Attributes](#441-definition-and-purpose-of-attributes)
    - [4.4.2. Syntax for Declaring and Using Attributes](#442-syntax-for-declaring-and-using-attributes)
    - [4.4.3. Clustering Mechanism](#443-clustering-mechanism)
    - [4.4.4. Examples](#444-examples)
  - [4.5. Modes](#45-modes)
    - [4.5.1. Definition and Purpose of Modes](#451-definition-and-purpose-of-modes)
    - [4.5.2. Syntax for Declaring and Using Modes](#452-syntax-for-declaring-and-using-modes)
    - [4.5.3. Relationship between Modes and Structures](#453-relationship-between-modes-and-structures)
    - [4.5.4. Examples](#454-examples)
  - [4.6. Type Inference and Checking](#46-type-inference-and-checking)
    - [4.6.1. Automatic Type Conversion Mechanisms](#461-automatic-type-conversion-mechanisms)
    - [4.6.2. Type Checking Process and Rules](#462-type-checking-process-and-rules)
    - [4.6.3. Resolving Ambiguities in Type Inference](#463-resolving-ambiguities-in-type-inference)
    - [4.6.4. Best Practices](#464-best-practices)

## 4.1. Introduction to Mizar's Type System

### 4.1.1. Overview of Mizar's Type System

Mizar's type system is a sophisticated feature that forms the backbone of its formal mathematical language. Unlike many other proof assistants, Mizar's types are not part of the logical foundation of the system. Instead, Mizar is based on untyped set theory, and its type system can be understood as a layer of "soft typing" built on top of this foundation.

Key characteristics of Mizar's type system include:

1. **Soft Types**: Mizar's types are essentially syntactic constructs. They guide the writing and checking of mathematical statements but do not intrude into the underlying logical foundation of the system.

2. **Set-Theoretic Foundation**: All Mizar expressions are ultimately about sets. The types in Mizar can be thought of as predicates that classify these sets.

3. **Type Checking as Proof Obligation Generation**: When Mizar performs type checking, it generates proof obligations in first-order logic. These obligations, if proven, ensure the type correctness of the mathematical statements.

### 4.1.2. Key Concepts

Several key concepts form the foundation of Mizar's type system:

1. **Radix Types**: These are the basic types in Mizar, such as `set` (the root type) or user-defined types like `integer` (for integers).

2. **Attributes**: These are type modifiers that can be applied to radix types. For example, `positive` and `negative` could be attributes applied to the `integer` type.

3. **Modes**: These are type constructors that define new types based on existing ones. They allow for more abstract type definitions and can be dependent.

4. **Structures**: These are composite types that group related data and properties, similar to record types in other systems.

5. **Clusters**: These are mechanisms for declaring relationships between types and attributes, such as subset relationships or attribute implications.

### 4.1.3. Relation to First-Order Logic

The relationship between Mizar's type system and first-order logic is central to its design:

1. **Types as Predicates**: Each type in Mizar corresponds to a predicate in first-order logic. For example, a type `T` is equivalent to a predicate `is_T(x)` in the underlying logic.

2. **Subtyping as Implication**: When one type is a subtype of another in Mizar, this relationship is represented as an implication in first-order logic. For instance, if `S` is a subtype of `T`, this is equivalent to the formula `∀x(is_S(x) ⇒ is_T(x))`.

3. **Type Erasure**: All type information in Mizar can be erased, resulting in untyped first-order logic formulas. This erasure process demonstrates that types in Mizar are not foundational to its logical system.

### 4.1.4. Design Philosophy

The design of Mizar's type system is guided by several key principles:

1. **Mathematical Intuitiveness**: The type system aims to closely align with mathematical thinking, allowing mathematicians to express concepts in a familiar way.

2. **Formal Rigor**: While intuitive, the system maintains strict formal semantics, ensuring that all expressions are unambiguous and logically sound.

3. **Expressiveness**: The type system is designed to handle a wide range of mathematical structures, from simple number systems to complex algebraic structures.

4. **Efficiency**: The type system is designed to allow for efficient type checking and inference, balancing expressiveness with practical implementation concerns.

5. **Set-Theoretic Foundation**: The type system is built on top of set theory, which allows for a clear separation between the type system and the underlying logical foundation.

By adhering to these principles, Mizar's type system provides a powerful tool for formalizing mathematics, striking a balance between intuitive expression and formal precision, while maintaining a clear connection to classical first-order logic and set theory. For more details, please refer to Freek Wiedijk (2007) [^FRE2007].

[^FRE2007]: Freek Wiedijk. [Mizar’s soft type system](https://cs.ru.nl/F.Wiedijk/mizar/miztype.pdf). 20th International Conference on Theorem Proving in Higher Order Logics (TPHOLs 2007), LNCS vol 4732 pp. 383-399. (2007)

## 4.2. Basic Types and Type Declarations

### 4.2.1. Built-in Types

Mizar's type system is built upon a foundation of basic types. In recent versions of the Mizar Mathematical Library (MML), the basic type hierarchy now includes:

1. **object**: The root type, representing all objects in the Mizar universe.
2. **set**: A subtype of `object`, representing mathematical sets.

The introduction of `object` as the root type allows for a distinction between primitive sets and other objects in the Mizar universe. `object` includes structural types defined by using `struct` keyword.

### 4.2.2. Syntax for Type Declarations

In Mizar, type declarations are made using specific keywords and constructs. Here are the main ways to declare and use types:

1. **Structure Definitions**

    Structures are used to define complex types with multiple fields:

    ```mizar
    definition
      struct Point2d where
        field x -> Real;
        field y -> Real;
      end
    end
    ```

2. **Attribute Definitions**

    Attributes are used to refine types:

    ```mizar
    definition
      let i be Integer;
      attr i is even means
      2 divides i;
    end;
    ```

3. **Mode Definitions**

    Modes are used to introduce new types:

    ```mizar
    definition
      mode Integer is integer Number;
    end;
    ```

    Modes and structures are collectively referred to as radix-types. These form the foundation for defining new types in the system.

4. **Type Expressions**

   Types can be combined and refined using various constructs:

   - Attribute application: `A T` (e.g., `positive Integer`)
   - Dependent types: `M of T` (where `M` is a mode that depends on `T`)

5. **Variable Declarations**

   Variables are declared with their types:

   ```mizar
   let n be positive Integer;
   let I be set;
   let f be Group-Family of I;
   ```

## 4.3. Structures

### 4.3.1. Concept and Purpose of Structures

### 4.3.2. Syntax for Defining Structures

### 4.3.3. Inheritance Mechanisms

### 4.3.4. Multiple Inheritance and Diamond Inheritance

### 4.3.5. Consistency Checks for Inheritance

### 4.3.6. Examples

## 4.4. Attributes

### 4.4.1. Definition and Purpose of Attributes

### 4.4.2. Syntax for Declaring and Using Attributes

### 4.4.3. Clustering Mechanism

### 4.4.4. Examples

## 4.5. Modes

### 4.5.1. Definition and Purpose of Modes

### 4.5.2. Syntax for Declaring and Using Modes

### 4.5.3. Relationship between Modes and Structures

### 4.5.4. Examples

## 4.6. Type Inference and Checking

### 4.6.1. Automatic Type Conversion Mechanisms

### 4.6.2. Type Checking Process and Rules

### 4.6.3. Resolving Ambiguities in Type Inference

### 4.6.4. Best Practices


