# 10. Functors

- [10. Functors](#10-functors)
  - [10.1 Overview and Syntax](#101-overview-and-syntax)
  - [10.2 Functors vs Predicates](#102-functors-vs-predicates)
  - [10.3 Definition Styles: `equals` vs `means`](#103-definition-styles-equals-vs-means)
  - [10.4 Partial Functions and `assume`](#104-partial-functions-and-assume)
  - [10.5 Dependent Return Types](#105-dependent-return-types)
  - [10.6 Correctness Conditions](#106-correctness-conditions)
    - [10.6.1 Functor Properties](#1061-functor-properties)
  - [10.7 Functor Redefinition](#107-functor-redefinition)
  - [10.8 Notation Styles](#108-notation-styles)
  - [10.9 Operator Precedence and Associativity](#109-operator-precedence-and-associativity)
  - [10.10 Symbol Resolution and Imports](#1010-symbol-resolution-and-imports)
  - [10.11 Logic Encoding Details](#1011-logic-encoding-details)
  - [10.12 Complete Syntax (EBNF)](#1012-complete-syntax-ebnf)

## 10.1 Overview and Syntax

Functors introduce symbolic functions that map typed inputs to typed outputs. Each functor has a name (label), a pattern, a return type, and a definition body.

**Syntax (EBNF)**:

```ebnf
func_def         ::= "func" label ":" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";" ;
label            ::= identifier ;
func_pattern     ::= [ loci ] functor_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
functor_symbol   ::= identifier | symbolic_func ;
symbolic_func    ::= symbol_char+ ;
type_expression  ::= attribute_chain radix_type ;
```

**Example**:

```mizar
definition
  let X, Y be set;
  func UnionDef: X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end;
```

Functors can be:

* **User-defined**: declared with `func` and `means` or `equals`
* **Overloaded**: disambiguated by parameter types

Key characteristics:
* `it` denotes the return value in `means` definitions
* Return type is specified after `->`
* Functor symbols can be arbitrary non-whitespace character sequences
* Lexical analysis follows the longest-match rule

> [!NOTE]
> For **inline functor definitions** within proofs (`deffunc`), see [Chapter 15 (Statements), §15.2.3](./15.statements.md#1523-inline-function-definition-deffunc).

## 10.2 Functors vs Predicates

Functors and predicates are both user-defined symbols, but serve different purposes:

| Aspect | Functors (`func`) | Predicates (`pred`) |
| --- | --- | --- |
| **Purpose** | Compute and return values | Express boolean relations |
| **Return type** | Any type (specified after `->`) | Always boolean (true/false) |
| **Syntax** | `x + y`, `f(x)`, `X \/ Y` | `x c= y`, `a divides b` |
| **Definition keyword** | `equals` or `means` | `means` only |
| **Correctness** | Requires existence/uniqueness for `means` | No existence/uniqueness needed |

**When to use functors**:
- Computing values: `x + y`, `card X`
- Building structures: `X \/ Y`, `[: X, Y :]`
- Defining mathematical operations

**When to use predicates**:
- Testing conditions: `x c= y`
- Defining relations: `a divides b`
- Expressing properties in formulas

**Example comparison**:

```mizar
:: As a functor (returns a value)
definition
  let x, y be Real;
  func SumDef: x + y -> Real equals ...;
end;

:: As a predicate (returns boolean)
definition
  let x, y be Real;
  pred LessOrEqualDef: x <= y means x < y or x = y;
end;

:: Functors are used in term expressions
set z = x + y;

:: Predicates are used in formulas
assume x <= y;
```

> [!NOTE]
> Detailed predicate syntax and semantics are defined in [Chapter 9 (Predicates)](./09.predicates.md).

## 10.3 Definition Styles: `equals` vs `means`

Mizar supports two styles of functor definitions:

### 10.3.1 Explicit Definition (`equals`)

Provides an explicit value. The system considers the functor well-defined by construction, so no additional proofs are needed.

```mizar
definition
  let n be Nat;
  func DoubleDef: twice(n) -> Nat equals 2 * n;
end;

definition
  let X be set;
  func PowerSetDef: power_set(X) -> set equals
    { Y where Y is set : Y c= X };
end;            
```

### 10.3.2 Implicit Definition (`means`)

Specifies the defining condition for the result, using `it` as a placeholder. This style requires the user to prove that a unique such result exists.

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func DivDef: x / y -> Real means it * y = x;
  existence
  proof
    :: Goal (auto-generated): ex z being Real st z * y = x
    ...;
  end;
  uniqueness
  proof
    :: Goal (auto-generated): for z1, z2 being Real st
    ::   z1 * y = x & z2 * y = x holds z1 = z2
    ...;
  end;
end;

definition
  let G be Group;
  func IdentityDef: 1_G -> Element of G means
    for a being Element of G holds it * a = a & a * it = a;
  existence
  proof
    :: Goal: ex e being Element of G st
    ::   for a being Element of G holds e * a = a & a * e = a
    ...;
  end;
  uniqueness
  proof
    :: Goal: for e1, e2 being Element of G st
    ::   (for a being Element of G holds e1 * a = a & a * e1 = a) &
    ::   (for a being Element of G holds e2 * a = a & a * e2 = a)
    ::   holds e1 = e2
    ...;
  end;
end;
```

**When to use each style**:

| Style | Use when... | Example |
| --- | --- | --- |
| `equals` | Value can be computed directly | `twice(n) equals 2 * n` |
| `means` | Value is characterized by properties | `x / y means it * y = x` |

## 10.4 Partial Functions and `assume`

`assume` clauses constrain the domain of definition:

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func PartialDivDef: x / y -> Real means it * y = x;
  existence
  proof ... end;
  uniqueness
  proof ... end;
end;

definition
  let f be Function, x be object;
  assume x in dom f;
  func ApplyDef: f . x -> object equals f(x);
end;
```

**Semantics**:
* Outside the assumed domain, the result is undefined
* Calls to partial functors require proof that preconditions hold

> [!TIP]
> It is recommended to encode preconditions into argument types when possible. For example, require `y` to be a `non zero Real` instead of using `assume y <> 0`. This improves clarity and reduces verification burden.

## 10.5 Dependent Return Types

Return types can depend on input values:

```mizar
definition
  let G be Group;
  func CenterDef: center G -> Subgroup of G means
    for a being Element of it holds
      for b being Element of G holds a * b = b * a;
end;

definition
  let X be set;
  func IdDef: id X -> Function of X, X equals
    { [x, x] where x is Element of X : x in X };
end;
```

Multiple dependencies are supported:

```mizar
definition
  let G be Group;
  let H, K be Subgroup of G;
  func SubgroupProdDef: H * K -> Subset of G equals
    { h * k where h is Element of H, k is Element of K };
end;
```

## 10.6 Correctness Conditions

Unlike predicates, functors have strict correctness requirements:

| Condition | Applies to | Description |
| --- | --- | --- |
| **Existence** | `means` only | Prove that at least one value satisfies the condition |
| **Uniqueness** | `means` only | Prove that at most one value satisfies the condition |
| **Well-formedness** | Both | The defining expression/formula must be syntactically valid |
| **Type correctness** | Both | All terms must be type-correct |
| **Definedness** | `assume` | Outside the assumed domain, the functor is undefined |

**Syntax**:

```ebnf
correctness_conditions ::= [ existence_block ] [ uniqueness_block ] ;
existence_block        ::= "existence" proof_or_refs ;
uniqueness_block       ::= "uniqueness" proof_or_refs ;
proof_or_refs          ::= proof_block | "by" references ";" ;
```

**Example with proofs**:

```mizar
definition
  let G be Group;
  func InverseDef: a" -> Element of G means it * a = 1_G & a * it = 1_G;
  existence
  proof
    :: Goal (auto-generated): ex b being Element of G st b * a = 1_G & a * b = 1_G
    consider b being Element of G such that
      A1: b * a = 1_G & a * b = 1_G by group_inverse_exists;
    take b;
    thus b * a = 1_G & a * b = 1_G by A1;
  end;
  uniqueness
  proof
    :: Goal (auto-generated): for b1, b2 being Element of G st
    ::   (b1 * a = 1_G & a * b1 = 1_G) & (b2 * a = 1_G & a * b2 = 1_G)
    ::   holds b1 = b2
    let b1, b2 be Element of G;
    assume A1: b1 * a = 1_G & a * b1 = 1_G;
    assume A2: b2 * a = 1_G & a * b2 = 1_G;
    b1 = b1 * 1_G by group_identity
       .= b1 * (a * b2) by A2
       .= (b1 * a) * b2 by group_assoc
       .= 1_G * b2 by A1
       .= b2 by group_identity;
    hence b1 = b2;
  end;
end;
```

> [!NOTE]
> Functors defined via `equals` are well-defined by construction and do not require existence or uniqueness proofs.

### 10.6.1 Functor Properties

Functors can declare algebraic properties that the verifier uses for automatic equational reasoning. Each property requires a proof obligation.

**Syntax (EBNF):**

```ebnf
func_property ::= ( "commutativity" | "idempotence"
                | "involutiveness" | "projectivity" ) justification ";" ;
```

**Properties and FOL Obligations:**

For a binary functor `F(a, b)` or unary functor `F(a)` with arguments of type T:

| Property | Arity | FOL Obligation | Verifier Effect |
|---|---|---|---|
| `commutativity` | Binary | `∀a,b:T. F(a,b) = F(b,a)` | Auto-reorders arguments for matching |
| `idempotence` | Binary | `∀a:T. F(a,a) = a` | Simplifies `F(x,x)` to `x` |
| `involutiveness` | Unary | `∀a:T. F(F(a)) = a` | Simplifies double application |
| `projectivity` | Unary | `∀a:T. F(F(a)) = F(a)` | Simplifies repeated application |

**Example:**

```mizar
definition
  let X, Y be set;
  func UnionDef: X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
  existence proof ... end;
  uniqueness proof ... end;
  commutativity
  proof
    let A, B be set;
    thus A \/ B = B \/ A by mml.set.Union_commutative;
  end;
  idempotence
  proof
    let A be set;
    thus A \/ A = A by mml.set.Union_idempotent;
  end;
end;

definition
  let x be Real;
  func NegDef: - x -> Real equals 0 - x;
  involutiveness
  proof
    let a be Real;
    thus - (- a) = a by mml.number.real.Neg_involutive;
  end;
end;

definition
  let x be Real;
  func AbsDef: |.x.| -> Real means
    (x >= 0 implies it = x) & (x < 0 implies it = -x);
  existence proof ... end;
  uniqueness proof ... end;
  projectivity
  proof
    let a be Real;
    thus |.|.a.|.| = |.a.| by mml.number.real.Abs_projective;
  end;
end;
```

> [!NOTE]
> Properties are placed inside the `definition ... end;` block, after the defining formula and correctness conditions.

## 10.7 Functor Redefinition

Existing functors can be redefined for more specific types to provide:
- Narrower return types
- Simplified defining conditions
- Type-specific optimizations

**Syntax**:

```ebnf
redefine_func  ::= "redefine" "func" label ":" func_pattern "->" type_expression
                   ( "means" formula | "equals" term_expression ) ";"
                   "coherence" [ "with" label ] proof_or_refs ";" ;
```

**Example**:

```mizar
definition
  let x be Real;
  func AbsGeneral: |.x.| -> Real means
    (x >= 0 implies it = x) & (x < 0 implies it = -x);
end;

definition
  let x be non negative Real;
  redefine func AbsNonNeg: |.x.| -> non negative Real equals x;
  coherence with AbsGeneral
  proof
    :: Goal (auto-generated): |.x.| = x & |.x.| is non negative Real
    :: i.e., the original definition satisfies the new equals clause,
    ::       and the result has the refined return type
    thus |.x.| = x by AbsGeneral;  :: x >= 0 implies |.x.| = x
    thus |.x.| is non negative Real;  :: x is non negative, so |.x.| = x is non negative
  end;
end;
```

Redefinition requirements:

* Use `redefine func`
* The redefined return type must be a subtype of the original
* Provide a `coherence` proof showing equivalence under the new parameter types
* All previous uses must remain type-safe

## 10.8 Notation Styles

Supported notations:

| Notation | Pattern | Example |
| --- | --- | --- |
| **Infix** | `x symbol y` | `x + y`, `X \/ Y` |
| **Prefix** | `symbol x` | `- x`, `card X` |
| **Postfix** | `x symbol` | `n !`, `f "` |
| **Circumfix (Bracket)** | `left x right` | `[: X, Y :]`, `|. x .|` |
| **Functional** | `symbol ( args )` | `sin(x)`, `max(a, b)` |

**Examples**:

```mizar
:: Infix
func AddDef: x + y -> Real equals ...;
func UnionDef: X \/ Y -> set means ...;

:: Prefix
func NegDef: - x -> Real equals ...;
func CardDef: card(X) -> Cardinal means ...;

:: Postfix
func FactorialDef: n ! -> Nat equals Product(id(Seg n));
func InverseDef: f " -> Function means ...;

:: Circumfix (bracket notation)
func CartesianDef: [: X, Y :] -> set means ...;
func AbsDef: |. x .| -> Real means ...;

:: Functional (parenthesized)
func SinDef: sin(x) -> Real means ...;
func MaxDef: max(a, b) -> Real equals ...;
```

## 10.9 Operator Precedence and Associativity

Declared via annotations:

```mizar
@symbol_precedence(+, 80, left_associative);
@symbol_precedence(*, 90, left_associative);
@symbol_precedence(^, 95, right_associative);
```

**Properties**:

| Property | Values | Default |
| --- | --- | --- |
| **Precedence** | 0–255 | 64 |
| **Associativity** | `left_associative`, `right_associative`, `non_associative` | `non_associative` |

**Associativity semantics**:

| Type | Effect | Example |
| --- | --- | --- |
| `left_associative` | Groups left-to-right | `a + b + c` → `(a + b) + c` |
| `right_associative` | Groups right-to-left | `a ^ b ^ c` → `a ^ (b ^ c)` |
| `non_associative` | Requires explicit parentheses | `a < b < c` → error |

**Conflict handling**:
* Precedence must be consistent across modules
* Consistency is checked during module linking
* Conflicts result in descriptive link-time errors

## 10.10 Symbol Resolution and Imports

User-defined functors are made available by importing their defining modules:

```mizar
import algebra.group as grp;
let G be set;
let x = grp.center(G);
```

Conflicts between names are resolved by:

* **Longest-match rule** during lexing
* **Qualified names** when needed

**Example**:

```mizar
import geometry.vector;
import linear_algebra.vector as linalg;

:: Use qualified names to disambiguate
let v = geometry.vector.zero;
let w = linalg.zero;
```

> [!NOTE]
> For synonyms of functors, see [Chapter 11 (Symbol Management), §11.1](./11.symbol_management.md#111-synonyms-and-antonyms).

## 10.11 Logic Encoding Details

This section describes how functors map to First-Order Logic.

### 10.11.1 Functors as FOL Function Symbols

Each user-defined functor is encoded as an FOL function symbol.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x + y` | `add(x, y)` |
| `card X` | `card(X)` |
| `[: X, Y :]` | `cartesian_product(X, Y)` |
| `f . x` | `apply(f, x)` |

### 10.11.2 `equals` Definitions as Equations

A functor defined via `equals` generates a universally quantified equation:

```
func twice(n) equals 2 * n
⇒  forall n (twice(n) = 2 * n)
```

More generally:

```
func F(x1, ..., xn) equals t
⇒  forall x1, ..., xn (F(x1, ..., xn) = t)
```

### 10.11.3 `means` Definitions as Unique Existence

A functor defined via `means` generates axioms asserting unique existence:

```
func x / y means it * y = x
⇒  forall x, y (
     exists! z (z * y = x) ∧
     div(x, y) * y = x
   )
```

The `it` placeholder is replaced by the function application in the generated axiom.

### 10.11.4 Typed Parameters as Guards

Type constraints on parameters are encoded as antecedents:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x, y be Real; func x + y -> Real` | `forall x, y (is_Real(x) ∧ is_Real(y) → is_Real(add(x, y)))` |
| `let G be Group; func center(G) -> Subgroup of G` | `forall G (is_Group(G) → is_Subgroup(center(G), G))` |

### 10.11.5 Domain Restrictions (`assume`)

When a functor uses `assume`, the condition becomes an additional antecedent:

```
let x, y be Real;
assume y <> 0;
func x / y -> Real means ...

⇒  forall x, y (is_Real(x) ∧ is_Real(y) ∧ y ≠ 0 → is_Real(div(x, y)) ∧ div(x, y) * y = x)
```

### 10.11.6 Return Type Encoding

The return type generates a type assertion for the result:

| Mizar Source | FOL Encoding |
| --- | --- |
| `func f(x) -> Nat` | `forall x (...preconditions... → is_Nat(f(x)))` |
| `func g(X) -> non empty set` | `forall X (...preconditions... → is_set(g(X)) ∧ ¬is_empty(g(X)))` |

### 10.11.7 Redefinition Encoding

A redefinition generates an equivalence axiom under restricted types:

```
redefine func |.x.| -> non negative Real equals x;
⇒  forall x (
     is_Real(x) ∧ is_non_negative(x)
     → abs(x) = x ∧ is_non_negative(abs(x))
   )
```

## 10.12 Complete Syntax (EBNF)

Summary of functor-related syntax.

```ebnf
(* Functor Definition *)
func_def         ::= "func" label ":" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";"
                     [ correctness_conditions ] ;
label            ::= identifier ;
func_pattern     ::= [ loci ] functor_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
functor_symbol   ::= identifier | symbolic_func ;
symbolic_func    ::= symbol_char+ ;

(* Correctness Conditions *)
correctness_conditions ::= [ existence_block ] [ uniqueness_block ] ;
existence_block  ::= "existence" proof_or_refs ;
uniqueness_block ::= "uniqueness" proof_or_refs ;
proof_or_refs    ::= proof_block | "by" references ";" ;

(* Functor Properties *)
func_property    ::= ( "commutativity" | "idempotence"
                   | "involutiveness" | "projectivity" ) justification ";" ;

(* Functor Redefinition *)
redefine_func    ::= "redefine" "func" label ":" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";"
                     "coherence" [ "with" label ] proof_or_refs ";" ;

(* Functor Application - see Chapter 13 *)
functor_application ::= [ functor_loci ] functor_symbol [ functor_loci ]
                      | left_bracket loci right_bracket ;
functor_loci       ::= locus | "(" loci ")" ;
loci               ::= locus { "," locus } ;

(* Operator Precedence Annotation *)
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value ::= integer ;  (* 0-255 *)
associativity    ::= "left_associative" | "right_associative" | "non_associative" ;
```
