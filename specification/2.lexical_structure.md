# 2. Lexical Structure

## 2.1 Characters and Encoding

Mizar uses a clearly defined character set to accurately represent mathematical concepts while maintaining high readability and searchability of the code.

1. Character Encoding:
    - Mizar adopts Unicode UTF-8 encoding.
    - This allows for the representation of diverse languages and mathematical symbols within comments and specific annotations.

2. Usable Characters:
    - Code sections: ASCII characters only (alphanumeric characters and basic symbols)
    - Comments and specific annotations: Full Unicode character set (including extended Latin characters, Greek letters, mathematical symbols, etc.)

3. Handling of Special Characters:
    - Direct input of mathematical symbols is not allowed in code sections.
    - Direct use of mathematical symbols is only allowed within comments and specific annotations.

4. Control Characters:
    - Line breaks (LF: U+000A, CR: U+000D, or CRLF)
    - Tab (U+0009)
    - Use of other control characters is prohibited

5. Character Display:
    - The Mizar processing system assumes an environment capable of correctly displaying both ASCII and Unicode characters.
    - Appropriate fonts may be necessary for displaying Unicode characters in comments and annotations.

6. Input Methods:
    - Code sections: Standard ASCII input only
    - Comments and specific annotations:
        - Support for standard Unicode input methods
        - LaTeX-style input is also possible (e.g., \alpha for Î±)

7. Character Escaping:
    - Backslash (\\) is used for escaping special characters within string literals

8. Deprecated Characters:
    - Use of non-ASCII characters in code sections
    - Use of control characters (U+0000 - U+001F, U+007F) except for line breaks and tabs
    - Use of characters from the Private Use Area

This specification allows Mizar to maintain high searchability and readability of code while enabling rich mathematical expression through comments and specific annotations. By limiting code to ASCII characters, it ensures consistency and compatibility of the code, while the adoption of Unicode UTF-8 encoding maintains future extensibility.

## 2.2 Lexicon and Vocabularies

Mizar's lexical structure is defined by its lexicon, which consists of a set of tokens recognized by the Mizar lexical processor. This lexicon is composed of a basic lexicon and additional lexicons.

1. Basic Lexicon:  
The basic lexicon includes:
    - Reserved words (keywords)
    - Special symbols
    - Numerals
    - Identifiers

2. Additional Lexicons:
    - Additional lexicons are defined in constructors.
    - They introduce symbols for various mathematical concepts and structures.
    - Symbols are categorized into: mode symbols, function symbols, left or right function brackets, structure symbols, selector symbols, attribute symbols, and predicate symbols.

3. Symbol Overriding:
   - If an additional lexicon defines a symbol that forms a valid identifier, the symbol takes precedence over the identifier.

4. Lexicon Composition:
    - The complete lexicon of a Mizar article is the union of its basic lexicon and all imported additional lexicons by *import* declaration.

5. Lexicon Scope:
    - The lexicon is article-specific, allowing different articles to use different sets of symbols.

6. Lexicon Consistency:
    - The Mizar system ensures lexical consistency across imported symbols.
    - Conflicts between symbols are detected and reported during processing.

## 2.3 Reserved Words

Reserved words, also known as keywords, are predefined identifiers that have special meanings within the Mizar language. These words cannot be used as identifiers for other purposes in Mizar code.

1. List of Reserved Words:  
The following is the complete list of reserved words in Mizar:

    ```text
    according aggregate all and antonym are as associativity
    assume asymmetry attr
    be begin being by
    canceled case cases cluster coherence commutativity
    compatibility connectedness consider consistency constructors
    contradiction correctness
    def deffunc define definition definitions defpred do does
    end environ equals ex exactly existence extends
    for from func
    given
    hence hereby holds
    idempotence identify if iff implies involutiveness
    inherits irreflexivity is it let
    means mode
    non not notation notations now
    of or otherwise over
    per pred prefix projectivity proof provided
    qua
    reconsider reduce reducibility redefine reflexivity registration
    registrations requirements reserve
    sch scheme schemes section selector set sethood st struct
    such suppose symmetry synonym
    take that the then theorem theorems thesis thus to
    transitivity
    uniqueness
    vocabularies
    when where with wrt
    ```

2. Usage Rules:
    - Reserved words are case-sensitive and must be written exactly as shown.
    - They cannot be used as identifiers for variables, predicates, functors or other user-defined entities.
    - Some reserved words may have context-specific meanings or usages within Mizar constructs.

3. Synonyms:
    - `be` and `being` are synonyms and can be used interchangeably.
    - `hereby` is a shortcut for `thus now`.

4. Context-Specific Keywords:  
Some words have special meanings in specific contexts, but may be used as regular identifiers elsewhere. These include:
    - `it` (often used in definitions)
    - `thesis` (used in proof steps)

5. Best Practices:
    - Avoid using identifiers that are similar to reserved words to prevent confusion.
    - Be aware of the specific meanings and usages of reserved words in different contexts within Mizar.

6. Future Considerations:
    - As Mizar evolves, new reserved words may be introduced. Users should consult the latest documentation for any updates to this list.

## 2.4 Special Symbols

Special symbols in Mizar are non-alphanumeric characters or character combinations that have specific meanings within the language. These symbols are essential for constructing various syntactic structures in Mizar.

1. List of Special Symbols:
    The following is the complete list of special symbols in Mizar:

    ```text
    ,   ;   :   (   )   [   ]   {   }   =   &   ->
    .=   ...   $1   $2   $3   $4   $5   $6   $7   $8   $9   $10   (#   #)
    ```

2. Usage and Meanings:
    - `,` (comma): Used for separating items in lists or arguments.
    - `;` (semicolon): Typically used to end statements.
    - `:` (colon): Used in various contexts, such as label declarations.
    - `( )` (parentheses): Used for grouping expressions or arguments.
    - `[ ]` (square brackets): Typically used to enclose arguments in a user-defined predicate. Also used in templates.
    - `{ }` (curly braces): Typically used in Fraenkel operator and schema constructs.
    - `=` (equals sign): Used for equality comparisons and definitions.
    - `&` (ampersand): Typically used for logical AND operations.
    - `->` (arrow): Typically used to denote return types.
    - `.=` (dot-equals): Used in successive equality transformations.
    - `...` (ellipsis): Used to denote omitted parts in certain contexts.
    - `$1, $2, ..., $10`: Used for private definition parameters.
    - `(# #)` (hash parentheses): Typically used to enclose fields in a structure definition.

## 2.5 Numerals and Literals

Numerals and literals in Mizar are used to represent constant values directly in the code.

1. Numerals:
    - A numeral in Mizar is a sequence of digits starting with a non-zero digit:

        ```bnf
        Numeral = Non-Zero-Digit { 0 | Non-Zero-Digit } .
        Non-Zero-Digit = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 .
        ```

2. Integer Literals:
    - Integer literals are represented by numerals.
    - Mizar's type system will infer their types as `natural number`.

3. Floating-Point Literals:
    - Mizar does not have built-in floating-point literals.
    - Rational numbers are defined as `mode` in the MML.

4. String Literals:
    - Mizar does not have built-in string literals.

5. Boolean Literals:
    - Mizar does not have explicit boolean literals.
    - Logical values are typically represented through predicates.

6. Special Constants:
    - Mizar does not have built-in special constants.
    - Mathematical constants are typically defined as functors in the MML (e.g., `PI`, `exp`).

7. Best Practices:
    - Use numerals directly for small, specific integer values.
    - For larger numbers or repeated use, consider defining named constants.

8. Future Considerations:
    - In the future version, floating-point literals, string literals and boolean literals might be added.

## 2.6 Identifiers

Identifiers in Mizar are used to name various entities such as variables, predicates, functors, and other user-defined constructs.

1. Syntax:
    - An identifier is a sequence of ascii letters, digits, underscores (_), and apostrophes (').
    - It must not be a reserved word.
    - The case of letters is significant in Mizar identifiers.

        ```bnf
        Identifier = (Letter | "_") { Letter | Digit | "_" | "'" } .
        Letter = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z" .
        Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" .
        ```

2. Scope and Precedence:
    - If there exist same name identifiers within the same scope, the last declared identifier takes precedence.
    - In nested scopes, the identifier in the inner scope takes precedence over identifiers with the same name in outer scopes.
    - When an identifier conflicts with a symbol, the identifier takes precedence.

3. Conflict with Symbols:
    - Identifiers can have the same name as user-defined or imported symbols.
    - In such cases, the identifier overrides the symbol within its scope.
    - This allows for local redefinition or shadowing of mathematical symbols when necessary.

4. Warnings:
    - The lexical analyzer may issue warnings in cases where identifiers are duplicated or override symbols.
    - These warnings are intended to alert the user to potential naming conflicts or unintended symbol shadowing.

5. Best Practices:
    - Choose clear and meaningful names for identifiers.
    - Avoid overly long or cryptic identifiers.
    - Be consistent in naming conventions throughout your Mizar articles.
    - Consider using apostrophes for related concepts (e.g., x and x' for a value and its derivative).
    - Although identifiers can override symbols, it's generally recommended to avoid naming conflicts between identifiers and mathematical symbols to prevent confusion.
    - When overriding a symbol is necessary, consider using clear and descriptive names that indicate the purpose of the override.

## 2.7 Symbols

1. Types of Symbols:
    - Functor Symbols: Represent mathematical functions or operations.
    - Mode Symbols: Denote types of mathematical objects.
    - Attribute Symbols: Represent properties or characteristics of objects.
    - Predicate Symbols: Denote logical relations or properties.
    - Structure Symbols: Represent complex mathematical structures.
    - Selector Symbols: Used to access fields or properties of structures.

2. Symbol Definition:
    - Symbols are defined within Mizar articles using specific keywords:
        - `func`: for defining functors
        - `mode`: for defining modes
        - `attr`: for defining attributes
        - `pred`: for defining predicates
        - `struct`: for defining structures
    - Selectors are typically defined as part of structure definitions.

3. Symbol Usage:
    - Symbols can be used throughout the formalization once defined.
    - They can be imported from other articles and used in the current article.

4. Symbol Precedence:
    - When a symbol conflicts with a standard identifier, the identifier takes precedence.

5. Scope of Symbols:
    - Symbols have a global scope within the article where they are defined.
    - Imported symbols are available throughout the importing article.

6. Notation:
    - Symbols often use mathematical notation, which can include special characters when used in appropriate contexts (e.g., comments or annotations).

7. Restrictions on Symbol Names:
    - Symbol names must not conflict with reserved words (keywords) of Mizar.
    - Symbol names must not be the same as special symbols defined in Mizar.
    - Attempting to define a symbol with a name that conflicts with a reserved word or special symbol will result in a compilation error.

## 2.8 File Names and Module Structure

1. File Names:
    - Mizar file names are no longer restricted to 8 characters.
    - File names should be descriptive and reflect the content.
    - The file extension for Mizar source files is `.miz`.

2. Basic Module Structure:
    - Each `.miz` file represents a single module.
    - The namespace of a module aligns with its directory structure.
    - For example, `/math/algebra/group.miz` defines the `group` module in the `math.algebra` namespace.

3. Import System Overview:
    - Mizar uses a Python-inspired import system.
    - Modules can be imported using various syntax options (details in Chapter 3).
    - Imports allow access to definitions, theorems, and other elements from other modules.

4. Best Practices:
    - Use clear and descriptive names for files to indicate their content.
    - Organize related concepts into separate modules for better maintainability.
    - Use the namespace structure to create a logical hierarchy of mathematical concepts.
    - Document the purpose and contents of each module in comments at the beginning of the file.

5. Module Content:
    - Each module typically contains definitions, theorems, and proofs related to a specific mathematical concept or area.

For detailed information on modules, namespaces, and import directives, please refer to [Chapter 3: Modules and Namespaces](./3.modules_and_namespaces.md).

## 2.9 Comments and Documentation

1. Single-line Comments:
    - Begin with two colons `::` and continue to the end of the line.
    - It also works as an inline comment.
    - Example:

        ```mizar
        :: This is a single-line comment
        let x be Real; :: This is an inline comment
        ```

2. Multi-line Comments:
    - Begin with `::=` and end with `=::`.
    - Can span multiple lines.
    - Example:

        ```mizar
        ::= This is a multi-line comment
            It can include multiple lines of text
            as well as LaTeX formulas: $E = mc^2$
        =::
        theorem Einstein_Energy: ...
        ```

    - Note: The sequence `=::` within a multi-line comment will end the comment. If you need to use this sequence in your comment, consider adding a space (e.g., `= ::`) or using an alternative expression.

3. Documentation Comments:
    - Begin with three colons (`:::`).
    - Used for generating documentation.
    - Should be placed immediately before the construct they describe.
    - Example:

        ```mizar
        ::: The Pythagorean theorem states that $a^2 + b^2 = c^2$
        ::: where $a$ and $b$ are the lengths of the catheti and
        ::: $c$ is the length of the hypotenuse in a right triangle.
        theorem Pythagorean: ...
        ```

4. Unicode in Comments:
    - Comments support full Unicode character set.
    - Mathematical symbols and non-ASCII characters can be used freely in comments.

5. LaTeX in Comments:
    - LaTeX notation is supported within comments.
    - Useful for writing complex mathematical expressions.
    - Example:

        ```mizar
        ::= The integral formula:
            $ \int_0^1 x^2 dx = \frac{1}{3} $
        =::
        ```

6. Annotation Comments:
    - Special comments that provide metadata or instructions to the Mizar system.
    - Begin with `@` followed by a specific keyword.
    - Example

        ```mizar
        ::: @proof-sketch This proof proceeds by induction on $n$
        theorem Factorial_Positive: ...
        ```

## 2.10 Whitespace and Formatting

1. Whitespace Characters:
    - Space (U+0020)
    - Tab (U+0009)
    - Newline (LF: U+000A, CR: U+000D, or CRLF)

2. Whitespace Significance:
    - Whitespace is generally not significant in Mizar syntax.
    - Multiple consecutive whitespace characters are treated as a single space.
    - Whitespace is required to separate tokens where ambiguity might occur.

3. Indentation:
    - While not syntactically required, proper indentation improves code readability.
    - Recommended: Use 2 or 4 spaces for each indentation level.
    - Be consistent with indentation throughout your code.

4. Line Breaks:
    - Use line breaks to separate logical parts of your code.
    - Long statements can be broken into multiple lines for better readability.

5. Blank Lines:
    - Use blank lines to separate logical sections of your code.
    - A single blank line is usually sufficient.

6. Formatting Guidelines:
    - Place one space after commas and semicolons.
    - Place spaces around operators for better readability.
    - Align related statements for visual clarity.

7. Example of Formatted Code:

    ```mizar
    theorem Pythagorean:
      for a, b, c being Real st
        a > 0 & b > 0 & c > 0
      holds
        a^2 + b^2 = c^2 implies
        ex t being Triangle st
          t.leg1 = a & t.leg2 = b & t.hypotenuse = c
    proof
      let a, b, c be Real;
      assume A1: a > 0 & b > 0 & c > 0;
      assume A2: a^2 + b^2 = c^2;
      ...
    end;
    ```

8. Consistency:
    - Maintain consistent formatting throughout your Mizar articles.
    - Consider using an automated formatting tool if available.

9. Long Lines:
    - Try to keep lines under 80-100 characters for better readability.
    - Break long lines at logical points, such as after operators or commas.
    - The previous limit of 80 characters per line has been removed.

## 2.11 Lexical Preprocessing

Lexical preprocessing in Mizar is the initial stage of processing Mizar source code. It transforms the raw input text into a sequence of tokens that can be further processed by the parser. Due to the possibility of importing symbols from other files, Mizar's lexical analysis is context-sensitive.

1. Character Set Handling:
    - Mizar source files are expected to be in UTF-8 encoding.
    - Non-ASCII characters are only permitted in comments and specific annotations.
    - All other parts of the code must use ASCII characters.

2. Whitespace Handling:
    - Multiple consecutive whitespace characters are condensed into a single space.
    - Leading and trailing whitespace on each line is trimmed.
    - Blank lines are preserved for maintaining code structure.

3. Comment Removal:
    - Single-line comments (starting with `::`) are removed.
    - Multi-line comments (enclosed in `::=` and `=::`) are removed.
    - Documentation comments (starting with `:::`) are preserved for later processing.

4. Import Processing:
    - Before full tokenization, the preprocessor identifies and processes import statements.
    - Symbols from imported files are added to the current context.
    - This step makes the lexical analysis context-sensitive, as the set of valid symbols depends on the imports.

5. Tokenization:
    - With the import context established, the preprocessor identifies and separates individual tokens such as keywords, identifiers, numerals, operators, and symbols.
    - Tokens are classified according to Mizar's lexical rules and the current context.

6. Keyword and Reserved Word Recognition:
    - Keywords and reserved words are identified and treated as special tokens.
    - These cannot be used as identifiers or symbols.

7. Identifier and Symbol Recognition:
    - Identifiers are recognized based on Mizar's identifier rules (as described in [section 2.6](#26-identifiers)).
    - Symbols (functors, modes, attributes, predicates, structures, and selectors) are identified based on the current context, including imported symbols.
    - The preprocessor distinguishes between standard identifiers and those that might override symbols.

8. Numeral Processing:
    - Numeric literals are identified and classified according to Mizar's numeral rules.

9. Special Symbol Recognition:
    - Special symbols used in Mizar syntax are recognized.

10. Error Detection:
    - Lexical errors, such as invalid characters, malformed tokens, or attempts to use reserved words as identifiers or symbols, are detected.
    - Appropriate error messages are generated to assist in debugging.

11. Output:
    - The result of lexical preprocessing is a stream of classified tokens.
    - Each token includes information about its type (keyword, identifier, symbol, numeral, operator, etc.), value, and position in the source file.

12. Handling of Conflicts:
    - In cases where an identifier overrides a symbol, the preprocessor marks this for later stages of compilation to handle appropriately.

13. Context Sensitivity:
    - Due to the import mechanism, Mizar's lexical analyzer is context-sensitive.
    - The validity and interpretation of certain tokens (particularly symbols) depend on the imports and the current context.
    - This context sensitivity allows for flexible use of mathematical notation but requires careful handling in the lexical analysis phase.
    - Example: Consider two Mizar articles, A and B:
        - Article A:

            ```mizar
            definition
              let x, y be real;
              func x+*y -> real means ...;
              func x*+y -> real means ...;
              func x+ -> real means ...;
            end;
            ```

        - Article B:

            ```mizar
            import A;

            let x, y be real;
            x +* y      :: Application of imported infix operator +*
            x *+ y      :: Application of imported infix operator *+
            x +*+ y     :: Interpreted as x +* (+ y) by the longest match rule.
            x + *+ y    :: Interpreted as x + (*+ y)
                        :: Space insertion can enforce specific interpretation.
            x + (*+ y)  :: Parentheses also work to enforce specific interpretation.
            ```

        - Article C:

            ```mizar
            import A;

            definition
              let x, y be real;
              func x+*+y -> real means ...;  :: This defines a new symbol +*+
            end;

            let x, y be real;
            x +* y  :: Application of imported infix operator +*
            x *+ y  :: Application of imported infix operator *+
            x +*+ y :: Application of imported infix operator +*+
                    :: according to the longest match rule.
            ```
