# 7. Attributes

- [7. Attributes](#7-attributes)
  - [7.1. Definition and Purpose of Attributes](#71-definition-and-purpose-of-attributes)
  - [7.2. Syntax for Declaring Attributes](#72-syntax-for-declaring-attributes)
  - [7.3. Using Attributes](#73-using-attributes)
  - [7.4. Clustering Mechanism](#74-clustering-mechanism)
  - [7.5. Attribute Inheritance](#75-attribute-inheritance)
  - [7.6. Type Inference with Attributes](#76-type-inference-with-attributes)
  - [7.7. Dependent Attributes](#77-dependent-attributes)
  - [7.8. Attribute Redefinition](#78-attribute-redefinition)

## 7.1. Definition and Purpose of Attributes

Attributes are type modifiers that refine existing types by adding additional properties. They serve several key purposes in Mizar's type system:

1. **Type Refinement**: Attributes allow for the creation of subtypes by adding constraints to existing types.
2. **Property Expression**: They provide a way to express mathematical properties that objects of a given type may possess.
3. **Type Inference**: Through the clustering mechanism, attributes play a role in the type inference system.

## 7.2. Syntax for Declaring Attributes

The basic syntax for defining an attribute is:

```mizar
definition
  let T be Type;
  attr T is attribute_name means
    ... definition ...;
end
```

Key components of this syntax:

- `attr` keyword introduces an attribute definition
- `attribute_name` is the name of the new attribute
- `means` clause provides the defining property

Example from algebraic structures:

```mizar
definition
  let M be Magma;
  
  attr M is associative means
    for x, y, z be Element of M holds
    M.binop(M.binop(x,y),z) = M.binop(x,M.binop(y,z));

  attr M is unital means
    ex e be Element of M st
    for x be Element of M holds
    M.binop(x,e) = x & M.binop(e,x) = x;

  attr M is commutative means
    for x, y be Element of M holds
    M.binop(x,y) = M.binop(y,x);
end
```

Attributes can be defined for any type, including built-in types, structures, and modes:

```mizar
definition
  let X be set;
  attr X is empty means
    not ex x be object st x in X;
    
  attr X is finite means
    ex n be Nat st ex f be Function st
    dom f = Seg n & rng f = X & f is one-to-one;
end

definition
  let n be Integer;
  attr n is even means
    ex k be Integer st n = 2*k;
    
  attr n is odd means
    ex k be Integer st n = 2*k + 1;
end
```

## 7.3. Using Attributes

Attributes can be used in several ways:

1. **Type Qualification**:
  ```mizar
  let G be associative unital Magma;
  let n be positive even Integer;
  let X be non empty finite set;
  ```

2. **Type Testing**:
  ```mizar
  assume M is commutative;
  if n is odd then ... else ...;
  ```

3. **Attribute Negation**:
  ```mizar
  let M be non empty Magma;
  let n be non zero Integer;
  ```

4. **Type-Qualified Attributes**:
  When dealing with structures that inherit from multiple sources, you can specify attributes in the context of specific types:
  ```mizar
  let R be Ring;
  assume R is AddLoopStr.commutative;    :: Commutativity for addition
  assume R is MulLoopStr.associative;    :: Associativity for multiplication
  ```

5. **Attribute in Theorems**:
  ```mizar
  theorem
    for n being Integer st n is even or n is odd
    holds n is even iff not n is odd;
  ```

6. **Complex Conditions**:
  While Mizar doesn't directly support "OR" conditions in attribute qualifications, these can be expressed through theorem statements and logical conditions:
  ```mizar
  theorem
    for n be Integer
    st n is even or n is odd
    holds n * n is odd iff n is odd;
  ```

## 7.4. Clustering Mechanism

The clustering mechanism enables automatic attribute inference. There are three types of clusters:

1. **Existential Clusters**:
  Declare that there exist objects with certain attributes:
  ```mizar
  registration
    cluster empty finite set;
    existence
    proof
      ... proof of the existence of empty finite set ...
    end
  end
  ```

2. **Conditional Clusters**:
  Define implications between attributes:
  ```mizar
  registration
    cluster empty -> finite set;
    coherence
    proof
      ... proof that empty set is finite ...
    end
  end
  ```

3. **Functorial Clusters**:
  Specify attributes of terms constructed by functors:
  ```mizar
  registration
    let X be non empty set;
    let Y be set;
    cluster X \/ Y -> non empty;
    coherence
    proof
      ... proof that X \/ Y is non empty ...
    end
  end
  ```

The clustering mechanism is discussed in more detail in [Chapter 10](./10.cluster).

## 7.5. Attribute Inheritance

When a structure inherits from another structure, it also inherits the attributes applicable to the parent structure.

#### Basic Attribute Inheritance

Child structures directly inherit attributes from their parent structures:

```mizar
definition
  let M be Magma;
  attr M is associative means
    for x, y, z be Element of M holds
    M.binop(M.binop(x,y),z) = M.binop(x,M.binop(y,z));
end

definition
  struct LoopStr where
    field carrier -> set;
    field binop -> BinOp of carrier;
    property unit -> Element of carrier;
  end

  inherit LoopStr from Magma where
    field carrier from carrier;
    field binop from binop;
  end
end
```

In this example, the `LoopStr` structure inherits from `Magma` so that all `LoopStr`s have the `associative` attribute. As a result, when you declare `let S be LoopStr;`, Mizar automatically recognizes the syntax `S is associative`.

#### Attribute Inheritance Through Inheritance Chains

Attributes are transitively inherited through inheritance chains:

```mizar
definition
  let M be LoopStr;
  attr M is invertible means
    for x be Element of M ex y be Element of M st
    M.binop(x,y) = M.unit & M.binop(y,x) = M.unit;
end

definition
  struct AddLoopStr where
    field carrier -> set;
    field add from binop -> BinOp of carrier;
    property zero from unit -> Element of carrier;
  end

  inherit AddLoopStr from LoopStr where
    field carrier from carrier;
    field add from binop;
    property zero from unit;
  end
end
```

In this example, `AddLoopStr` inherits from `LoopStr`, which inherits from `Magma`. As a result, `AddLoopStr` inherits both the `invertible` attribute (from `LoopStr`) and the `associative` attribute (from `Magma`).

#### Resolving Attribute Ambiguity in Multiple Inheritance

In multiple inheritance, ambiguity may arise when attributes with the same name come from different inheritance paths. Mizar provides several mechanisms to resolve this ambiguity:

1. **Type-Qualified Attribute Syntax**:

Mizar supports a direct syntax for specifying attributes in the context of specific types:

```mizar
<object> is <type>.<attribute>
```

This syntax allows clear and concise resolution of attribute ambiguity:

```mizar
definition
  struct AddLoopStr where
    field carrier -> set;
    field add -> BinOp of the carrier;
    property zero -> Element of the carrier;
  end

  struct MulLoopStr where
    field carrier -> set;
    field mul -> BinOp of the carrier;
    property one -> Element of the carrier;
  end
  
  let L be AddLoopStr;
  attr L is associative means
    for x, y, z be Element of L holds
    L.add(L.add(x,y),z) = L.add(x,L.add(y,z));
  
  let L be MulLoopStr;
  attr L is associative means
    for x, y, z be Element of L holds
    L.mul(L.mul(x,y),z) = L.mul(x,L.mul(y,z));
  
  struct DoubleLoopStr where
    field carrier -> set;
    field add -> BinOp of the carrier;
    field mul -> BinOp of the carrier;
    property zero -> Element of the carrier;
    property one -> Element of the carrier;
  end

  inherit DoubleLoopStr from AddLoopStr where
    field carrier from carrier;
    field add from add;
    property zero from zero;
  end

  inherit DoubleLoopStr from MulLoopStr where
    field carrier from carrier;
    field mul from mul;
    property one from one;
  end
end
```

Using the type-qualified attribute syntax:

```mizar
let DL be DoubleLoopStr;
assume A1: DL is AddLoopStr.associative;   :: Associativity for addition
assume A2: DL is MulLoopStr.associative;   :: Associativity for multiplication
```

This syntax provides several advantages:
- **Conciseness**: More readable than the `qua` operator approach
- **Mathematical intuition**: Aligns with mathematical expressions like "associative with respect to addition"
- **Clear namespace**: Explicitly indicates which type context the attribute refers to

2. **Explicit Resolution Using Type Conversion (qua operator)**:

The traditional `qua` operator approach remains available:

```mizar
let DL be DoubleLoopStr;
assume A1: (DL qua AddLoopStr) is associative;  :: Associativity for addition
assume A2: (DL qua MulLoopStr) is associative;  :: Associativity for multiplication
```

3. **Defining Namespaced Attributes**:

For frequently used ambiguous attributes, define explicitly namespaced attributes:

```mizar
definition
  let R be DoubleLoopStr;

  attr R is add_associative means
    R is AddLoopStr.associative;

  attr R is mul_associative means
    R is MulLoopStr.associative;
    
  attr R is distributive means
    for x, y, z be Element of R holds
    R.mul(x, R.add(y,z)) = R.add(R.mul(x,y), R.mul(x,z)) &
    R.mul(R.add(y,z), x) = R.add(R.mul(y,x), R.mul(z,x));
end
```

This eliminates ambiguity when defining mathematical concepts:

```mizar
definition
  mode Ring is add_associative add_commutative 
    mul_associative distributive non degenerated DoubleLoopStr;
end

definition
  let R be Ring;
  attr R is commutative means
    R is MulLoopStr.commutative;
end
```

In this example, when we say a `Ring` is `commutative`, it means commutativity with respect to multiplication.

#### Ambiguity Resolution Rules

When using type-qualified attributes, Mizar follows these resolution rules:

1. **Explicit qualification takes precedence**: `R is MulLoopStr.associative` is unambiguous
2. **Unqualified attributes must be unambiguous**: `R is associative` will produce an error if multiple inheritance paths define `associative`
3. **Compatibility with both syntaxes**: Both `qua` and type-qualified syntax can be used interchangeably

## 7.6. Type Inference with Attributes

Mizar's type inference system uses attributes and clusters to automatically deduce type information:

1. **Direct Inference**:
    ```mizar
    let G be Group;
    thus G is associative;    :: automatically inferred from Group cluster
    ```

2. **Transitive Inference**:
    ```mizar
    let G be associative unital Magma;
    thus G is group-like;     :: inferred through conditional cluster
    ```

3. **Constructor-based Inference**:
    ```mizar
    let A, B be non empty set;
    thus [:A, B:] is non empty;  :: inferred through functorial cluster
    ```

4. **Type-Qualified Inference**:
    ```mizar
    let R be Ring;
    thus R is AddLoopStr.commutative;     :: inferred from Ring definition
    thus R is MulLoopStr.associative;     :: inferred from Ring definition
    ```

## 7.7. Dependent Attributes

Attributes can be parameterized by variables or constants using hyphen-separated syntax:

```mizar
definition
  let n be Nat;
  attr V is n-dimensional means
    ex B being Basis of V st card B = n;
end
```

**Parameter syntax:**
- Single parameter: `attr X is param-name means ...`
- Multiple parameters: `attr X is (param1,param2)-name means ...`
- Parameters can be variables or constants

**Usage:**
```mizar
let V be 3-dimensional VectorSpace;
let M be F-linear Function;
let A be (3,4)-size Matrix;
```

**Parameter constraints:**
- Parameters must be declared before the attribute definition
- Single parameters use hyphen directly: `n-dimensional`
- Multiple parameters use parentheses: `(m,n)-size`

**Complex examples:**
```mizar
definition
  let m, n be Nat;
  attr A is (m,n)-size means
    A is Function of [:Seg m, Seg n:], REAL;
end

let A be (3,4)-size Matrix;
```

## 7.8. Attribute Redefinition

Attribute redefinition allows for providing alternative logical definitions of existing attributes for more specialized types. Unlike functor redefinition (which can change return types), attribute redefinition only changes the logical meaning.

#### Basic Redefinition Syntax

The `redefine` keyword is used to modify an existing attribute definition:

```mizar
definition
  let T be Type;
  redefine attr T is attribute_name means
    ... new logical definition ...;
end
```

**Key characteristics:**
- `redefine` keyword indicates modification of an existing attribute
- The attribute must already be defined for the type or its parent types
- The new definition must be logically equivalent to the original definition

#### Redefinition in Inheritance Contexts

Attribute redefinition is most commonly used when specializing types to provide more specific or computationally efficient definitions:

```mizar
definition
  let i be Integer;
  attr i is even means
    :even_for_integer:
    2 divides i;
end

definition
  let n be Nat;
  redefine attr n is even means
    ex k be Nat st n = 2*k;
  coherence with even_for_integer
  proof
    :: Proof that for natural numbers, the new definition is equivalent to the original
  end
end
```

This redefinition provides a more constructive characterization of evenness for natural numbers while maintaining logical equivalence with the divisibility-based definition for integers.

#### Compatibility Requirements

When redefining attributes, the following compatibility requirements must be satisfied:

1. **Logical Equivalence**: The redefined attribute must be logically equivalent to the original when applied to objects of the specialized type.

2. **Coherence Obligation**: A proof must be provided showing that the new definition is equivalent to the original, optionally referencing specific definition labels.

3. **Label Reference**: When using hierarchical redefinition, specific definition labels can be referenced to clarify which parent definition is being refined.

**Coherence Proof Requirements:**

```mizar
definition
  let S be SpecializedType;
  redefine attr S is some_attribute means
    ... specialized definition ...;
  coherence with <original_attribute_label>
  proof
    :: Must prove that for any object x of SpecializedType:
    :: x is some_attribute (original sense) iff x is some_attribute (new sense)
  end
end
```

#### Advanced Redefinition Patterns

Attribute redefinition can be used in various contexts:

1. **Alternative Characterization**: Providing different but equivalent logical formulations for specialized types
2. **Computational Efficiency**: Offering more direct computational characterizations
3. **Mathematical Equivalence**: Expressing the same concept using different mathematical frameworks
4. **Constructive Definitions**: Converting existential definitions to constructive ones for specific types

Through attribute redefinition, Mizar enables precise mathematical expression while maintaining semantic consistency across type hierarchies.
