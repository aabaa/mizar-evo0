# 1. Introduction

- [1. Introduction](#1-introduction)
  - [1.1 Background for Redesigning Mizar](#11-background-for-redesigning-mizar)
  - [1.2 Purpose of this Document](#12-purpose-of-this-document)
  - [1.3 Brief History of Mizar](#13-brief-history-of-mizar)
  - [1.4 New Features Overview](#14-new-features-overview)

## 1.1 Background for Redesigning Mizar

The redesign of Mizar is driven by several key factors in the evolving landscape of formalization of mathematics and interactive theorem proving (ITP):

1. **Modernization of Software Practices**:  
    Mizar, with its 50-year heritage, has been constrained by outdated software practices. This redesign introduces modern software paradigms such as templates, namespaces, module system and overload resolution enhancing efficiency and expressiveness in formalized proof development.

2. **Revitalizing First-Order Logic Based Systems**:  
    While the trend in theorem proving has shifted towards higher-order logic and type theory, we believe there is significant value in advancing first-order logic based systems. This is supported by:  
   a) Recent major advancements in automated theorem proving (ATP) within first-order logic.
   b) The prevalence of set theory based on first-order logic as the common logical framework among mathematicians.  
   c) The need for a system that bridges the gap between traditional mathematical thinking and formal verification.  

3. **Expanding Capabilities**:  
    By introducing features like tactics and algorithm verification, we aim to broaden Mizar's applicability beyond pure mathematics into areas such as software verification and formalized computer science.

4. **Synergy with AI and Large Language Models**:  
    With the rapid advancement of Large Language Models (LLMs) and automated reasoning, we recognize the potential for a synergistic approach. The new Mizar integrates state-of-the-art ATPs like [Vampire](https://vprover.github.io/) and [E](https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html) as robust inference engines, while also adopting standards like the **Model Context Protocol (MCP)** to facilitate seamless interaction with AI agents. This architecture allows Mizar to leverage LLMs for high-level proof search and suggestion, **while strictly maintaining logical soundness through its minimal trusted kernel.** This design combines the intuitive power of AI with the rigorous certainty of mathematical proof.

5. **Preserving Mathematical Intuition**:  
    Mizar stands out as the only ITP with a language designed by a mathematician for mathematicians. This unique approach has garnered support from the formalization community for five decades, demonstrating its alignment with intuitive mathematical thinking and expression.

6. **Disciplined Expressivity Over Syntactic Flexibility**:
    While some modern systems favor extensible syntax and meta-programming capabilities, Mizar adopts a more disciplined approach. By enforcing a stable and uniform syntax, the system promotes human readability, long-term maintainability, and alignment with traditional mathematical exposition. This design choice is intended to minimize cognitive overhead, allowing users to focus more fully on the essence of mathematical reasoning.

7. **Foundational Reliability via SAT-Based Small Kernel**:
    In response to the growing demand for absolute reliability, the new Mizar adopts a "Small Kernel" architecture that adheres to the de Bruijn criterion. Instead of relying on a monolithic verifier, the system decouples proof search from proof checking. The validity of first-order inferences is verified by reducing them to propositional logic via specific substitution instances. This allows the trusted kernel to be minimized to a simple component that performs instantiation and checks for unsatisfiability (UNSAT) using a SAT solver, ensuring that logical soundness is independent of the complexity of high-level automation.

This redesign of Mizar is not just an update of an existing tool, but a strategic move to position first-order logic based theorem proving at the forefront of formal mathematics and automated reasoning. It aims to combine the strengths of traditional mathematical logic with modern software engineering practices and cutting-edge automated reasoning techniques, while maintaining its core philosophy of being a system that truly speaks the language of mathematicians.

## 1.2 Purpose of this Document

This document serves as the official specification for the redesigned Mizar language, encompassing its latest features and improvements. The primary objectives of this specification are:

1. To provide a comprehensive and authoritative reference for the Mizar language, detailing its syntax, semantics, and core functionalities.
2. To serve as a guide for both newcomers and experienced users in understanding and effectively utilizing the Mizar system for formal mathematical proofs.
3. To document the recent enhancements and modifications to the Mizar language, ensuring that users are aware of the latest capabilities and best practices.
4. To establish a standard for the development of Mizar-based tools, libraries, and educational materials.
5. To facilitate the integration of Mizar with other mathematical software and proof assistants by providing clear interface specifications.
6. To illustrate how the new features of Mizar integrate with its traditional strengths in first-order logic and set theory based mathematics.

This specification is intended for a diverse audience, including:

- Mathematicians seeking to formalize their work
- Computer scientists interested in formal methods and theorem proving
- Educators teaching formal logic and mathematical reasoning
- Software developers creating tools for or integrating with Mizar
- Researchers exploring the foundations of mathematics and automated reasoning
- Developers of ATPs interested in integration with ITPs

While this document aims to be exhaustive in its coverage of the Mizar language, it is not intended as a tutorial or user manual. Readers are encouraged to consult supplementary materials, such as tutorials, user guides, and example repositories, for practical guidance on using Mizar effectively.

As the Mizar language continues to evolve towards more powerful and efficient formalization capabilities, this specification will be periodically updated to reflect new features, improvements, and best practices. Users are advised to refer to the most recent version of this document to ensure they have the latest information on Mizar's expanding capabilities in both traditional mathematics and new areas of application.

## 1.3 Brief History of Mizar

Mizar, one of the oldest ITPs, has a rich history dating back to the early 1970s. Its development and evolution have been marked by significant milestones and achievements. Key events include:

- 1973: The Mizar project started under the leadership of Andrzej Trybulec.
- 1975: First version of Mizar-PC.
- 1982: First version of Mizar-MSE.
- 1989: Launch of [the Mizar Mathematical Library (MML)](https://mizar.uwb.edu.pl/library/), a comprehensive repository of formalized mathematics. Also, the launch of [the Journal of Formalized Mathematics](https://fm.mizar.org/), pioneering machine-verified mathematical publications.
- 2001: Formalization of the Jordan Curve Theorem [^ART2005] [^ART2007].
- 1995-2003: Formalization of "Compendium of Continuous Lattice" [^BAN2002].

As of January 2026, the Mizar project has completed formalizing 71 theorems on Freek Wiedijk's "[Formalizing 100 Theorems](https://www.cs.ru.nl/F.Wiedijk/100/)" list. For more detailed history and formalization achievement, please refer to Matuszewski and Rudnicki (2005)[^ROM2005], Bancerek et al. (2015)[^BAN2015] and Bancerek et al. (2018)[^BAN2018].

The logical structure of the Mizar language is based on a variant of the classical first-order logic natural deduction system proposed by Jaśkowski. The Tarski-Grothendieck set theory, which is an extension of ZFC set theory with strongly inaccessible cardinals, is applied as the foundation basis in the MML. For the detailed specifications of the current Mizar system, please refer to Grabowski et al.(2010) [^GRA2010]

Throughout its evolution, Mizar has maintained its core philosophy of closely mirroring natural mathematical language and reasoning. This approach has made it a favorite among the MML developers for formalizing complex mathematical proofs and theories. The system's longevity and consistent development have resulted in one of the largest libraries of formalized mathematics, covering a wide range of fields from basic set theory to advanced algebraic structures.

Mizar's influence extends beyond its direct applications, having inspired aspects of other proof assistants and contributing significantly to the field of formalized mathematics. The formalization of the Jordan Curve Theorem and the extensive work on Lattice Theory demonstrate Mizar's capability to handle complex mathematical concepts. Moreover, the contributions to Wiedijk's "100 Theorems" project highlight Mizar's role in the broader landscape of theorem provers.

As we embark on this redesign, we build upon this rich legacy, aiming to preserve Mizar's strengths while adapting to the changing landscape of formal verification and automated reasoning.

[^ROM2005]: Roman Matuszewski and Piotr Rudnicki. [Mizar: the First 30 Years](https://mizar.uwb.edu.pl/people/romat/MatRud2005.pdf). Mechanized Mathematics and Its Applications 4(1) pp. 3-24 (2005)
[^BAN2015]: Bancerek G., Bylinski C., Grabowski A., Kornilowicz A., Matuszewski R., Naumowicz A., Pak K., Urban J., [Mizar: State-of-the-Art and Beyond](https://link.springer.com/chapter/10.1007/978-3-319-20615-8_17). In M. Kerber et al. (Eds.), Intelligent Computer Mathematics, CICM 2015, LNAI 9150, pp. 261-279 (2015).
[^BAN2018]: Bancerek, Grzegorz, et al. [The Role of the Mizar Mathematical Library for Interactive Proof Development in Mizar](https://link.springer.com/article/10.1007/s10817-017-9440-6). Journal of Automated Reasoning 61 pp. 9-32 (2018).
[^ART2005]: Artur Korniłowicz. [Jordan Curve Theorem](https://fm.mizar.org/2005-13/pdf13-4/jordan.pdf). Formalized Mathematics 13(4) pp. 481-491 (2005).
[^ART2007]: Artur Korniłowicz. [A Proof of the Jordan Curve Theorem via the Brouwer Fixed Point Theorem](http://sakura.cs.shinshu-u.ac.jp/mizar/mma.dir/2007/MMA_2007_paper_4_for_web.pdf). Mechanized Mathematics and Its Applications 6(1) pp. 33-40 (2007).
[^BAN2002]: Bancerek, G, Rudnicki, P., [A Compendium of Continuous Lattices in Mizar: Formalizing recent mathematics](https://mizar.uwb.edu.pl/project/CCL020525-gbpr.pdf), Journal of Automated Reasoning 29(3-4) pp. 189-224 (2002)
[^GRA2010]: Grabowski, A., Kornilowicz, A., Naumowicz, A., [Mizar in a Nutshell](http://jfr.cib.unibo.it/article/view/1980/1356), in: A. Asperti, J. Harrison and C. Munoz (Eds.) User Tutorials I, Journal of Formalized Reasoning 3(2) pp. 153-245 (2010)

## 1.4 New Features Overview

The redesign of Mizar introduces several significant enhancements and new features aimed at modernizing the system while preserving its core strengths. This overview highlights the key improvements:

1. **Enhanced Module System and Namespaces**:
    - Introduction of a more robust module system for better code organization.
    - Implementation of namespaces to prevent naming conflicts and improve code reusability.

2. **Templates**:
    - Support for generic programming through a template system.
    - Enables writing more flexible and reusable mathematical structures and theorems.

3. **Improved Type System**:
    - Enhanced type inference capabilities.
    - More expressive type hierarchies and automatic conversions.
    - Improved resolution rules for overloaded entities.

4. **Advanced Tactics and Automation**:
    - Introduction of a tactic language for more powerful proof automation.
    - Integration with external theorem provers for enhanced proving capabilities.
    - Incorporation of machine learning techniques to assist in proof development.

5. **Algorithm Validation and Program Generation**:
    - New syntax and semantics for algorithm specification and formal verification.
    - Support for preconditions, postconditions, loop invariants, and termination proofs.
    - Enhanced capabilities for proving algorithm correctness and program generation.

6. **Improved Error Handling and Diagnostics**:
    - More informative error messages and warnings.
    - Enhanced debugging capabilities for complex proofs and definitions.

7. **Comprehensive Annotation System**:
    - Introduction of a versatile annotation system for improved documentation and meta-information.
    - Support for inference engine hints to guide automated reasoning.
    - Capability to record ATP versions used for verification.
    - Metadata for assembling formal proofs into article format for the Journal of Formalized Mathematics.
    - Annotations to maintain compatibility information with existing Mizar libraries by tracking theorem origins during library reorganization.

8. **Modernized Standard Library**:
    - Expansion and reorganization of the standard library to cover a wider range of mathematical concepts and structures.

9. **Compatibility Layer**:
    - Inclusion of a compatibility layer to facilitate the transition from older versions of Mizar.

10. **Substitution-Based Verification Kernel**:
    - **Certificate-Based Verification**: For every inference step, the system generates a proof certificate consisting of specific variable substitutions (instances).
    - **Reduction to SAT**: Verification is performed by applying these substitutions to the negated formula and confirming its unsatisfiability (UNSAT).
    - **Minimal TCB**: The trusted kernel is strictly limited to the instantiation mechanism and a basic SAT solver, drastically reducing the Trusted Computing Base compared to traditional implementation.

11. **Interactive Development Architecture**:
    - **Incremental Parsing and Verification**: Unlike the traditional batch-processing approach, the new architecture supports incremental verification. This allows for partial checking of documents, enabling immediate feedback on errors and proof validity as the user types.
    - **Error Resilient Parsing**: The parser is designed to be resilient, capable of constructing a partial syntax tree even in the presence of syntax errors, which facilitates continuous tooling support (e.g., autocompletion) during editing.

12. **Standardized Tooling Interfaces (LSP & MCP)**:
    - **Language Server Protocol (LSP) Support**: Built-in support for LSP ensures that Mizar can be easily integrated into modern IDEs (such as VS Code, Emacs, and Neovim) with features like syntax highlighting, code completion, and go-to-definition out of the box.
    - **Model Context Protocol (MCP) Integration**: To facilitate the synergy with Large Language Models (LLMs), Mizar implements the Model Context Protocol. This exposes the library's structure, theorem search, and verification status as a standardized context for AI agents, allowing LLMs to interact with the Mizar system reliably.

13. **Integrated Package Management and Documentation**: 
    - **Package Manager and Build System**: Introduction of a dedicated package manager to handle dependencies, versioning, and reproducible builds. This facilitates the transition from a monolithic repository to a decentralized ecosystem of modular theories. 
    - **Automated Documentation Generator**: Recognizing code as knowledge, the system includes a tool to generate comprehensive documentation (HTML/PDF) directly from Mizar source files and annotations. This ensures that formal proofs remain accessible and understandable.

14. **Source Encoding and Syntax Policy**: 
    - **UTF-8 Support**: Source files are fully encoded in UTF-8, allowing the use of Unicode characters in comments and annotations. This enables users to write documentation and explanations in their native languages.
    - **ASCII-Based Syntax**: To ensure canonical representation and efficient searchability across the library, the core logical syntax remains ASCII-based. This deliberate choice prevents notation fragmentation and maintains the "search-friendly" nature of Mizar code.

These new features and improvements aim to enhance Mizar's expressiveness, ease of use, and power in formalizing complex mathematical concepts and proofs. They reflect a balance between preserving Mizar's traditional strengths in natural-language-like mathematical formalization and incorporating modern programming language features and proof automation techniques.

The subsequent chapters of this document will dive into the details of each of these features, providing comprehensive explanations, syntax specifications, and usage guidelines.

# 2. Lexical Structure

- [2. Lexical Structure](#2-lexical-structure)
  - [2.1 Character Set and Encoding](#21-character-set-and-encoding)
  - [2.2 Tokens and Lexicon](#22-tokens-and-lexicon)
  - [2.3 Reserved Words](#23-reserved-words)
  - [2.4 Special Symbols](#24-special-symbols)
  - [2.5 Identifiers](#25-identifiers)
  - [2.6 Numerals and Literals](#26-numerals-and-literals)
  - [2.7 File and Module Naming](#27-file-and-module-naming)
  - [2.8 Comments and Annotations](#28-comments-and-annotations)
    - [2.8.1 Comment Types](#281-comment-types)
    - [2.8.2 Annotations](#282-annotations)
  - [2.9 Whitespace and Formatting](#29-whitespace-and-formatting)
  - [2.10 Lexical Preprocessing](#210-lexical-preprocessing)

## 2.1 Character Set and Encoding

* **Encoding**: UTF-8
* **Code sections**: ASCII only (letters, digits, symbols)
* **Comments and annotations**: Full Unicode allowed, including Greek letters and LaTeX-style notation (e.g., `\alpha`)
* **Escape character**: Use `\` to escape special characters in string literals

## 2.2 Tokens and Lexicon

The lexer processes the following token types:

* **Reserved words**: predefined keywords with fixed semantics
* **Special symbols**: punctuation, operator-like symbols, and template markers
* **Identifiers**: user-defined names
* **Numerals**: unsigned sequences of digits

Lexical analysis is context-sensitive: imported modules can extend the active lexicon. In case of ambiguity, the lexer uses a **longest-match rule**.

## 2.3 Reserved Words

Reserved words are case-sensitive and may not be used as identifiers. The complete list is as follows:

```mizar
according aggregate all and antonym are as associativity
assume asymmetry attr
be begin being by
canceled case cases cluster coherence commutativity
compatibility conjecture connectedness consider consistency
constructor contradiction correctness
def deffunc define definition definitions defpred do does
end environ equals ex exactly existence export extend
for from func
given
hence hereby holds
idempotence identify if iff implies import involutiveness
inherits irreflexivity is it let
means mode
non not notation notations now
of or otherwise over
per pred prefix projectivity proof provided private
qua
reconsider reduce reducibility redefine reflexivity registration
registrations requirements reserve
sch scheme schemes section selector set sethood st struct
such suppose symmetry synonym
take that the then theorem theorems thesis thus to
transitivity
uniqueness
vocabularies
when where with wrt
```

These words must be recognized as individual tokens, not as identifiers.

## 2.4 Special Symbols

Special symbols are non-alphanumeric characters or sequences with syntactic meaning. The complete list is:

```mizar
,  .  ;  :  (  )  [  ]  {  }  =  &  ->  .=  ...
```

* `,` `;` `:`: Delimiters
* `.`: Namespace separator or postfix dot notation
* `=` `.=`: Equality and stepwise transformation
* `->`: Function arrow
* `...`: Ellipsis

## 2.5 Identifiers

Identifiers are used for variables.

**Syntax**:

```lark
identifier: (LETTER | "_") (LETTER | DIGIT | "_" | "'")*
```

* Must not match any reserved word
* Case-sensitive
* May override symbols (e.g., `id`) if they form a valid identifier
* Shadowing follows scoping and longest-match precedence

## 2.6 Numerals and Literals

* **Numerals**: Built-in representation of natural numbers

  * Syntax: decimal digits (no sign)
  * Examples: `0`, `1`, `42`
* **Other literals**: No built-in support; e.g., strings, booleans, floats must be encoded as terms in the library

## 2.7 File and Module Naming

* Files must end with `.miz`
* Each file defines one module; module name = file name (sans extension)
* The directory path determines the namespace

**Example**:

```
File path: /mml/algebra/group.miz
Module name: group
Namespace: mml.algebra.group
```

## 2.8 Comments and Annotations

### 2.8.1 Comment Types

* **Single-line**: Begins with `::`

```mizar
:: This is a single-line comment
```

* **Multi-line**: Between `::=` and `=::`

```mizar
::=
This is a multi-line comment
It may contain LaTeX: $E = mc^2$
=::
```

* **Documentation**: Begins with `:::`

```mizar
::: Pythagorean theorem: $a^2 + b^2 = c^2$
theorem Pythagorean:
```

### 2.8.2 Annotations

* Begin with `@`, used for metadata or parser hints

```mizar
::: @proof-sketch This proof proceeds by induction on $n$
@symbol_precedence(*, 100, left_associative)
```

## 2.9 Whitespace and Formatting

* Whitespace is not semantically significant
* Use space, tab, newline for layout
* Recommendations:
  * Indent consistently (2 or 4 spaces)
  * Limit line length to 100 characters
  * Break long expressions after logical or arithmetic operators

**Example**:

```mizar
theorem Pythagorean:
  for a, b, c being Real st a > 0 & b > 0 & c > 0 holds
  a^2 + b^2 = c^2 implies
  ex t being right Triangle st
    t.leg1 = a & t.leg2 = b & t.hypotenuse = c;
```

## 2.10 Lexical Preprocessing

* Comments are removed before parsing
* Imports are resolved before tokenization; imported symbols affect lexing
* Token recognition depends on the currently active lexicon
* The lexer uses a **longest-match rule** among all known symbols

**Example**:

Suppose the following operators are defined in module `A`:

```mizar
definition
  let x, y be Real;
  func x +* y -> Real means ...;
  func x *+ y -> Real means ...;
  func x +*+ y -> Real means ...;
end
```

Then in another file:

```mizar
import A;
let x, y be Real;

x +* y;     :: parsed as `+*`
x *+ y;     :: parsed as `*+`
x +*+ y;    :: parsed as `+*+`
x + *+ y;   :: parsed as `+` and `*+`
```

This example illustrates how the longest-match rule and import-sensitive context influence lexical analysis.


# 3. Modules and Namespaces

- [3. Modules and Namespaces](#3-modules-and-namespaces)
  - [3.1 Module Structure and Namespace Rules](#31-module-structure-and-namespace-rules)
    - [3.1.1 Repository Layout](#311-repository-layout)
    - [3.1.2 Naming Conventions](#312-naming-conventions)
    - [3.1.3 Design Philosophy](#313-design-philosophy)
  - [3.2 Import Statements](#32-import-statements)
    - [3.2.1 Aliases](#321-aliases)
    - [3.2.2 Multiple Imports](#322-multiple-imports)
    - [3.2.3 Relative Imports](#323-relative-imports)
    - [3.2.4 Conflict Resolution](#324-conflict-resolution)
    - [3.2.5 Cyclic Imports](#325-cyclic-imports)
  - [3.3 Export Statements](#33-export-statements)
    - [3.3.1 Automatic Exports](#331-automatic-exports)
    - [3.3.2 Private Declarations](#332-private-declarations)
    - [3.3.3 Re-exporting](#333-re-exporting)
  - [3.4 Example](#34-example)

## 3.1 Module Structure and Namespace Rules

A module corresponds to a `.miz` file and serves as a unit of mathematical content. Each file defines one module.

* **Module name**: Same as file name without extension
* **Namespace**: Defined by directory structure
* **Example**: `/mml/algebra/group.miz` defines module `group` in namespace `mml.algebra`

### 3.1.1 Repository Layout

* `/mml`: Core Mizar Mathematical Library (MML), self-contained
* `/fm`: Formalized Mathematics articles by year; depends on `/mml`
* `/user`: User space; depends on `/mml` and `/fm`

### 3.1.2 Naming Conventions

* Lowercase letters, digits, underscores
* Avoid reserved keywords and naming conflicts

### 3.1.3 Design Philosophy

The module system is designed for clarity and maintainability, prioritizing static structure over dynamic flexibility. Features such as re-exporting, relative imports, and aliasing support modular organization. Dynamic inclusion mechanisms (e.g., local `open`) are intentionally excluded to preserve predictability.

* All module dependencies are statically declared
* Namespaces are globally unique
* Modules are composable via re-exporting

## 3.2 Import Statements

Modules can import others using the `import` statement.

```mizar
import mml.algebra.group;
```

Public symbols (e.g., `Group`) become available:

```mizar
let G be Group;
let G be group.Group;
let G be mml.algebra.group.Group;
```

### 3.2.1 Aliases

```mizar
import mml.algebra.group as grp;
let G be grp.Group;
```

### 3.2.2 Multiple Imports

```mizar
import mml.algebra.{group, ring, field};
```

### 3.2.3 Relative Imports

```mizar
import ..group;  :: from parent directory
import .utils;   :: from current directory
```

### 3.2.4 Conflict Resolution

Symbol names must be unambiguous. If multiple modules define the same symbol name and it is used without disambiguation, this results in a **verification-time error**.

To avoid this, use aliases or fully qualified names:

```mizar
import mml.algebra.group as alg_group;
import mml.topology.group as top_group;
let G be alg_group.Group;
let T be top_group.Group;
```

### 3.2.5 Cyclic Imports

Cyclic module dependencies are **not permitted**. The verifier will raise an error if a cycle is detected in the module dependency graph.

## 3.3 Export Statements

Modules export their public elements by default. You can control this behavior explicitly.

### 3.3.1 Automatic Exports

The following elements are automatically exported if not declared `private`:

* `struct`, `mode`, `attr`, `func`, `pred`, `theorem`, `conjecture`, `scheme`, `synonym`, `antonym`

### 3.3.2 Private Declarations

Use `private` to restrict visibility:

```mizar
private theorem internal_lemma: ...;
```

Private declarations are only accessible within the same module.

### 3.3.3 Re-exporting

```mizar
export mml.algebra.group;
```

This makes all public elements of `group` available through the current module.

**Note**: Re-exported symbols can be accessed both via their original module path and through the re-exporting module. This allows layering and modular reuse.

## 3.4 Example

```mizar
:: File: /mml/algebra/group_theory.miz
export mml.algebra.group;
export mml.algebra.subgroup;
import mml.algebra.group;
import mml.algebra.subgroup;

definition
  let G be Group;
  attr G is simple means
    for H being normal Subgroup of G holds
      H = {1_G} or H = the carrier of G;
end

private theorem internal_lemma: ...;

theorem public_group_theorem: ...;
```

This defines a module that imports and re-exports foundational components, adds new concepts, and hides internal proofs.


# 4. Variables and Constants

- [4. Variables and Constants](#4-variables-and-constants)
  - [4.1 Variables in First-Order Logic and Mizar](#41-variables-in-first-order-logic-and-mizar)
  - [4.2 Variable Declarations](#42-variable-declarations)
    - [4.2.1 Basic Syntax](#421-basic-syntax)
    - [4.2.2 Constraints (Attributes)](#422-constraints-attributes)
    - [4.2.3 Multiple Declarations](#423-multiple-declarations)
  - [4.3 Constants](#43-constants)
    - [4.3.1 Numerals](#431-numerals)
    - [4.3.2 Set Declarations](#432-set-declarations)
  - [4.4 Variable Scoping Rules](#44-variable-scoping-rules)
    - [4.4.1 Local Scope](#441-local-scope)
    - [4.4.2 Nested Scope and Shadowing](#442-nested-scope-and-shadowing)
    - [4.4.3 Reserved Type Declarations](#443-reserved-type-declarations)
    - [4.4.4 Quantified Variables](#444-quantified-variables)
    - [4.4.5 Identifier Precedence](#445-identifier-precedence)
    - [4.4.6 Scoping Errors](#446-scoping-errors)
  - [4.5 Summary](#45-summary)

## 4.1 Variables in First-Order Logic and Mizar

Mizar extends first-order logic (FOL) by introducing typed variables.

* **FOL**: `x` is untyped; quantified over the domain
* **Mizar**: `let x be Real;` implies `Real(x)` in logical terms

## 4.2 Variable Declarations

### 4.2.1 Basic Syntax

```mizar
let x be Real;
let n be Nat;
let G be Group;
```

### 4.2.2 Constraints (Attributes)

```mizar
let n be positive Nat;
let S be non empty set;
let a be positive even Integer;
```

### 4.2.3 Multiple Declarations

```mizar
let x, y, z be Real;
let m, n be Nat;
```

## 4.3 Constants

### 4.3.1 Numerals

* Represent natural numbers: `0, 1, 2, ...`
* Inferred as `natural Number`

### 4.3.2 Set Declarations

```mizar
set X = {1, 2, 3};
set f = id REAL;
set n = 2 + 3;
```

You can redefine type using `reconsider`:

```mizar
reconsider X as finite set;
```

## 4.4 Variable Scoping Rules

Note: `reserve` is not a variable declaration. It is a directive that allows omitting the type specification in subsequent variable declarations within the module.

### 4.4.1 Local Scope

* `for x being T` introduces bound variables
* `let x be T;` in `proof` block declares local instantiation

### 4.4.2 Nested Scope and Shadowing

Inner variables can shadow outer ones:

```mizar
let x be Real;
proof
  let x be Nat;  :: valid shadowing
end
```

### 4.4.3 Reserved Type Declarations

The `reserve` statement declares that a given identifier will always refer to a value of a specified type within the current module. It does **not** bind the variable; it only provides a type default:

```mizar
reserve x for Real;
```

This allows type specification to be omitted later:

```mizar
let x;
```

This is equivalent to:

```mizar
let x be Real;
```

Local contexts can override the reserved type:

```mizar
for x being Nat holds ...
```

### 4.4.4 Quantified Variables

```mizar
for x being Real holds P(x);
ex n being Nat st Q(n);
```

### 4.4.5 Identifier Precedence

Identifiers declared as variables override imported symbols:

```mizar
import module_with_symbol_id;
reserve id for Real;  :: refers to variable, not symbol
let id be Nat;  :: it overrides the above variable type
```

### 4.4.6 Scoping Errors

* Redeclaring with incompatible type in same scope is error:

```mizar
let x be Real;
let x be Nat;  :: Error
```

* Shadowing in inner blocks is allowed

## 4.5 Summary

* Mizar variables are typed and follow lexical scoping
* `let`, `set`, and quantifiers each introduce variable bindings
* `reserve` is a type hint for later declarations, not a binding
* Scoping rules and identifier resolution are critical for correct parsing and proof checking

# 5. Type System

- [5. Type System](#5-type-system)
    - [5.1. Overview](#51-overview)
    - [5.2. Core Concepts](#52-core-concepts)
    - [5.3. Logical Interpretation](#53-logical-interpretation)
    - [5.4. Design Principles](#54-design-principles)
    - [5.5. Built-in Types](#55-built-in-types)
    - [5.6. Type Declarations](#56-type-declarations)

### 5.1. Overview

Mizar Evolution adopts a soft typing system layered on untyped set theory. Types serve as syntactic guides and are not part of the logical foundation. All expressions ultimately denote sets, and type checking is implemented as generation of proof obligations in first-order logic. For an in-depth discussion of Mizar's soft typing, see:

> Freek Wiedijk. [Mizar's Soft Type System](https://cs.ru.nl/F.Wiedijk/mizar/miztype.pdf) TPHOLs 2007

### 5.2. Core Concepts

* **Radix-types**: Root types including built-in types (`object`, `set`) and user-defined types (`mode`, `struct`).
* **Attributes**: Unary predicates that refine existing types.
* **Modes**: Type constructors defining new types using attributes and existing radix-types.
* **Structures**: Composite radix-types grouping fields and properties.
* **Clusters**: Mechanisms that declare relationships among types and attributes.

### 5.3. Logical Interpretation

* A type `T` is interpreted as a predicate `is_T(x)`.
* Subtyping is modeled as implication: `is_S(x) ⇒ is_T(x)`.
* All typing can be erased to yield a pure first-order representation.

### 5.4. Design Principles

* **Mathematical alignment**: Types are designed to match mathematical practice.
* **Separation of concerns**: Types guide readability and verification but are erased for logical core.
* **Efficiency**: Syntax and inference mechanisms are optimized for fast checking.
* **Consistency**: All typing constructs follow unified syntax and semantics.

### 5.5. Built-in Types

* `object`: Universal type representing all elements in the Mizar universe, including structural types.
* `set`: Subtype of `object`. Represents mathematical sets in the traditional sense. Structural types (defined via `struct`) are included in `object` but not in `set`.

### 5.6. Type Declarations

#### Structures

Defined using `struct`:

```mizar
struct Point2d where
  field x -> Real;
  field y -> Real;
end
```

#### Attributes

Defined using `attr`:

```mizar
definition
  let i be Integer;
  attr i is even means 2 divides i;
end
```

#### Modes

Defined using `mode`:

```mizar
definition
  mode Integer is integer Number;
end
```

Modes can include attribute chains and can be parameterized.

#### Variable Declarations

```mizar
let n be positive Integer;
let I be set;
let f be Group-Family of I;
```

#### Type Expressions

* Attribute application: `positive Integer`
* Dependent modes: `Group-Family of I`

Type expressions may involve inheritance and clustering.

# 6. Structures

## 6.1 Concept and Purpose

Structures are radix-types used to define composite types with named fields and properties. They serve three purposes:

1. **Data encapsulation**: grouping logically related components
2. **Type formation**: creating new types via structural definitions
3. **Mathematical modeling**: representing algebraic and analytical structures

## 6.2 Syntax

Structure definitions use the `struct` keyword:

```mizar
definition
  struct Name where
    field field1 -> Type1;
    ...
    property prop1 -> Type2;
    ...
  end
end
```

* `field`: represents intrinsic components
* `property`: represents derived values (often from functors)
* Property values are typically computed from the fields via functors.

**Example**:

```mizar
definition
  struct UnitalMagma where
    field carrier -> set;
    field binop -> BinOp of carrier;
    property unit -> Element of carrier;
  end
end
```

## 6.3 Inheritance

Structures may inherit from others via `inherit`:

```mizar
definition
  inherit Derived from Base where
    field derived_field from base_field;
    property derived_prop from base_prop;
  end
end
```

* All base fields/properties must be inherited.
* Inheritance supports renaming and type specialization with proof obligations.
* When the type of an inherited field or property is specialized, one must prove type consistency (e.g., `for x being X holds x is Y`).

**Set inheritance** is allowed:

```mizar
inherit 1-sorted from set where
  field carrier from it;
end
```

## 6.4 Multiple and Diamond Inheritance

Multiple inheritance is allowed if structure names are distinct. Diamond inheritance is supported but must be disambiguated.

**Example**:

```mizar
definition
  struct ZeroStr where
    field carrier -> set;
    property zero -> Element of carrier;
  end

  struct OneStr where
    field carrier -> set;
    property one -> Element of carrier;
  end

  struct ZeroOneStr where
    field carrier -> set;
    property zero -> Element of carrier;
    property one -> Element of carrier;
  end

  inherit ZeroOneStr from ZeroStr where
    field carrier from carrier;
    property zero from zero;
  end

  inherit ZeroOneStr from OneStr where
    field carrier from carrier;
    property one from one;
  end
end
```

Consistency of shared fields (e.g., `carrier`) must be proven.

## 6.5 Constructors

Structures can be instantiated using default or custom constructors.

* **Default**: named arguments in any order. The order of fields does not matter due to the named argument syntax.

```mizar
let x = OneStr(carrier: A, one: b);
```

* **Custom**: using `constructor` keyword

```mizar
definition
  let G be Group;
  constructor OneStr(G) where
    it.carrier = G.carrier;
    it.one = G.unit;
  end
end
```

* **Converting constructors** allow implicit type coercion:

```mizar
reconsider x = G as OneStr;
```

## 6.6 Dependent Structures

Structures can be parameterized using `over` or `of`:

```mizar
definition
  let R be Ring;
  struct Polynomial over R where
    field coeffs -> FinSequence of R.carrier;
    property degree -> Nat;
  end
end
```

* These forms are syntactic sugar for template definitions.
* Multiple parameters: `struct Name over T, U`
* These declarations enable instantiation and specialization as generic structures.

**Usage**:

```mizar
let p be Polynomial over REAL;
```

This enables modular and reusable structure definitions parameterized by types.

# 7. Attributes

- [7. Attributes](#7-attributes)
  - [7.1. Definition and Purpose](#71-definition-and-purpose)
  - [7.2. Syntax for Attribute Declaration](#72-syntax-for-attribute-declaration)
  - [7.3. Usage](#73-usage)
    - [Type Qualification](#type-qualification)
    - [Property Testing](#property-testing)
    - [Negation and Combinations](#negation-and-combinations)
    - [Type-Qualified Attributes](#type-qualified-attributes)
  - [7.4. Clustering Mechanism](#74-clustering-mechanism)
  - [7.5. Attribute Inheritance](#75-attribute-inheritance)
  - [7.6. Disambiguation in Multiple Inheritance](#76-disambiguation-in-multiple-inheritance)
  - [7.7. Redefinition](#77-redefinition)
  - [7.8. Implementation Notes](#78-implementation-notes)

## 7.1. Definition and Purpose

Attributes are unary predicates used to refine types by specifying additional logical properties. They serve the following purposes:

1. **Subtype Refinement**: Define subtypes of existing types based on logical conditions.
2. **Property Annotation**: Attach properties to types in a modular and reusable way.
3. **Type Inference**: Participate in the clustering mechanism for automatic type derivation.

## 7.2. Syntax for Attribute Declaration

Attributes are defined using the `attr` keyword:

```mizar
definition
  let T be Type;
  attr T is attr_name means
    <logical_condition>;
end
```

Attributes may also be parameterized:

```mizar
definition
  let n be Nat;
  attr V is n-dimensional means
    ex B being Basis of V st card B = n;
end
```

Syntax for multiple parameters:

```mizar
definition
  let m, n be Nat;
  attr A is (m,n)-size means ...;
end
```

## 7.3. Usage

### Type Qualification

```mizar
let G be associative unital Magma;
let n be positive even Integer;
```

### Property Testing

```mizar
assume M is commutative;
if n is odd then ...;
```

### Negation and Combinations

```mizar
let S be non empty finite set;
```

### Type-Qualified Attributes

Used to disambiguate multiple inheritance:

```mizar
R is AddLoopStr.associative;
R is MulLoopStr.commutative;
```

Alternatively, the `qua` operator may be used:

```mizar
(R qua AddLoopStr) is associative;
(R qua MulLoopStr) is commutative;
```

## 7.4. Clustering Mechanism

Clustering enables automatic propagation of attributes.

* **Existential Cluster**: Declares that some object of the type with the attribute exists.

```mizar
registration
  cluster empty finite set;
  existence
  proof
    ...;
  end
end
```

* **Conditional Cluster**: Declares implication between attributes.

```mizar
registration
  cluster empty -> finite set;
  coherence
  proof
    ...;
  end
end
```

## 7.5. Attribute Inheritance

Attributes are inherited along structure inheritance paths.

```mizar
inherit LoopStr from Magma where
  field carrier from carrier;
  field binop from binop;
end
```

In this case, a `LoopStr` inherits attributes defined for `Magma`.

## 7.6. Disambiguation in Multiple Inheritance

Use qualified syntax to avoid ambiguity:

```mizar
R is AddLoopStr.associative;
R is MulLoopStr.associative;
```

Alternatively, define disambiguated attributes:

```mizar
definition
  let R be DoubleLoopStr;
  attr R is add_associative means R is AddLoopStr.associative;
end
```

## 7.7. Redefinition

To redefine an attribute for a specialized type:

```mizar
definition
  let n be Nat;
  redefine attr n is even means ex k be Nat st n = 2*k;
  coherence with even_for_integer;
  proof
    :: for Nat, divisibility and multiplication-based definitions coincide
    ...;
  end
end
```

A label such as `:even_for_integer:` can be given to the original definition for reference.

Requirements:

* Logical equivalence with the original definition
* Coherence proof to justify redefinition
* (Optional) use of labels to disambiguate when redefining based on specific parent definition

## 7.8. Implementation Notes

* Attributes are internally treated as unary predicates.
* Clustering generates proof obligations automatically.
* Type inference relies heavily on clustering and attribute propagation.
* Multiple inheritance paths must be explicitly resolved to avoid ambiguity.
* `qua` operator remains available for manual disambiguation in complex type coercions.


# 8. Modes

- [8. Modes](#8-modes)
  - [8.1 Definition and Purpose of Modes](#81-definition-and-purpose-of-modes)
  - [8.2 Syntax for Declaring and Using Modes](#82-syntax-for-declaring-and-using-modes)
    - [Mode Definition](#mode-definition)
    - [Mode Application](#mode-application)
  - [8.3 Type Inference with Modes](#83-type-inference-with-modes)
  - [8.4 Mode Implementation](#84-mode-implementation)
  - [8.5 Relationship between Modes and Structures](#85-relationship-between-modes-and-structures)
  - [8.6 Unified Mode Syntax](#86-unified-mode-syntax)
  - [8.7 Dependent Modes](#87-dependent-modes)
  - [8.8 Correctness Conditions](#88-correctness-conditions)

## 8.1 Definition and Purpose of Modes

Modes are user-defined type constructors built on top of radix-types such as `set` or `struct`. They allow:

* **Abstraction** of mathematical concepts as types
* **Refinement** of types using attributes
* **Composition** of complex types
* **Dependency** on values (i.e., dependent types)

Modes are a central mechanism for type classification in Mizar Evolution, offering an abstract and modular alternative to structures.

## 8.2 Syntax for Declaring and Using Modes

### Mode Definition

```mizar
definition
  mode <mode_name> is <attribute_chain> <type_expression>;
end
```

Here, `<attribute_chain>` is a (possibly empty) sequence of unary predicates that refine the base type. Attributes must be defined using the `attr` keyword (see Chapter 7).

Examples:

```mizar
definition
  mode Integer is integer Number;
  mode Prime is prime Integer;
  mode Group is non empty associative invertible unital Magma;
end
```

### Mode Application

Modes are used in variable declarations, expressions, and type restrictions:

```mizar
let G be Group;
let n be Prime;
```

## 8.3 Type Inference with Modes

Mizar automatically infers type relations for variables declared with modes:

* Inference follows attribute clusters and structural inheritance
* Inference supports dependent modes and parameterized types

Examples:

```mizar
let n be Prime;  :: implies n is Integer and Number
let S be Subset of X;  :: implies S is set and S ⊆ X
```

## 8.4 Mode Implementation

Internally, each mode is interpreted as:

1. A unary predicate for membership
2. A cluster registration linking attributes and base types

This supports a uniform and efficient type checking mechanism.

```mizar
definition
  mode M is <attribute_chain> <type_expression>;
end
```

is equivalent to defining a predicate and a cluster registration.

## 8.5 Relationship between Modes and Structures

Modes and structures serve complementary roles. Use **structures** when you need to define composite types with internal fields (e.g., algebraic structures like rings or groups). Use **modes** when you want to classify or restrict existing types by logical properties without adding internal structure (e.g., prime numbers, continuous functions).

| Aspect     | Modes                                | Structures                         |
| ---------- | ------------------------------------ | ---------------------------------- |
| Definition | Abstract (via attributes)            | Concrete (via fields/properties)   |
| Usage      | Conceptual classification            | Data modeling and component access |
| Conversion | `qua` operator for structural access | Field/method access is explicit    |

Example:

```mizar
definition
  struct MetricStruct where
    field carrier -> set;
    field distance -> Function of [:carrier, carrier:], REAL;
  end

definition
  mode MetricSpace is reflective discerning symmetric triangle MetricStruct;
end
```

## 8.6 Unified Mode Syntax

Mizar Evolution enforces the `is` syntax for mode definitions, replacing the legacy `means` form. This ensures:

* Simplified parsing and inference
* Uniform representation across the language
* Clear separation between types (modes) and predicates (logical properties)

Instead of:

```mizar
definition
  mode Prime means <predicate>;
end
```

Use:

```mizar
definition
  let n be Nat;
  attr n is prime means <definition>;

  mode Prime is prime Integer;
end
```

## 8.7 Dependent Modes

Modes can be parameterized using `of` or `over`:

```mizar
definition
  mode Subset of X is X-subset_like set;
  mode Matrix over R is R-matrix_like set;
end

let A be Matrix over REAL;
```

These forms are syntactic sugar for template-style definitions. For example, `Matrix over REAL` is equivalent to `Matrix[REAL]` in other notations.

Multiple parameters are supported:

```mizar
definition
  mode FinDimVectorSpace over F, n is n-dimensional vector_space_like structure over F;
end

let V be FinDimVectorSpace over COMPLEX, 5;
```

## 8.8 Correctness Conditions

Mode definitions require existence guarantees, typically provided by cluster registrations:

```mizar
registration
  cluster prime Integer;
  existence
  proof
    take 2; thus 2 is prime;
  end
end

definition
  mode Prime is prime Integer;
end
```

To avoid warnings, ensure all mode base types with attribute chains have existential registrations.

Note: In Mizar Evolution, existence checks for modes follow a two-stage policy. At the point of mode declaration (using the mode keyword), the system issues a warning if no existential registration is found. If such a mode is subsequently used (e.g., in variable declarations), and the required existence proof is still missing, a hard error is raised. This encourages early validation while supporting modular development.


# 9. Type Inference and Conversion

- [9. Type Inference and Conversion](#9-type-inference-and-conversion)
    - [9.1. Basic Type Inference](#91-basic-type-inference)
    - [9.2. Type Conversion](#92-type-conversion)
        - [9.2.1. Implicit Conversion](#921-implicit-conversion)
        - [9.2.2. Explicit Conversion](#922-explicit-conversion)
    - [9.3. Type Checking Process](#93-type-checking-process)

## 9.1. Basic Type Inference

Type inference is based on inheritance, attribute clusters, and structural compatibility.

```mizar
let G be Group;
reconsider M = G as Magma;  :: Group is inferred to be a Magma
```

Declarations (`let`), `reconsider`, and mode applications all use the inference engine.

## 9.2. Type Conversion

Two kinds of conversions are supported: implicit and explicit.

### 9.2.1. Implicit Conversion

Automatically applied by the verifier:

* Upcasting (e.g., `Group` → `Magma`)
* Attribute implications via clustering
* Mode/structure-based compatibility

### 9.2.2. Explicit Conversion

Used when inference is insufficient or ambiguous:

* **`qua` operator**:

  ```mizar
  (R qua AddLoopStr) is associative;
  ```

* **`reconsider` statement**:

  ```mizar
  reconsider f as Function of X, Y;
  ```

These may trigger proof obligations to ensure type validity.

## 9.3. Type Checking Process

1. Parse type declarations and usage
2. Generate proof obligations for conversions
3. Resolve inheritance and attribute clusters
4. Apply conversions (implicit/explicit)

Type checking guarantees semantic coherence of all terms.


# 10. Predicates

## 10.1 Predicate Declarations

Predicates express properties and relations. Each predicate has a name, typed parameters, and a logical definition.

```mizar
definition
  let X, Y be set;
  pred X c= Y means
    for x being object st x in X holds x in Y;
end
```

Types are enforced on parameters. Predicates must yield boolean values.

Predicates can be:

* **Built-in**: e.g., `x in X`, `x = y`, `x <> y`
* **User-defined**: declared with `pred` and `means`
* **Overloaded**: disambiguated by parameter types

## 10.2 Dependent and Typed Parameters

Parameter types can depend on earlier parameters:

```mizar
definition
  let G be Group;
  let H be Subgroup of G;
  let a, b be Element of G;
  pred a, b are_congruent_mod H means
    a * b" in H;
end
```

You may also constrain types using attributes:

```mizar
definition
  let G be non empty associative Magma;
  let a, b be Element of G;
  pred a, b are_commute means
    G.binop(a, b) = G.binop(b, a);
end
```

## 10.3 Predicate Redefinition

Existing predicates can be redefined for more specific types. This improves clarity and removes redundant conditions.

```mizar
definition
  let x be object, f be Function;
  pred x is_a_fixpoint_of f means
    :fixpoint_general: x in dom f & x = f.x;
end

definition
  let A be non empty set, a be Element of A, f be Function of A, A;
  redefine pred a is_a_fixpoint_of f means
    a = f.a;
  coherence with fixpoint_general
  proof
    :: dom f = A, so membership is implied
  end
end
```

Redefinition syntax:

* Use `redefine pred`
* Refer to original using a label (e.g., `:fixpoint_general:`)
* Provide a `coherence` proof to show logical equivalence

## 10.4 Symbol Resolution and Imports

User-defined predicates are made available by importing their defining modules. Conflicts between names are resolved by:

* **Longest-match rule** during lexing
* **Qualified names** when needed:

```mizar
import algebra.group as grp;
let G be set;
assume G is grp.subgroup_of;
```

Ambiguous symbols can also be resolved using the `qua` operator when involving structural types, though this is more common in functor or expression contexts.

Note: Predicate symbols must be unambiguous only when they are actually used.


# 11. Functors

- [11. Functors](#11-functors)
  - [11.1. Overview and Syntax](#111-overview-and-syntax)
  - [11.2. Definition Styles: `equals` vs `means`](#112-definition-styles-equals-vs-means)
  - [11.3. Partial Functions and `assume`](#113-partial-functions-and-assume)
  - [11.4. Dependent Return Types](#114-dependent-return-types)
  - [11.5. Redefinition and Type Refinement](#115-redefinition-and-type-refinement)
  - [11.6. Correctness Conditions](#116-correctness-conditions)
  - [11.7. Notation Styles](#117-notation-styles)
  - [11.8. Operator Precedence and Associativity](#118-operator-precedence-and-associativity)

## 11.1. Overview and Syntax

Functors introduce symbolic functions using the `func` keyword:

```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end
```

* `it` denotes the return value.
* Return type is specified after `->`.
* Functor symbols can be arbitrary non-whitespace character sequences.
* Lexical analysis follows the longest-match rule and import-sensitive symbol resolution. In case of conflicts between modules, fully qualified names or aliasing must be used to disambiguate symbol references.

## 11.2. Definition Styles: `equals` vs `means`

Mizar supports two styles of functor definitions:

* **`equals`**: Provides an explicit value. The system considers the functor well-defined by construction, so no additional proofs are needed.

```mizar
func twice(n) -> Nat equals 2 * n;
```

* **`means`**: Specifies the defining condition for the result, using `it` as a placeholder. This style requires the user to prove that a unique such result exists, using `existence` and `uniqueness` blocks.

```mizar
definition
  let x, y be Real;
  func x / y -> Real means it * y = x;
  existence
  proof ... end
  uniqueness
  proof ... end
end
```

Use `means` when the value cannot be defined constructively or involves complex conditions.

## 11.3. Partial Functions and `assume`

`assume` clauses constrain the domain of definition:

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func x / y -> Real means it * y = x;
end
```

* Outside the assumed domain, result is undefined.
* Definedness checking is more complex than type checking. Therefore, it is recommended to encode preconditions such as `y ≠ 0` into the argument types when possible—for example, by requiring `y` to be a non-zero Real. This improves clarity and reduces the burden on semantic verification.

## 11.4. Dependent Return Types

Return types can depend on input values. Such dependent return types may affect type inference and require explicit annotations or proof obligations during verification:

```mizar
definition
  let G be Group;
  func center(G) -> Subgroup of G means ...
end
```

Multiple dependencies are supported:

```mizar
definition
  let H, K be Subgroup of G;
  func H * K -> Subset of G means ...
end
```

## 11.5. Redefinition and Type Refinement

Return types can be specialized via `redefine`:

```mizar
definition
  let x be Real;
  func |.x.| -> Real means ...;
end

definition
  let x be non negative Real;
  redefine func |.x.| -> non negative Real means it = x;
  coherence with abs_general
  proof ... end
end
```

* The redefined type must be a subtype of the original. Subtyping is determined by structural inclusion, attribute implication, or explicit registration via the clustering mechanism.
* All previous uses must remain type-safe. For example, redefining a functor with a stricter return type such as `positive Integer` from `Integer` will fail if the functor is used in a context that allows non-positive integers.

## 11.6. Correctness Conditions

* Functors defined via `means` require `existence` and `uniqueness` proofs.
* Functors defined via `equals` are well-defined by construction.

## 11.7. Notation Styles

Supported notations:

* **Infix**: `func x + y`
* **Prefix**: `func - x`
* **Postfix**: `func n !`
* **Bracket**: `func [: X, Y :]`

Examples:

```mizar
func n ! -> Nat equals Product(id(Seg n));
```

## 11.8. Operator Precedence and Associativity

Declared via annotations:

```mizar
@symbol_precedence(+, 80, left_associative);
```

* Range: 0–255 (default: 64)
* Must be consistent across modules. Precedence consistency is checked statically during the module linking phase. Any conflict results in a descriptive link-time error.
* Conflicting declarations cause link-time errors

Associativity types:

* `left_associative`: `(x + y) + z`
* `right_associative`: `x ^ (y ^ z)`
* `non_associative`: e.g., relational operators


# 12. Symbol Management

- [12. Symbol Management](#12-symbol-management)
  - [12.1. Synonyms and Antonyms](#121-synonyms-and-antonyms)
    - [Examples](#examples)
    - [Benefits](#benefits)
  - [12.2. Scope and Visibility](#122-scope-and-visibility)
    - [Scope Hierarchy](#scope-hierarchy)
    - [Precedence Rules](#precedence-rules)
  - [12.3. Import Behavior and Conflict Resolution](#123-import-behavior-and-conflict-resolution)
    - [Import Syntax](#import-syntax)
    - [Conflict Resolution Strategies](#conflict-resolution-strategies)
  - [12.4. Public and Private Symbols](#124-public-and-private-symbols)
    - [Visibility Defaults](#visibility-defaults)
    - [Private symbols are excluded from import and apply to:](#private-symbols-are-excluded-from-import-and-apply-to)

## 12.1. Synonyms and Antonyms

Mizar allows the definition of **synonyms** and **antonyms** for predicates, functors, modes, and attributes.

### Examples

* **Predicates**

  ```mizar
  pred a < b means ...;
  synonym b > a for a < b;
  antonym b >= a for a < b;
  ```

* **Functors**

  ```mizar
  func f" -> Function means ...;
  synonym inv f for f";  :: must follow the original definition
  ```

* **Modes**

  ```mizar
  mode FinSequence of G is ...;
  synonym FinSeq of G for FinSequence of G;
  ```

* **Attributes**

  ```mizar
  attr R is commutative means ...;
  synonym R is abel for R is commutative;

  attr a is finite means ...;
  antonym a is infinite for a is finite;
  ```

### Benefits

* Support for alternative mathematical notations and word orders
* Natural expression of negation without explicit "not"
* Maintain semantic equivalence while improving readability
* Improve compatibility with mathematical conventions

## 12.2. Scope and Visibility

### Scope Hierarchy

* **Module-level definitions** are visible throughout the module:

  ```mizar
  pred x divides y means ...;
  ```

* **Imported symbols** are made available via `import`:

  ```mizar
  import mml.algebra.group;
  ```

### Precedence Rules

* Local definitions take precedence over imported symbols
* Redefinitions require the `redefine` keyword
* Identifiers override symbol names when forming valid patterns

## 12.3. Import Behavior and Conflict Resolution

### Import Syntax

```mizar
import mml.algebra.group;
import mml.topology.space as top;
```

### Conflict Resolution Strategies

1. **Namespace Qualification**

   ```mizar
   let G be algebra.group.Group;
   let T be top_group.Group;
   ```

2. **Module Precedence**

   ```mizar
   :: Suppose mml.set_theory.cardinal defines:
   :: pred A card_leq B means card A <= card B;
   import mml.set_theory.cardinal;

   pred A card_leq B means ...;  :: Local redefinition takes precedence
   ```

3. **Longest-Match Rule**

   This applies during lexical analysis

   * When `+` and `++` are defined, `a++b` is parsed as `++`


## 12.4. Public and Private Symbols

### Visibility Defaults

* `pred`, `func`, `mode`, `attr`, `struct`, `theorem` are public unless declared `private`
* `synonym`/`antonym` are imported with their base symbols unless declared `private`

```mizar
private pred helper(x, y) means ...;
private func intermediate(x) -> Real equals ...;
```

### Private symbols are excluded from import and apply to:

* Predicates, functors, modes, attributes, structures, theorems, etc.

Note: private declarations are also invisible to re-exporting modules


# 13. Basic Term Expressions

- [13. Basic Term Expressions](#13-basic-term-expressions)
  - [13.1. Primary Expressions](#131-primary-expressions)
    - [13.1.1. Variable Identifiers](#1311-variable-identifiers)
    - [13.1.2. The `it` Keyword](#1312-the-it-keyword)
    - [13.1.3. Parenthesized Expressions](#1313-parenthesized-expressions)
  - [13.2. Functor Applications](#132-functor-applications)
    - [13.2.1. Classification of Functors](#1321-classification-of-functors)
    - [13.2.2. Symbolic Functor Applications](#1322-symbolic-functor-applications)
    - [13.2.3. Inline Functor Applications](#1323-inline-functor-applications)

## 13.1. Primary Expressions

Primary expressions represent atomic values, references, and basic constructs that form the building blocks of more complex terms.

### 13.1.1. Variable Identifiers

Variable identifiers are references to previously declared variables. Their usage follows the general scoping rules of the language.

See [則4](./04.variables_and_constants.md) for detailed rules on variable declaration, scope, shadowing, and reserved identifiers.

**Example:**
```mizar
let x be Nat;
x + 1;
```

### 13.1.2. The `it` Keyword

`it` refers to the object currently being defined within a `func` block.

**Usage:**
```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end
```

**Restrictions:**
- Only allowed inside a `func` definition
- Refers exclusively to the return object being defined

### 13.1.3. Parenthesized Expressions

Used for grouping and precedence control.

**Syntax:**
```mizar
("(" Term-Expression ")")
```

**Semantics:**
- Parentheses override default precedence
- Nesting is arbitrary
- Type of expression is preserved

**Examples:**
```mizar
(a + b) * c
(x > 0) & (y > 0)
(((a + b) * c) + (d / (e - f)))
```

## 13.2. Functor Applications

### 13.2.1. Classification of Functors

- **Symbolic Functors:** Declared via `func`; support infix, prefix, etc.
- **Inline Functors:** Declared via `deffunc`; used only within proofs

### 13.2.2. Symbolic Functor Applications

**Syntax:**
```lark
term: [args] functor_symbol [args]
    | left_functor_bracket [args] right_functor_bracket

args: variable
    | "(" variable_list ")"

variable_list: variable ("," variable)*
```

**Forms:**
- Infix: `x + y`
- Prefix: `- x`
- Postfix: `x!`
- Bracket: `[: a, b :]`

**Notes:**
- Functor syntax is declared explicitly
- Parentheses required for multiple-argument disambiguation

### 13.2.3. Inline Functor Applications

**Definition Syntax:**
```mizar
deffunc <name>(<args>) -> <type> equals <expr>;
```

**Application Example:**
```mizar
proof
  deffunc add3(a be Nat, b be Nat, c be Nat) -> Nat
  equals a + b + c;
  
  add3(1, 2, 3);
end
```

**Semantics:** Inline functors are proof-local and expanded by substitution.


# 14. Advanced Term Expressions

- [14. Advanced Term Expressions](#14-advanced-term-expressions)
    - [14.1. Structure Expressions](#141-structure-expressions)
        - [14.1.1. Structure Constructor](#1411-structure-constructor)
        - [14.1.2. Structure Reference](#1412-structure-reference)
        - [14.1.3. Selector Access](#1413-selector-access)
    - [14.2. Set Construction](#142-set-construction)
        - [14.2.1. Fraenkel Operator (Set Comprehension)](#1421-fraenkel-operator-set-comprehension)
    - [14.3. Type Conversion](#143-type-conversion)
        - [14.3.1. `qua` Operator](#1431-qua-operator)
        - [14.3.2. Reconsider Statement](#1432-reconsider-statement)
    - [14.4. Operator Precedence and Associativity](#144-operator-precedence-and-associativity)
        - [14.4.1. Precedence Rules](#1441-precedence-rules)
        - [14.4.2. Associativity](#1442-associativity)
        - [14.4.3. Disambiguation Guidelines](#1443-disambiguation-guidelines)

## 14.1. Structure Expressions

Structure expressions allow construction and manipulation of structured data values based on user-defined `struct` types.

### 14.1.1. Structure Constructor

A structure value is created by supplying field-value pairs.

**Syntax:**
```mizar
StructName(field1: val1, field2: val2, ..., fieldN: valN)
```

**Example:**
```mizar
Point(x: 3, y: 4)
Rectangle(width: 10, height: 5)
```

**Notes:**
- All fields must be specified unless default values are provided.
- Field names must match the structure's declaration.
- Order of fields is irrelevant.

### 14.1.2. Structure Reference

Structure expressions such as `Point(x: 1, y: 2)` yield values of the corresponding structure type. These values can be passed to functors, used in assertions, or bound to variables via statements.

The binding of structure values to variables (e.g., `let p = Point(...)`) is part of the statement language and is described in the following chapter.

### 14.1.3. Selector Access

Fields of a structure are accessed using dot notation.
```mizar
p.x + p.y
```

## 14.2. Set Construction

### 14.2.1. Fraenkel Operator (Set Comprehension)

**Syntax:**
```mizar
{ x where x is T : P[x] }
```

**Example:**
```mizar
{ n where n is Nat : n mod 2 = 0 }
```

Constructs a subset of type `T` satisfying predicate `P[x]`.

## 14.3. Type Conversion

### 14.3.1. `qua` Operator

Used to explicitly reinterpret a value as a **supertype or compatible structural type** (i.e., up-cast or safe reinterpretation).

**Example:**
```mizar
(R qua AddLoopStr) is associative
```

### 14.3.2. Reconsider Statement

Allows reinterpreting a term as a different type with appropriate proof obligations.
```mizar
reconsider f as Function of A, B;
```

## 14.4. Operator Precedence and Associativity

### 14.4.1. Precedence Rules

Each symbolic functor has an associated precedence level (0–255).

**Declaration:**
```mizar
@symbol_precedence(*, 100, left_associative)
```

### 14.4.2. Associativity

Defines how sequences of the same operator group.
- `left_associative`: `(x + y) + z`
- `right_associative`: `x ^ (y ^ z)`
- `non_associative`: `x = y = z` is invalid

### 14.4.3. Disambiguation Guidelines

- Use parentheses liberally
- Use qualified names if multiple functors share symbols
- Avoid ambiguous constructs that rely on implicit grouping


# 15. Formula Basics

- [15. Formula Basics](#15-formula-basics)
  - [15.1 Overview](#151-overview)
  - [15.2 Syntax Summary](#152-syntax-summary)
  - [15.3 Atomic Formula Expressions](#153-atomic-formula-expressions)
    - [Predicate applications](#predicate-applications)
    - [Type and property assertions](#type-and-property-assertions)
    - [Special constants](#special-constants)
  - [15.4 Special Formula Forms](#154-special-formula-forms)
  - [15.5 Examples and Usage Patterns](#155-examples-and-usage-patterns)

## 15.1 Overview

A formula is a syntactic representation of a logical proposition. Unlike term expressions, which denote mathematical objects, formulas denote boolean-valued statements and are used within theorems, proofs, and control structures. Formula expressions are defined recursively and support logical composition, quantification, and special syntactic forms.

## 15.2 Syntax Summary

The syntax of formula expressions is defined by the following Lark grammar:

```lark
?formula: "(" formula ")"
        | atomic
        | quantified
        | formula "&" formula               -> and
        | formula "&" "..." "&" formula     -> and_multi
        | formula "or" formula              -> or
        | formula "or" "..." "or" formula   -> or_multi
        | formula "implies" formula         -> implies
        | formula "iff" formula             -> iff
        | "not" formula                     -> not
        | "contradiction"                   -> contradiction
        | "thesis"                          -> thesis

?atomic: predicate_application
       | inline_predicate_application
       | type_assertion
       | attribute_assertion

predicate_application: term_expr_list? negation? predicate term_expr_list?
inline_predicate_application: inline_predicate "(" term_expr_list? ")"
type_assertion: term_expr "is" type
attribute_assertion: term_expr "is" adjective+

negation: "does" "not" | "do" "not"
term_expr_list: term_expr ("," term_expr)*

quantified: "for" qualified_vars ["st" formula] ("holds" formula | quantified)
          | "ex" qualified_vars "st" formula

qualified_vars: implicit_vars
              | explicit_vars
              | explicit_vars "," implicit_vars

implicit_vars: var_list
explicit_vars: qualified_segment ("," qualified_segment)*
qualified_segment: var_list qualification
var_list: var ("," var)*
qualification: ("being" | "be") type
```

## 15.3 Atomic Formula Expressions

The atomic portion of the formula grammar, as defined in Lark, is reproduced here for clarity:

```lark
?atomic: predicate_application
       | inline_predicate_application
       | type_assertion
       | attribute_assertion

predicate_application: term_expr_list? negation? predicate term_expr_list?
inline_predicate_application: inline_predicate "(" term_expr_list? ")"
type_assertion: term_expr "is" type
attribute_assertion: term_expr "is" adjective+

negation: "does" "not" | "do" "not"
term_expr_list: term_expr ("," term_expr)*
```

### Predicate applications

A predicate may be applied to one or more arguments. The `does not` or `do not` modifier negates the predicate. For example:

```mizar
x does not divide y;
x, y do not commute;
```

### Type and property assertions

Type assertions use the `is` keyword:

```mizar
x is Nat;
y is positive even Integer;
```

Multiple adjectives can follow `is`, forming an attribute chain. These are interpreted conjunctively.

### Special constants

* `thesis` is a formula that means tautology and typically denotes the current goal in a proof block.
* `contradiction` is a formula that is always false and typically appears in proofs by contradiction

## 15.4 Special Formula Forms

The following are also recognized as special forms:

* Attribute tests with qualified types:

  ```mizar
  G is Group.associative;
  (G qua Magma) is associative;
  ```

* Negated type assertions:

  ```mizar
  x is not finite;
  ```

  This is equivalent to `not (x is finite)`.

## 15.5 Examples and Usage Patterns

```mizar
x is Nat;
x is non negative even Integer;
x, y are_congruent_mod N;
a does not divide b;
x is not finite;
thesis;
contradiction;
```

These forms serve as the building blocks of larger formulas, which can be composed using logical connectives and quantifiers as described in the next chapter.


# 16. Quantification and Logical Connectives

- [16. Quantification and Logical Connectives](#16-quantification-and-logical-connectives)
    - [16.1 Logical Connectives](#161-logical-connectives)
        - [Conjunction (`&`, `& ... &`)](#conjunction----)
        - [Disjunction (`or`, `or ... or`)](#disjunction-or-or--or)
        - [Implication (`implies`)](#implication-implies)
        - [Bi-implication (`iff`)](#bi-implication-iff)
        - [Negation (`not`)](#negation-not)
        - [Grouping with Parentheses](#grouping-with-parentheses)
    - [16.2 Quantified Formula Expressions](#162-quantified-formula-expressions)
        - [Universal Quantification (`for`)](#universal-quantification-for)
        - [Existential Quantification (`ex`)](#existential-quantification-ex)
        - [Qualified Variable Syntax](#qualified-variable-syntax)
    - [16.3 Associativity and Grouping Guidelines](#163-associativity-and-grouping-guidelines)

This chapter describes the remaining logical formula constructs not covered in the former chapter, based on the following Lark grammar:

```lark
?formula: "(" formula ")"
        | atomic
        | quantified
        | formula "&" formula               -> and
        | formula "&" "..." "&" formula     -> and_multi
        | formula "or" formula              -> or
        | formula "or" "..." "or" formula   -> or_multi
        | formula "implies" formula         -> implies
        | formula "iff" formula             -> iff
        | "not" formula                     -> not
        | "contradiction"
        | "thesis"
```

Among these, `quantified`, `and`, `or`, `implies`, `iff`, `not`, and the multi-connective variants are newly introduced here.

## 16.1 Logical Connectives

Logical connectives allow the construction of compound formulas by combining simpler ones.

### Conjunction (`&`, `& ... &`)

```lark
formula "&" formula               -> and
formula "&" "..." "&" formula     -> and_multi
```

Binary conjunction represents logical "and" and is left-associative by default:

```mizar
x is Nat & x > 0;
```

The `& ... &` form is a special repetition syntax to represent a series of similar conjuncts over a range of integer values. For example:

```mizar
assume m <> 0 & ... & m <> 3;
```

This is interpreted as a shorthand for:

```mizar
assume m <> 0 & m <> 1 & m <> 2 & m <> 3;
```

### Disjunction (`or`, `or ... or`)

```lark
formula "or" formula              -> or
formula "or" "..." "or" formula   -> or_multi
```

Disjunctions represent logical "or".&#x20;

```mizar
x = 0 or x = 1;
x mod 2 = 0 or ... or x mod 7 = 0;
```

### Implication (`implies`)

```lark
formula "implies" formula         -> implies
```

Represents logical implication (if-then).&#x20;

```mizar
x > 0 implies x^2 > 0;
```

### Bi-implication (`iff`)

```lark
formula "iff" formula             -> iff
```

Represents logical equivalence.

```mizar
x in A iff x is Element of A;
```

### Negation (`not`)

```lark
"not" formula                     -> not
```

Unary operator representing logical negation. It binds more tightly than any binary connective.

```mizar
not x in A;
not (x > 0 or y < 0);
```

Note: syntactic forms like `x is not finite` are allowed instead of  `not (x is finite)`.

### Grouping with Parentheses

Parentheses can override the default association and grouping of connectives.

```mizar
not x > 0 & y > 0;  -- parsed as (not x > 0) & y > 0
(a or b) implies c;
```

To avoid ambiguity, parentheses are strongly recommended around compound subformulas.

## 16.2 Quantified Formula Expressions

```lark
quantified: "for" qualified_vars ["st" formula] ("holds" formula | quantified)
          | "ex" qualified_vars "st" formula
```

Quantified formulas express logical universality (`for`) and existentiality (`ex`).

### Universal Quantification (`for`)

```mizar
for x being Nat holds x + 1 > x;
```

An optional `st` condition may restrict the range of variables:

```mizar
for x being Real st x > 0 holds x^2 > 0;
```

Nesting is allowed:

```mizar
for x being Real st x > 0
  for y being Real st y > x
    holds x + y > 0;
```

### Existential Quantification (`ex`)

```mizar
ex n being Nat st n > 100;
```

States that there exists a value of the given type satisfying the condition.

### Qualified Variable Syntax

```lark
qualified_vars: implicit_vars
              | explicit_vars
              | explicit_vars "," implicit_vars

explicit_vars: qualified_segment ("," qualified_segment)*
qualified_segment: var_list qualification
qualification: ("being" | "be") type
```

Examples:

```mizar
for x, y being Real holds ...;
for a being Nat, b holds ...;  -- b is typed by "reserve" syntax
```

Variable types may be omitted if they are declared via `reserve`.

## 16.3 Associativity and Grouping Guidelines

* `not` binds more tightly than `&` and `or`.
* `&`, `or`, `implies` and `iff`are left-associative.
* Grouping with parentheses is strongly encouraged for clarity.

**Examples:**

```mizar
not x > 0 & y > 0;         -- parsed as (not x > 0) & y > 0
a or b implies c;          -- parsed as (a or b) implies c
(x implies y) implies z;   -- parenthesized for clarity
```

---

This chapter completes the logical formula syntax by introducing quantifiers and logical connectives. These constructs enable structured expression of logical reasoning necessary for theorem formulation and proof.


# 17. Statements

- [17. Statements](#17-statements)
    - [17.1 Overview](#171-overview)
    - [17.2 Variable and Constant Introduction](#172-variable-and-constant-introduction)
        - [17.2.1 Generalization Statement (`let`)](#1721-generalization-statement-let)
        - [17.2.2 Constant Definition (`set`)](#1722-constant-definition-set)
        - [17.2.3 Inline Function Definition (`deffunc`)](#1723-inline-function-definition-deffunc)
        - [17.2.4 Inline Predicate Definition (`defpred`)](#1724-inline-predicate-definition-defpred)
    - [17.3 Assumptions and Assertions](#173-assumptions-and-assertions)
        - [17.3.1 Single Assumption (`assume`)](#1731-single-assumption-assume)
        - [17.3.2 Collective Assumption (`assume that`)](#1732-collective-assumption-assume-that)
        - [17.3.3 Existential Assumption (`given`)](#1733-existential-assumption-given)
        - [17.3.4 Choice Statement (`consider`)](#1734-choice-statement-consider)
    - [17.4 Conclusions and Derivations](#174-conclusions-and-derivations)
        - [17.4.1 Direct Conclusion (`thus`)](#1741-direct-conclusion-thus)
        - [17.4.2 Sequential Conclusion (`hence`)](#1742-sequential-conclusion-hence)
        - [17.4.3 Block Conclusion (`hereby`)](#1743-block-conclusion-hereby)
        - [17.4.4 Witness Introduction (`take`)](#1744-witness-introduction-take)
    - [17.5 Type Management](#175-type-management)
        - [17.5.1 Type Reconsideration (`reconsider`)](#1751-type-reconsideration-reconsider)
        - [17.5.2 Term Reduction (`reduce`)](#1752-term-reduction-reduce)
    - [17.6 Proof Organization](#176-proof-organization)
        - [17.6.1 Labeled Reasoning Block (`now`)](#1761-labeled-reasoning-block-now)
        - [17.6.2 Case Analysis (`case`)](#1762-case-analysis-case)
        - [17.6.3 Supposition (`suppose`)](#1763-supposition-suppose)
    - [17.7 Iterative Equality](#177-iterative-equality)
    - [17.8 Justification Forms](#178-justification-forms)
        - [17.8.1 Simple Justification](#1781-simple-justification)
        - [17.8.2 Full Proof](#1782-full-proof)
    - [17.9 Statement Modifiers](#179-statement-modifiers)
        - [17.9.1 Sequential Modifier (`then`)](#1791-sequential-modifier-then)
    - [17.10 Scoping and Context Rules](#1710-scoping-and-context-rules)
    - [17.11 Grammar Summary (Lark Format)](#1711-grammar-summary-lark-format)

## 17.1 Overview

Statements in Mizar form the building blocks of mathematical reasoning. They appear within various contexts including theorem proofs and auxiliary reasoning blocks. This chapter describes all statement forms, their syntax, semantics, and proper usage.

Statements can be broadly categorized into:
- **Declarative statements**: Introduce variables, constants, or assumptions
- **Justification statements**: Assert propositions with supporting evidence
- **Structural statements**: Organize proof flow and reasoning patterns
- **Type-related statements**: Handle type conversions and reinterpretations

## 17.2 Variable and Constant Introduction

### 17.2.1 Generalization Statement (`let`)

The `let` statement introduces universally quantified variables with optional constraints.

**Syntax (Lark):**
```lark
generalization: "let" variable_list qualification? ("such" conditions)? ";"
variable_list: identifier ("," identifier)*
qualification: ("being" | "be") type_expr
conditions: "that" proposition ("and" proposition)*
```

**Examples:**
```mizar
let x be Real;
let y, z be Real such that y < z;
let G be Group;
let H be Subgroup of G;
let n be Nat such that n > 0 and n is prime;
```

**Semantics:**
- In proof contexts: introduces arbitrary but fixed values
- In definition contexts: introduces parameters for the definition
- Variables are not recommended to shadow existing variables
- The `such that` clause adds assumptions about the introduced variables
- Multiple variables are allowed only when they share the same type

### 17.2.2 Constant Definition (`set`)

The `set` statement introduces abbreviations for terms.

**Syntax (Lark):**
```lark
constant_definition: "set" identifier "=" term_expr ";"
```

**Examples:**
```mizar
set x = a + b;
set y = f.x;
set n = card X;
```

**Semantics:**
- Creates syntactic abbreviations expanded during verification
- The type is inferred from the right-hand side expression
- No label is needed (labels are for propositions, not definitions)
- Only single assignments are allowed

### 17.2.3 Inline Function Definition (`deffunc`)

Defines local function abbreviations within proofs.

**Syntax (Lark):**
```lark
inline_functor_definition: "deffunc" identifier "(" typed_params? ")" "equals" term_expr ";"
typed_params: typed_param ("," typed_param)*
typed_param: identifier "be" type_expr
```

**Example:**
```mizar
proof
  deffunc F(n be Nat) equals n * (n + 1);
  deffunc G(x be Real, y be Real) equals x^2 + y^2;
  ...
  F(n) = n * (n + 1);  :: by definition
end
```

### 17.2.4 Inline Predicate Definition (`defpred`)

Defines local predicate abbreviations within proofs.

**Syntax (Lark):**
```lark
inline_predicate_definition: "defpred" identifier "(" typed_params? ")" "means" formula ";"
```

**Example:**
```mizar
proof
  defpred P(n be Nat) means n is prime & n > 2;
  defpred Q(x be Real, y be Real) means x < y & y < x + 1;
  ...
  P(n) implies n is odd;
end
```

## 17.3 Assumptions and Assertions

### 17.3.1 Single Assumption (`assume`)

Introduces a single proposition as an assumption.

**Syntax (Lark):**
```lark
single_assumption: "assume" proposition ";"
proposition: (label_identifier ":")? formula
```

**Examples:**
```mizar
assume x > 0;
assume A1: G is abelian;
```

### 17.3.2 Collective Assumption (`assume that`)

Introduces multiple related assumptions.

**Syntax (Lark):**
```lark
collective_assumption: "assume" conditions ";"
conditions: "that" proposition ("and" proposition)*
```

**Example:**
```mizar
assume that A1: x > 0
        and A2: y > 0
        and x < y;
```

### 17.3.3 Existential Assumption (`given`)

Introduces existentially quantified variables with properties.

**Syntax (Lark):**
```lark
existential_assumption: "given" variable_list qualification? ("such" conditions)? ";"
```

**Examples:**
```mizar
given x being Real such that x^2 = 2;
given G being Group such that G is finite and card G = p;
```

**Semantics:**
- Introduces Skolem constants satisfying the given conditions
- Equivalent to existential instantiation in natural deduction
- Multiple variables are allowed only when they share the same type

### 17.3.4 Choice Statement (`consider`)

Introduces a variable satisfying conditions with justification.

**Syntax (Lark):**
```lark
choice_statement: "consider" identifier qualification "such" conditions simple_justification ";"
```

**Example:**
```mizar
consider x being Real such that x > 0 and f.x = 0 by A1, Th5;
```

**Note:** Only single variable introduction is allowed.

## 17.4 Conclusions and Derivations

### 17.4.1 Direct Conclusion (`thus`)

Asserts a proposition with justification.

**Syntax (Lark):**
```lark
conclusion: "thus" proposition justification ";"
```

**Examples:**
```mizar
thus A3: x > 0 by A1, A2;
thus thesis by Lemma1, Def3;
```

### 17.4.2 Sequential Conclusion (`hence`)

Equivalent to `then thus`, emphasizes derivation from immediately preceding statements.

**Syntax (Lark):**
```lark
conclusion: "hence" proposition justification ";"
```

### 17.4.3 Block Conclusion (`hereby`)

Introduces a reasoning block whose result serves as justification.

**Syntax (Lark):**
```lark
diffuse_conclusion: "hereby" reasoning "end"
```

**Example:**
```mizar
hereby
  assume x > 0;
  then x^2 > 0 by Th1;
  hence thesis;
end
```

### 17.4.4 Witness Introduction (`take`)

Provides a witness for existential claims.

**Syntax (Lark):**
```lark
exemplification: "take" example ";"
example: term_expr | identifier "=" term_expr
```

**Examples:**
```mizar
take 0;
take x = a + b;
```

**Note:** Only single witness introduction is allowed.

## 17.5 Type Management

### 17.5.1 Type Reconsideration (`reconsider`)

Changes the type view of a term with justification.

**Syntax (Lark):**
```lark
type_changing_statement: "reconsider" reconsider_item "as" type_expr simple_justification ";"
reconsider_item: identifier | identifier "=" term_expr
```

**Examples:**
```mizar
reconsider x as Element of NAT by A1;
reconsider f = F|A as Function of A, B by Th3;
```

**Note:** Only single reconsideration is allowed per statement.

### 17.5.2 Term Reduction (`reduce`)

Simplifies terms to canonical forms automatically (part of registration blocks).

**Syntax (Lark):**
```lark
reduction_registration: "reduce" term_expr "to" term_expr ";" correctness_conditions
```

**Example:**
```mizar
registration
  let n be Nat;
  reduce n + 0 to n;
  reducibility;
end
```

## 17.6 Proof Organization

### 17.6.1 Labeled Reasoning Block (`now`)

Creates a labeled sub-proof for later reference.

**Syntax (Lark):**
```lark
diffuse_statement: (label_identifier ":")? "now" reasoning "end"
```

**Example:**
```mizar
A1: now
  assume x > 0;
  then x^2 > 0 by Square_positive;
  thus P[x];
end
```

### 17.6.2 Case Analysis (`case`)

Structures reasoning by cases with justification.

**Syntax (Lark):**
```lark
case_item: "case" (proposition | conditions) ";" reasoning "end"
```

Used within `per cases`:
```mizar
thus P[n]
proof
  per cases by NAT_IND;
  case n = 0;
    thus thesis by Base_case;
  end
  case n > 0;
    thus thesis by Inductive_step;
  end
end
```

### 17.6.3 Supposition (`suppose`)

Alternative case introduction.

**Syntax (Lark):**
```lark
suppose_item: "suppose" (proposition | conditions) ";" reasoning "end"
```

**Example:**
```mizar
per cases;
suppose A1: x > 0;
  thus thesis by A1, Positive_case;
end
suppose A2: x <= 0;
  thus thesis by A2, Non_positive_case;
end
```

## 17.7 Iterative Equality

Chains equality reasoning steps with intermediate justifications.

**Syntax (Lark):**
```lark
iterative_equality: (label_identifier ":")? term_expr "=" term_expr simple_justification 
                   (".=" term_expr simple_justification)* ";"
```

**Example:**
```mizar
A1: f.(x + y) = f.x + f.y by Additive
             .= g.x + f.y by A2
             .= g.x + g.y by A3;
```

**Semantics:**
- Each step must be justified
- Creates a chain of equalities
- The label (if present) refers to the entire chain
- Not an assignment but a justified equality assertion

## 17.8 Justification Forms

### 17.8.1 Simple Justification

**Syntax (Lark):**
```lark
?simple_justification: ("by" references)?
references: reference ("," reference)*
```

**Examples:**
```mizar
by A1, A2;
by mml.algebra.group.Lagrange_theorem;
by Math_induction[n, n^2 >= n];
by Well_founded_induction[Nat, <, P];
```

**Note:** References can now include:
- Local identifiers (labels and theorem names within the current proof)
- Qualified references using namespace paths
- Template instantiations for parameterized theorems (replacing the old scheme mechanism)

### 17.8.2 Full Proof

**Syntax (Lark):**
```lark
proof: "proof" reasoning "end"
```

## 17.9 Statement Modifiers

### 17.9.1 Sequential Modifier (`then`)

The `then` modifier indicates direct derivation from the immediately preceding statement.

**Syntax (Lark):**
```lark
statement: "then"? linkable_statement | diffuse_statement
```

**Example:**
```mizar
assume x > 0;
then x^2 > 0 by Square_positive;
then hence x^2 + 1 > 1;
```

## 17.10 Scoping and Context Rules

1. **Variable Scope**: Variables introduced by `let` are scoped to their enclosing block. While not enforced, unique variables within a block are strongly recommended.
2. **Label Scope**: Labels are scoped to their enclosing reasoning block. While not enforced, unique labels within a block are strongly recommended.
3. **Definition Context**: In definition blocks, `let` introduces definition parameters
4. **Proof Context**: In proof blocks, `let` introduces arbitrary fixed values
5. **Inline Definitions**: `deffunc` and `defpred` are scoped to their proof block

## 17.11 Grammar Summary (Lark Format)

Key statement productions in Lark grammar format:

```lark
// Main statement categories
?statement: linkable_statement
          | diffuse_statement
          | "then" linkable_statement

?linkable_statement: compact_statement
                   | choice_statement
                   | type_changing_statement
                   | iterative_equality

// Variable and constant introduction
generalization: "let" variable_list qualification? ("such" conditions)? ";"
constant_definition: "set" identifier "=" term_expr ";"

// Private definitions
inline_functor_definition: "deffunc" identifier "(" typed_params? ")" "equals" term_expr ";"
inline_predicate_definition: "defpred" identifier "(" typed_params? ")" "means" formula ";"
typed_params: typed_param ("," typed_param)*
typed_param: identifier "be" type_expr

// Assumptions
?assumption: single_assumption
           | collective_assumption
           | existential_assumption

single_assumption: "assume" proposition ";"
collective_assumption: "assume" conditions ";"
existential_assumption: "given" variable_list qualification? ("such" conditions)? ";"
choice_statement: "consider" identifier qualification "such" conditions simple_justification ";"

// Conclusions
?conclusion: ("thus" | "hence") proposition justification ";"
           | diffuse_conclusion

diffuse_conclusion: "hereby" reasoning "end"
exemplification: "take" example ";"
example: term_expr | identifier "=" term_expr

// Type management
type_changing_statement: "reconsider" reconsider_item "as" type_expr simple_justification ";"
reconsider_item: identifier | identifier "=" term_expr

// Structured statements
compact_statement: proposition justification ";"
iterative_equality: (label_identifier ":")? term_expr "=" term_expr simple_justification 
                   (".=" term_expr simple_justification)* ";"
diffuse_statement: (label_identifier ":")? "now" reasoning "end"

// Case analysis
case_reasoning: ("then"? "per" "cases" simple_justification ";") (case_list | suppose_list)
case_list: case_item+
suppose_list: suppose_item+
case_item: "case" (proposition | conditions) ";" reasoning "end"
suppose_item: "suppose" (proposition | conditions) ";" reasoning "end"

// Supporting rules
proposition: (label_identifier ":")? formula
conditions: "that" proposition ("and" proposition)*
variable_list: identifier ("," identifier)*
qualification: ("being" | "be") type_expr

// Justification
?justification: simple_justification | proof
?simple_justification: ("by" references)?
proof: "proof" reasoning "end"

references: reference ("," reference)*
reference: identifier template_args?                    // local reference with optional template
         | qualified_reference template_args?           // qualified reference with optional template

template_args: "[" template_arg_list "]"
template_arg_list: template_arg ("," template_arg)*
template_arg: term_expr | formula | type_expr           // depending on template parameter type

qualified_reference: namespace_path "." identifier
                   | identifier "." identifier          // module-qualified reference

namespace_path: identifier ("." identifier)*

// Common patterns
label_identifier: ID
identifier: ID

// Terminals (defined elsewhere in the complete grammar)
ID: /[a-zA-Z_][a-zA-Z0-9_]*/
```

Note: This grammar is simplified for clarity. See the complete Lark specification for full details including all terminal symbols and precedence rules.
