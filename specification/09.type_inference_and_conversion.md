# 9. Type Inference and Conversion

- [9. Type Inference and Conversion](#9-type-inference-and-conversion)
  - [9.1 Basic Type Inference](#91-basic-type-inference)
  - [9.2 Type Conversion](#92-type-conversion)
  - [9.3 Type Checking Process](#93-type-checking-process)
  - [9.4 Logic Encoding Details](#94-logic-encoding-details)
  - [9.5 Complete Syntax (EBNF)](#95-complete-syntax-ebnf)

## 9.1 Basic Type Inference

Type inference is based on inheritance, attribute clusters, and structural compatibility.

```mizar
let G be Group;
reconsider M = G as Magma;  :: Group is inferred to be a Magma
```

The inference engine is invoked in the following contexts:

| Context | Description |
| --- | --- |
| `let` declarations | Infers variable types from mode definitions |
| `reconsider` | Validates type conversion with proof obligations |
| Mode applications | Resolves parameterized types |
| Attribute testing | Checks attribute membership via clusters |

## 9.2 Type Conversion

Two kinds of conversions are supported: implicit (automatic) and explicit (user-specified).

**Syntax (EBNF)**:

```ebnf
qua_expression   ::= "(" term_expression "qua" type_expression ")" ;
reconsider_stmt  ::= "reconsider" identifier "=" term_expression "as" type_expression
                     [ justification ] ";" ;
justification    ::= "by" reference_list | proof_block ;
reference_list   ::= label { "," label } ;
```

### 9.2.1 Implicit Conversion (Widening)

Automatically applied by the verifier when a subtype is used where a supertype is expected:

* **Upcasting**: e.g., `Group` → `Magma`, `Prime` → `Integer`
* **Attribute implications**: via cluster registrations
* **Mode/structure-based compatibility**: structural subtyping

**Example**:

```mizar
let n be Prime;
:: n can be used where Integer is expected (implicit widening)
let m be Integer;
reconsider m = n as Integer;  :: explicit, but no proof needed
```

### 9.2.2 Explicit Conversion (Narrowing)

Required when converting to a more specific type. Generates proof obligations.

**`qua` operator**: Accesses a value as a specific type without changing it.

```mizar
let R be DoubleLoopStr;
(R qua AddLoopStr) is associative;
(R qua MulLoopStr) is commutative;
```

**`reconsider` statement**: Declares a new variable with a different type, requiring justification.

```mizar
let x be Real;
assume x >= 0;
reconsider y = x as non negative Real by assumption;
```

**`reconsider` with proof block**:

```mizar
let f be Function;
reconsider g = f as Bijection
proof
  thus f is one-to-one & f is onto by ...;
end;
```

## 9.3 Type Checking Process

The type checking process proceeds in the following order:

1. **Parse**: Extract type declarations and usage sites
2. **Resolve**: Apply mode definitions and attribute clusters
3. **Generate obligations**: Create proof goals for conversions
4. **Verify**: Discharge obligations using inference or explicit proofs
5. **Apply conversions**: Insert implicit/explicit casts

```
Declaration: let x be T
⇒  Assert: is_T(x)

Conversion: reconsider y = x as U
⇒  Goal: is_T(x) → is_U(x)
⇒  Proof required if not implied by clusters
```

## 9.4 Logic Encoding Details

This section describes how type inference and conversion map to First-Order Logic.

### 9.4.1 Type Assertions

Variable declarations generate type predicates:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be Integer;` | `is_Integer(x)` |
| `let G be Group;` | `is_Group(G)` |

### 9.4.2 Widening (Implicit Conversion)

Widening relies on subtype axioms:

```
mode Prime is prime Integer
⇒  forall x (is_Prime(x) implies is_Integer(x))
```

When `Prime` is used where `Integer` is expected, the implication is applied automatically.

### 9.4.3 Narrowing (Explicit Conversion)

Narrowing generates proof obligations:

| Mizar Source | FOL Encoding |
| --- | --- |
| `reconsider y = x as Prime` | `Goal: is_Integer(x) ∧ is_prime(x)` |
| `(R qua AddLoopStr)` | `Assumption: is_AddLoopStr(R)` |

### 9.4.4 `qua` Operator Encoding

The `qua` operator creates a type-restricted view:

```
(x qua T).field
⇒  Precondition: is_T(x)
⇒  Access: field(x)
```

## 9.5 Complete Syntax (EBNF)

Summary of type inference and conversion syntax.

```ebnf
(* Explicit Conversion *)
qua_expression   ::= "(" term_expression "qua" type_expression ")" ;
reconsider_stmt  ::= "reconsider" identifier "=" term_expression "as" type_expression
                     [ justification ] ";" ;
justification    ::= "by" reference_list | proof_block ;
reference_list   ::= label { "," label } ;

(* Type Expression - see Chapter 5 *)
type_expression  ::= attribute_chain radix_type ;
attribute_chain  ::= { [ "non" ] attribute_ref } ;
radix_type       ::= builtin_type | mode_name [ type_args ] | struct_name [ type_args ] ;
```
