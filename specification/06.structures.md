# 6. Structures

This chapter defines how composite types (structures) are declared, inherited, and instantiated.

* [6. Structures](#6-structures)
  * [6.1 Concept and Purpose](#61-concept-and-purpose)
  * [6.2 Syntax](#62-syntax)
  * [6.3 Inheritance](#63-inheritance)
  * [6.4 Multiple and Diamond Inheritance](#64-multiple-and-diamond-inheritance)
  * [6.5 Constructors](#65-constructors)
  * [6.6 Dependent Structures](#66-dependent-structures)
  * [6.7 Field Access (Selectors)](#67-field-access-selectors)
  * [6.8 Logic Encoding Details](#68-logic-encoding-details)
  * [6.9 Complete Syntax (EBNF)](#69-complete-syntax-ebnf)

## 6.1 Concept and Purpose

Structures are radix-types used to define composite types with named fields and properties. They serve three purposes:

1. **Data encapsulation**: grouping logically related components
2. **Type formation**: creating new types via structural definitions
3. **Mathematical modeling**: representing algebraic and analytical structures

## 6.2 Syntax

**Syntax (EBNF)**:

```ebnf
struct_def    ::= "struct" struct_name [ type_params ] "where"
                  { struct_member } "end" ";" ;
struct_member ::= field_decl | property_decl ;
field_decl    ::= "field" identifier "->" type_expression ";" ;
property_decl ::= "property" identifier "->" type_expression ";" ;
type_params   ::= ( "of" | "over" ) parameter_list ;
parameter_list ::= identifier { "," identifier } ;
```

* `field`: represents intrinsic components (stored data)
* `property`: represents derived values (computed from fields, often via functors)

**Example**:

```mizar
definition
  struct UnitalMagma where
    field carrier -> set;
    field binop -> BinOp of carrier;
    property unit -> Element of carrier;
  end;
end;
```

## 6.3 Inheritance

Structures may inherit from others via `inherit`. When inheriting, fields and properties can be specialized (narrowed) to more specific types.

### 6.3.1 Syntax (EBNF)

```ebnf
inherit_def     ::= "inherit" struct_name "from" parent_list "where"
                    { inherit_member }
                    [ compatibility_block ] [ coherence_block ]
                    "end" ";" ;

parent_list     ::= parent_type { "," parent_type } ;
parent_type     ::= struct_name | "set" ;

inherit_member  ::= field_redef | property_redef ;

/* Type Specialization Syntax (type is optional if unchanged from parent) */
field_redef     ::= "field" identifier [ "->" type_expression ] "from" (identifier | "it") ";" ;
property_redef  ::= "property" identifier [ "->" type_expression ] "from" identifier ";" ;

coherence_block ::= "coherence" { proof_block | by_refs } ";" ;
compatibility_block ::= "compatibility" { proof_block | by_refs } ";" ;
```

* All base fields/properties must be inherited.
* Inheritance supports renaming and type specialization.
* Type specialization requires proof obligations.

**Example**:

```mizar
definition
  inherit Derived from Base where
    field derived_field from base_field;
    property derived_prop from base_prop;
  end;
end;
```

**Set inheritance** is allowed:

```mizar
inherit 1-sorted from set where
  field carrier from it;
end;
```

### 6.3.2 Coherence (Type Specialization)

When a **property** (derived value) is inherited with a narrower type, a `coherence` proof is required to verify that the computed value actually belongs to the new type.

**Example**:
Suppose `Magma` defines a property `unit` returning `Element of carrier`. We define `Group` where `unit` is specialized to `Unity of carrier` (a narrower type).

```mizar
definition
  inherit Group from Magma where
    /* Field narrowing: No proof needed (creates stricter axiom) */
    field carrier -> non empty set from carrier;

    /* Property narrowing: Proof required */
    property unit -> Unity of carrier from unit
    coherence
    proof
      let G be Group;
      :: Must prove: G.unit is Unity of G.carrier
      :: Assuming G satisfies Group axioms (associativity, etc.)
      thus G.unit is Unity of G.carrier ...;
    end;
  end;
end;
```

## 6.4 Multiple and Diamond Inheritance

Multiple inheritance is allowed if structure names are distinct. Diamond inheritance is supported but must be disambiguated. Consistency of shared fields (e.g., `carrier`) must be proven via `compatibility`.

**Example**:

```mizar
definition
  struct ZeroStr where
    field carrier -> set;
    property zero -> Element of carrier;
  end;

  struct OneStr where
    field carrier -> set;
    property one -> Element of carrier;
  end;

  struct ZeroOneStr where
    field carrier -> set;
    property zero -> Element of carrier;
    property one -> Element of carrier;
  end;

  inherit ZeroOneStr from ZeroStr where
    field carrier from carrier;
    property zero from zero;
  end;

  inherit ZeroOneStr from OneStr where
    field carrier from carrier;
    property one from one;
    compatibility
    proof
      thus for x being ZeroOneStr holds
        (x qua ZeroStr).carrier = (x qua OneStr).carrier;
    end;
  end;
end;
```

## 6.5 Constructors

Structures can be instantiated using default or custom constructors.

**Syntax (EBNF)**:

```ebnf
constructor_def ::= "constructor" struct_name "(" term_expression ")" "where"
                    { field_assign } "end" ";" ;
field_assign    ::= "it" "." identifier "=" field_access ";" ;
field_access    ::= term_expression "." identifier ;
```

### 6.5.1 Default Constructor

Named arguments in any order:

```mizar
let x = OneStr(carrier: A, one: b);
```

### 6.5.2 Custom Constructor

```mizar
definition
  let G be Group;
  constructor OneStr(G) where
    it.carrier = G.carrier;
    it.one = G.unit;
  end;
end;
```

### 6.5.3 Converting Constructors

Allow implicit type coercion:

```mizar
reconsider x = G as OneStr;
```

## 6.6 Dependent Structures

Structures can be parameterized using `over` or `of`.

**Example**:

```mizar
definition
  let R be Ring;
  struct Polynomial over R where
    field coeffs -> FinSequence of R.carrier;
    property degree -> Nat;
  end;
end;
```

* Multiple parameters: `struct Name over T, U`
* Usage: `let p be Polynomial over REAL;`

## 6.7 Field Access (Selectors)

Fields and properties are accessed using dot notation.

**Syntax (EBNF)**:

```ebnf
field_access ::= term_expression "." identifier ;
```

**Examples**:

```mizar
let G be Group;
let c = G.carrier;     :: Access field
let u = G.unit;        :: Access property
let f = G.binop;       :: Access field

:: Chained access (nested structures)
let S be Module over R;
let base_carrier = S.ring.carrier;  :: Access parent structure's field
```

## 6.8 Logic Encoding Details

This section describes how structures map to First-Order Logic. The encoding relies on flattening structure components into global predicates and functions.

### 6.8.1 Structures as Predicates

Each structure type `S` is encoded as a unary predicate `is_S(x)`.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is UnitalMagma` | `is_UnitalMagma(x)` |

### 6.8.2 Fields as Functions and Type Guards

Each `field` is encoded as a global function symbol. Additionally, a **Type Guard Axiom** ensures that the selector returns a value of the correct type when applied to a valid structure.

* **Symbol**: `carrier(x)`
* **Axiom**:
```
forall x (is_UnitalMagma(x) implies is_set(carrier(x)))
```

> [!NOTE]
> Properties are also encoded as function symbols with the same Type Guard pattern.

### 6.8.3 Inheritance as Implication

Inheritance relationships are encoded as universal implications (subsumption).

```
inherit Derived from Base
â‡”  forall x (is_Derived(x) implies is_Base(x))
```

### 6.8.4 Constructor Axioms

Constructors are encoded as functions that generate two types of axioms: **Projection** (field values) and **Typing** (result type).

Given `constructor OneStr(G)` encoded as term `Agg_OneStr(G)`:

1. **Projection Axiom**:
```
carrier(Agg_OneStr(G)) = carrier(G)
```

2. **Typing Axiom**:
```
is_OneStr(Agg_OneStr(G))
```

### 6.8.5 Extensionality (Strictness)

To capture the "Many-Sorted Set" nature of structures, an extensionality axiom dictates that identity is determined solely by fields.

For a strict structure `S` with fields `f1`, ..., `fn`:

```
forall x, y (
  (is_S(x) & is_S(y) & is_strict(x) & is_strict(y))
  implies
  ((f1(x) = f1(y) & ... & fn(x) = fn(y)) iff x = y)
)
```

## 6.9 Complete Syntax (EBNF)

Summary of structure-related syntax.

```ebnf
(* Structure Definition *)
struct_def     ::= "struct" struct_name [ type_params ] "where"
                   { struct_member } "end" ";" ;
struct_member  ::= field_decl | property_decl ;
field_decl     ::= "field" identifier "->" type_expression ";" ;
property_decl  ::= "property" identifier "->" type_expression ";" ;
type_params    ::= ( "of" | "over" ) parameter_list ;

(* Inheritance *)
inherit_def    ::= "inherit" struct_name "from" parent_list "where"
                   { inherit_member }
                   [ compatibility_block ] [ coherence_block ]
                   "end" ";" ;
parent_list    ::= parent_type { "," parent_type } ;
parent_type    ::= struct_name | "set" ;

inherit_member ::= field_redef | property_redef ;
field_redef    ::= "field" identifier [ "->" type_expression ] "from" (identifier | "it") ";" ;
property_redef ::= "property" identifier [ "->" type_expression ] "from" identifier ";" ;

(* Coherence for Type Specialization *)
coherence_block ::= "coherence" { proof_block | by_refs } ";" ;

(* Compatibility for Diamond Inheritance *)
compatibility_block ::= "compatibility" { proof_block | by_refs } ";" ;

(* Constructor *)
constructor_def ::= "constructor" struct_name "(" term_expression ")" "where"
                    { field_assign } "end" ";" ;
field_assign    ::= "it" "." identifier "=" field_access ";" ;

(* Field Access *)
field_access   ::= term_expression "." identifier ;

(* Common *)
struct_name    ::= identifier ;
parameter_list ::= identifier { "," identifier } ;
```
