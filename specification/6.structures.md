# 6. Structures

- [6. Structures](#6-structures)
  - [6.1. Concept and Purpose of Structures](#61-concept-and-purpose-of-structures)
  - [6.2. Syntax for Defining Structures](#62-syntax-for-defining-structures)
  - [6.3. Inheritance Mechanisms](#63-inheritance-mechanisms)
  - [6.4. Multiple Inheritance and Diamond Inheritance](#64-multiple-inheritance-and-diamond-inheritance)
  - [6.5. Constructor](#65-constructor)
  - [6.6. Dependent Structures](#66-dependent-structures)

## 6.1. Concept and Purpose of Structures

Structures in Mizar are fundamental constructs used to define complex types that group related fields and properties. They serve several key purposes:

1. **Data Encapsulation**: Structures allow related pieces of data to be grouped together, similar to record types in other programming languages.
2. **Type Definition**: They form the basis for defining new types in the Mizar system, along with modes.
3. **Mathematical Modeling**: Structures provide a way to formally represent mathematical concepts that have multiple components or properties.

Structures are considered radix-types, meaning they form the foundation for defining new types in the system.

## 6.2. Syntax for Defining Structures

The syntax for defining structures in Mizar has been updated to provide more flexibility. The new syntax is as follows:

```mizar
definition
  struct StructureName where
    field field1 -> Type1;
    field field2 -> Type2;
    ...
    property property1 -> Type1';
    property property2 -> Type2';
    ...
  end
end
```

Key components of this syntax:

- `struct` keyword introduces a structure definition
- `StructureName` is the name of the new structure
- `field` declarations define the data components of the structure
- `property` declarations define properties associated with the structure

The distinction between `field` and `property` lies in their roles: fields represent intrinsic data, while properties represent derived data. For instance, in a group structure, the carrier set and binary operation are fields, while the identity element is a property as it is derived from the properties of the carrier and operation. Typically, property values are computed using functors that take field values as arguments.

Example:

```mizar
definition
  ::=
  `UnitalMagma` is a magma with an identity element.
  `UnitalMagma` consists of a set `carrier` with a single binary operator `binop`.
  Additionally, `UnitalMagma` has an identity element `unit` that is derived from
  the properties of `carrier` and `binop`.
  =::
  struct UnitalMagma where
    field carrier -> set;
    field binop -> BinOp of the carrier;
    property unit -> Element of carrier;
  end
end
```

## 6.3. Inheritance Mechanisms

Mizar supports inheritance for structures, allowing a structure to inherit from existing ones. The syntax for inheritance is:

```mizar
definition
  inherit DerivedStructure from BaseStructure where
    field derivedField1 from baseField1;
    field derivedField2 from baseField2;
    ...
    property derivedProperty1 from baseProperty1;
    property derivedProperty2 from baseProperty2;
    ...
  end
end
```

Inheritance enables the reuse of predicates, functors, and attributes from the base structure through implicit type conversion (in the up-cast direction). A derived structure must inherit all fields and properties from its base structure; omitting any field or property will result in a compilation error. Furthermore, fields must be inherited as fields, and properties must be inherited as properties.

The new syntax separates structure declaration from inheritance declaration, allowing base structures to be added after the initial structure declaration. This separation, combined with field and property renaming, enables more flexible inheritance patterns.

Structures can also inherit from set types:

```mizar
inherit 1-sorted from set where
  field carrier from it;
end
```

Here, `it` refers to the set itself. This inheritance allows all predicates, functors, and attributes applicable to the set to be implicitly applied to the 1-sorted structure.

Inheritance supports type specialization of fields and properties:

```mizar
definition
  inherit T from S where
    ...
  end

  struct A where
    field x -> X;
  end

  struct B where
    field y -> Y;
  end

  inherit B from A where
    field y inherit x;
    consistency;
  end
end
```

Type consistency must be proven, requiring a proof that `for x being X holds x is Y`.

## 6.4. Multiple Inheritance and Diamond Inheritance

Mizar supports multiple inheritance, allowing structures to inherit from multiple base structures:

```mizar
definition
  inherit DerivedStructure from BaseStructure1 where
    ...
  end

  inherit DerivedStructure from BaseStructure2 where
    ...
  end
end
```

To prevent ambiguity, inheriting from the same named structure multiple times is prohibited. When multiple inheritance from the same structure is required, the structure must first be inherited and renamed. Diamond inheritance occurs when a structure inherits from two structures sharing a common ancestor:

```mizar
definition
  struct UnitStr where
    field carrier -> set;
    property unit -> Element of the carrier;
  end

  struct ZeroStr where
    field carrier -> set;
    property zero -> Element of the carrier;
  end

  inherit ZeroStr from UnitStr where
    field carrier from carrier;
    property zero from unit;
  end

  struct OneStr where
    field carrier -> set;
    property one -> Element of the carrier;
  end

  inherit OneStr from UnitStr where
    field carrier from carrier;
    property one from unit;
  end

  struct ZeroOneStr where
    field carrier -> set;
    property zero -> Element of the carrier;
    property one -> Element of the carrier;
  end

  inherit ZeroOneStr from ZeroStr where
    field carrier from carrier;
    property zero from zero;
  end

  inherit ZeroOneStr from OneStr where
    field carrier from carrier;
    property one from one;
  end
end
```

In this example, `UnitStr` is renamed through inheritance to `ZeroStr` and `OneStr`, which are then inherited by `ZeroOneStr`. The common field `carrier` from `UnitStr` is merged in `ZeroOneStr`. Users must ensure the consistency of fields and properties in diamond inheritance scenarios.

## 6.5. Constructor

Structures can be instantiated using constructors, which provide mechanisms for object creation and type conversion. Mizar provides both default and custom constructors.

#### Default Constructors

Structure values are constructed by providing values for each of the structure's fields in a named form. Field order is irrelevant due to named parameters.

```mizar
let A be set;
let b be Element of A;
set x = OneStr(Carrier: A, one: b);
```

#### Custom Constructors

Constructors can be explicitly declared using the `constructor` keyword:

```mizar
definition
  let G be Group;
  constructor OneStr(G) where
    it.carrier = G.carrier;
    it.one = G.unit;
  end
end
```

The special identifier `it` refers to the structure being constructed, allowing field and property initialization.

#### Converting Constructors

A constructor that takes a single argument serves as a converting constructor, enabling implicit type conversion:

```mizar
let G be Group;
reconsider x = G as OneStr;  :: Implicit conversion from Group to OneStr
```

Converting constructors are particularly useful when working with inheritance hierarchies, allowing automatic conversion from base structures to their derived structures.

## 6.6. Dependent Structures

Structures can be parameterized using `over` or `of` keywords as syntactic sugar for templates:

```mizar
definition
  let R be Ring;
  struct Polynomial over R where
    field coeffs -> FinSequence of R.carrier;
    property degree -> Nat;
  end
end
```

**Parameter syntax:**
- `struct Name over T` (equivalent to `struct Name[T]`)
- `struct Name of T` (equivalent to `struct Name[T]`)
- Multiple parameters: `struct Name over T, U` (equivalent to `struct Name[T, U]`)
- Both forms are syntactic sugar for template structures

**Usage:**
```mizar
let R be Ring;
let p be Polynomial over R;         :: Equivalent to Polynomial[R]
let S be Subset of REAL;            :: Equivalent to Subset[REAL]

let F be Field;
let n be Nat;
let V be VectorSpace over F, n;     :: Equivalent to VectorSpace[F, n]
```

**Template equivalence:** Dependent structure declarations are internally processed as template definitions, enabling the same instantiation and specialization mechanisms.
