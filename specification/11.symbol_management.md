# 11. Symbol Management

- [11. Symbol Management](#11-symbol-management)
  - [11.1 Synonyms and Antonyms](#111-synonyms-and-antonyms)
  - [11.2 Scope and Visibility](#112-scope-and-visibility)
  - [11.3 Import Behavior and Conflict Resolution](#113-import-behavior-and-conflict-resolution)
  - [11.4 Public and Private Symbols](#114-public-and-private-symbols)
  - [11.5 Logic Encoding Details](#115-logic-encoding-details)
  - [11.6 Complete Syntax (EBNF)](#116-complete-syntax-ebnf)

## 11.1 Synonyms and Antonyms

Mizar allows the definition of **synonyms** and **antonyms** for predicates, functors, modes, and attributes. These provide alternative notations while maintaining semantic equivalence.

**Syntax (EBNF)**:

```ebnf
synonym_def  ::= "synonym" alt_pattern "for" original_pattern ";" ;
antonym_def  ::= "antonym" alt_pattern "for" original_pattern ";" ;
alt_pattern  ::= pred_pattern | func_pattern | mode_pattern | attr_pattern ;
```

### 11.1.1 Predicate Synonyms and Antonyms

```mizar
definition
  let a, b be Real;
  pred LessThanDef: a < b means ...;
  synonym b > a for a < b;
  antonym a >= b for a < b;
end;
```

### 11.1.2 Functor Synonyms

```mizar
definition
  let f be Function;
  func InverseDef: f" -> Function means ...;
  synonym inv f for f";
end;
```

### 11.1.3 Mode Synonyms

```mizar
definition
  let G be set;
  mode FinSequenceDef: FinSequence of G is ...;
  synonym FinSeq of G for FinSequence of G;
end;
```

### 11.1.4 Attribute Synonyms and Antonyms

```mizar
definition
  let R be Ring;
  attr CommutativeDef: R is commutative means ...;
  synonym R is abelian for R is commutative;
end;

definition
  let S be set;
  attr FiniteDef: S is finite means ...;
  antonym S is infinite for S is finite;
end;
```

### 11.1.5 Benefits

| Benefit | Description |
| --- | --- |
| **Alternative notations** | Support different mathematical conventions |
| **Natural negation** | Express negation without explicit `non` or `not` |
| **Semantic equivalence** | Maintain logical identity while improving readability |
| **Compatibility** | Match conventions from different mathematical traditions |

## 11.2 Scope and Visibility

### 11.2.1 Scope Hierarchy

Symbols are visible according to the following hierarchy:

| Level | Description | Example |
| --- | --- | --- |
| **Local** | Defined within current proof block | `deffunc`, `defpred` |
| **Module** | Defined at module level | `pred`, `func`, `mode`, `attr` |
| **Imported** | Made available via `import` | `import mml.algebra.group` |

### 11.2.2 Module-Level Definitions

```mizar
definition
  let x, y be Integer;
  pred DivisibilityDef: x divides y means ex k be Integer st y = x * k;
end;
```

### 11.2.3 Imported Symbols

```mizar
import mml.algebra.group;
import mml.topology.space as top;
```

### 11.2.4 Precedence Rules

1. **Local definitions** take precedence over module-level definitions
2. **Module-level definitions** take precedence over imported symbols
3. **Import conflicts** result in a compile-time error (must be resolved via qualification or aliasing)
4. **Redefinitions** require the `redefine` keyword

## 11.3 Import Behavior and Conflict Resolution

**Syntax (EBNF)**:

```ebnf
import_stmt    ::= "import" module_path [ "as" alias ] ";" ;
module_path    ::= identifier { "." identifier } ;
alias          ::= identifier ;
qualified_name ::= [ module_path "." ] symbol_name ;
```

### 11.3.1 Import Syntax

```mizar
import mml.algebra.group;           :: direct import
import mml.topology.space as top;   :: aliased import
```

### 11.3.2 Conflict Resolution Strategies

**1. Namespace Qualification**

```mizar
import mml.algebra.group;
import mml.topology.topological_group as top_grp;

let G be mml.algebra.group.Group;
let T be top_grp.Group;
```

**2. Module Precedence**

```mizar
import mml.set_theory.cardinal;

definition
  let A, B be set;
  :: Local definition takes precedence over imported cardinal.card_leq
  pred LocalCardLeq: A card_leq B means card A c= card B;
end;
```

**3. Longest-Match Rule**

During lexical analysis, the longest matching token is selected:

```mizar
:: Suppose + and ++ are both defined symbols
a ++ b   :: Parsed as (a) (++) (b), not (a) (+) (+) (b)
```

## 11.4 Public and Private Symbols

**Syntax (EBNF)**:

```ebnf
visibility     ::= [ "private" ] ;
private_def    ::= "private" definition_body ;
definition_body ::= pred_def | func_def | mode_def | attr_def
                  | struct_def | theorem_def | lemma_def
                  | synonym_def | antonym_def ;
```

### 11.4.1 Visibility Defaults

| Symbol Type | Default Visibility |
| --- | --- |
| `pred`, `func`, `mode`, `attr`, `struct` | Public |
| `theorem`, `lemma` | Public |
| `synonym`, `antonym` | Public |

### 11.4.2 Private Declarations

```mizar
definition
  let x, y be Real;
  private pred HelperPred: helper(x, y) means x * x + y * y < 1;
end;

definition
  let x be Real;
  private func IntermediateFunc: intermediate(x) -> Real equals x * x + 1;
end;
```

### 11.4.3 Private Symbol Behavior

* Excluded from public module interface
* Not accessible via import from other modules
* Not re-exported by dependent modules
* Useful for internal helper definitions

## 11.5 Logic Encoding Details

This section describes how symbol management constructs map to First-Order Logic.

### 11.5.1 Synonym Encoding

Synonyms are encoded as logical equivalences:

| Mizar Source | FOL Encoding |
| --- | --- |
| `synonym b > a for a < b` | `∀a,b. (b > a) ↔ (a < b)` |
| `synonym inv f for f"` | `∀f. inv(f) = inverse(f)` |
| `synonym FinSeq of G for FinSequence of G` | `∀G,x. is_FinSeq(x,G) ↔ is_FinSequence(x,G)` |

### 11.5.2 Antonym Encoding

Antonyms are encoded as logical negations:

| Mizar Source | FOL Encoding |
| --- | --- |
| `antonym a >= b for a < b` | `∀a,b. (a >= b) ↔ ¬(a < b)` |
| `antonym S is infinite for S is finite` | `∀S. is_infinite(S) ↔ ¬is_finite(S)` |

### 11.5.3 Visibility Encoding

Private symbols are not exported to the logical interface:

```
private pred helper(x, y) means φ
⇒  (internal only, not in exported theory)
```

Public symbols generate exported axioms:

```
pred P(x, y) means φ
⇒  forall x, y (P(x, y) ↔ φ)  [exported]
```

### 11.5.4 Import Encoding

Imports make external axioms available **on demand**. Only symbols actually referenced in the importing module are included in the logical theory:

```
import mml.algebra.group
⇒  For each symbol S from mml.algebra.group used in this module:
     Include the axioms defining S
```

This lazy loading approach:
- Reduces the size of generated proof obligations
- Improves verification performance
- Maintains logical soundness (transitive dependencies are automatically included)

## 11.6 Complete Syntax (EBNF)

Summary of symbol management syntax.

```ebnf
(* Synonyms and Antonyms *)
synonym_def    ::= "synonym" alt_pattern "for" original_pattern ";" ;
antonym_def    ::= "antonym" alt_pattern "for" original_pattern ";" ;

(* Import Statements *)
import_stmt    ::= "import" module_path [ "as" alias ] ";" ;
module_path    ::= identifier { "." identifier } ;
alias          ::= identifier ;
qualified_name ::= [ module_path "." ] symbol_name ;

(* Visibility *)
visibility      ::= [ "private" ] ;
private_def     ::= "private" definition_body ;
definition_body ::= pred_def | func_def | mode_def | attr_def
                  | struct_def | theorem_def | lemma_def
                  | synonym_def | antonym_def ;

(* Symbol Patterns *)
pred_pattern   ::= [ loci ] predicate_symbol [ loci ] ;
func_pattern   ::= [ loci ] functor_symbol [ loci ] ;
mode_pattern   ::= mode_name [ type_params ] ;
attr_pattern   ::= [ param_prefix ] attribute_name ;
```
