# 7. Attributes

This chapter defines how attributes (type-refining predicates) are declared, used, and encoded.

* [7. Attributes](#7-attributes)
  * [7.1 Definition and Purpose](#71-definition-and-purpose)
  * [7.2 Syntax](#72-syntax)
  * [7.3 Usage](#73-usage)
  * [7.4 Clustering (Overview)](#74-clustering-overview)
  * [7.5 Attribute Inheritance](#75-attribute-inheritance)
  * [7.6 Disambiguation](#76-disambiguation)
  * [7.7 Redefinition](#77-redefinition)
  * [7.8 Logic Encoding Details](#78-logic-encoding-details)
  * [7.9 Complete Syntax (EBNF)](#79-complete-syntax-ebnf)

## 7.1 Definition and Purpose

Attributes are predicates (possibly parameterized) used to refine types by specifying additional logical properties. They serve the following purposes:

1. **Subtype Refinement**: Define subtypes of existing types based on logical conditions.
2. **Property Annotation**: Attach properties to types in a modular and reusable way.
3. **Type Inference**: Participate in the clustering mechanism for automatic type derivation.

## 7.2 Syntax

**Syntax (EBNF)**:

```ebnf
attr_def       ::= "attr" subject "is" attr_pattern "means" formula ";" ;
subject        ::= identifier ;
attr_pattern   ::= [ param_prefix ] attribute_name ;
param_prefix   ::= parameter "-"
                 | "(" parameter_list ")" "-" ;
parameter_list ::= parameter { "," parameter } ;
parameter      ::= identifier | numeral ;
attribute_name ::= identifier ;
```

* `subject`: The variable being tested (e.g., `T`, `n`, `V`)
* `param_prefix`: Optional prefix for parameterized attributes (e.g., `n-`, `(m,n)-`)

**Example (Simple)**:

```mizar
definition
  let i be Integer;
  attr i is even means 2 divides i;
end;
```

**Example (Parameterized)**:

```mizar
definition
  let n be Nat;
  attr V is n-dimensional means
    ex B being Basis of V st card B = n;
end;
```

**Example (Multiple Parameters)**:

```mizar
definition
  let m, n be Nat;
  let A be Matrix;
  attr A is (m,n)-size means
    rows A = m & cols A = n;
end;
```

## 7.3 Usage

### 7.3.1 Type Qualification

Attributes refine types in variable declarations:

```mizar
let G be associative unital Magma;
let n be positive even Integer;
```

### 7.3.2 Property Testing

Attributes can be tested in formulas:

```mizar
assume M is commutative;
if n is odd then ...;
```

### 7.3.3 Negation and Combinations

The `non` keyword negates attributes:

```mizar
let S be non empty finite set;
```

### 7.3.4 Type-Qualified Attributes

Used to disambiguate when the same attribute name exists in multiple structures:

```mizar
R is AddLoopStr.associative;
R is MulLoopStr.commutative;
```

Alternatively, use the `qua` operator:

```mizar
(R qua AddLoopStr) is associative;
(R qua MulLoopStr) is commutative;
```

## 7.4 Clustering (Overview)

Clustering enables automatic propagation of attributes.

| Cluster Type | Purpose |
| --- | --- |
| **Existential** | Proves existence of typed values with attributes |
| **Conditional** | Declares implication between attributes |
| **Functor** | Assigns attributes to functor results |

**Example (Existential)**:

```mizar
registration
  cluster empty finite set;
  existence
  proof ... end;
end;
```

**Example (Conditional)**:

```mizar
registration
  cluster empty -> finite set;
  coherence
  proof ... end;
end;
```

> [!NOTE]
> Detailed cluster syntax and semantics are defined in **Chapter 21 (Clusters)**.

## 7.5 Attribute Inheritance

Attributes defined for a parent structure apply to derived structures.

```mizar
definition
  inherit LoopStr from Magma where
    field carrier from carrier;
    field binop from binop;
  end;
end;
```

A `LoopStr` inherits all attributes defined for `Magma`.

## 7.6 Disambiguation

When multiple inheritance paths define the same attribute name, use qualified syntax:

```mizar
R is AddLoopStr.associative;
R is MulLoopStr.associative;
```

Or define explicit disambiguated attributes:

```mizar
definition
  let R be DoubleLoopStr;
  attr R is add_associative means R is AddLoopStr.associative;
end;
```

## 7.7 Redefinition

To redefine an attribute for a different definition:

* Original definition
```mizar
definition
  let n be Integer;
  attr n is even means
  ::integer_even::
  ex k be Integer st n = 2*k;
end;
```

* A redefinition
```mizar
definition
  let n be Nat;
  redefine attr n is even means ex k be Nat st n = 2*k;
  coherence with integer_even
  proof
    :: for Nat, divisibility and multiplication-based definitions coincide
    ...;
  end;
end;
```

**Requirements**:
* Logical equivalence with the original definition
* Coherence proof to justify redefinition
* (Optional) Labels to reference specific parent definitions

## 7.8 Logic Encoding Details

This section describes how attributes map to First-Order Logic.

### 7.8.1 Attributes as Predicates

Each attribute `A` applied to type `T` is encoded as a predicate.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is even` | `is_even(x)` |
| `x is positive` | `is_positive(x)` |
| `V is n-dimensional` | `is_n_dimensional(V, n)` |

### 7.8.2 Negation Encoding

The `non` keyword generates negated predicates:

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is non empty` | `¬is_empty(x)` |

### 7.8.3 Attribute Chains as Conjunctions

Multiple attributes are encoded as conjunctions:

| Mizar Source | FOL Encoding |
| --- | --- |
| `x is positive even Integer` | `is_Integer(x) ∧ is_positive(x) ∧ is_even(x)` |

### 7.8.4 Clustering as Axioms

Cluster registrations generate FOL axioms:

**Conditional Cluster**:
```
cluster empty -> finite set
⇔  forall x (is_set(x) & is_empty(x) implies is_finite(x))
```

## 7.9 Complete Syntax (EBNF)

Summary of attribute-related syntax.

```ebnf
(* Attribute Definition *)
attr_def       ::= "attr" subject "is" attr_pattern "means" formula ";" ;
subject        ::= identifier ;
attr_pattern   ::= [ param_prefix ] attribute_name ;
param_prefix   ::= parameter "-"
                 | "(" parameter_list ")" "-" ;
parameter_list ::= parameter { "," parameter } ;
parameter      ::= identifier | numeral ;
attribute_name ::= identifier ;

(* Attribute Redefinition *)
redefine_attr  ::= "redefine" "attr" subject "is" attr_pattern "means" formula ";"
                   "coherence" [ "with" label ] ";"
                   [ proof_block ] ;

(* Attribute Usage in Types *)
attribute_chain ::= { [ "non" ] attribute_ref } ;
attribute_ref   ::= [ struct_name "." ] attribute_name [ "(" argument_list ")" ] ;
```
