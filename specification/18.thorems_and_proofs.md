# 18. Theorems and Proofs

- [18. Theorems and Proofs](#18-theorems-and-proofs)
    - [18.1. Theorem Classes](#181-theorem-classes)
    - [18.2. Syntax of Theorem Declarations](#182-syntax-of-theorem-declarations)
    - [18.3. Logical Structure and Goal Transformation](#183-logical-structure-and-goal-transformation)
        - [18.3.1. The Concept of Current Goal](#1831-the-concept-of-current-goal)
        - [18.3.2. The `thesis` Keyword](#1832-the-thesis-keyword)
        - [18.3.3. Goal Transformation Rules](#1833-goal-transformation-rules)
    - [18.4. Proof Structure and Scope](#184-proof-structure-and-scope)
        - [18.4.1. Proof Blocks](#1841-proof-blocks)
        - [18.4.2. Scope and Visibility](#1842-scope-and-visibility)
        - [18.4.3. Diffuse Reasoning (Nested Proofs)](#1843-diffuse-reasoning-nested-proofs)
    - [18.5. Type System Proof Obligations](#185-type-system-proof-obligations)
        - [18.5.1. Existence and Uniqueness Formulas](#1851-existence-and-uniqueness-formulas)
        - [18.5.2. Coherence and Compatibility Formulas](#1852-coherence-and-compatibility-formulas)
        - [18.5.3. Cluster Registration Formulas](#1853-cluster-registration-formulas)
    - [18.6. Implementation Notes](#186-implementation-notes)

## 18.1. Theorem Classes

Mizar Evolution distinguishes declarative logical units based on their verification status and parameterization.

* **`theorem`**: A fully verified proposition. It requires a syntactically valid and semantically correct `proof` block.
* **`conjecture`**: A proposition asserted without proof.
    * **Verification Status**: Treated as "Unverified" but accepted by the parser.
    * **Reference Capability**: Can be referenced by other theorems (via label) to facilitate top-down development, but triggers a "dependence on conjecture" warning.
* **`scheme`**: A parameterized reasoning template (e.g., induction schemes). Syntax and semantics are detailed in **Chapter 24**.

## 18.2. Syntax of Theorem Declarations

The syntax for declaring theorems and proofs is defined by the following Lark grammar.

```lark
// Top-level declarations
theorem_declaration: "theorem" label_identifier ":" formula ";" proof_block
                   | "conjecture" label_identifier ":" formula ";"

// Proof Structure
proof_block: "proof" statement* "end" ";"

// Note: 'statement' is defined in Chapter 17.
// 'label_identifier' is mandatory for referencing this theorem.
````

  * **Label**: Mandatory. Allows the theorem to be referenced from other proofs.
  * **Formula**: The proposition $\Phi$ to be proved.
  * **Proof Block**: Mandatory for `theorem`. It contains a sequence of reasoning steps (statements) that must logically derive $\Phi$.

## 18.3. Logical Structure and Goal Transformation

Mizar verification is based on the principle of **Goal Transformation**. The verifier maintains a "Current Goal" state, which corresponds to the logical formula that remains to be proved.

### 18.3.1. The Concept of Current Goal

Let $\mathcal{G}$ be the set of formulas remaining to be proved.
At the beginning of a `proof` block for a theorem stating $\Phi$, the initial state is $\mathcal{G}_0 = \{ \Phi \}$.

As the proof proceeds via statements (like `assume`, `let`, `thus`), the goal $\mathcal{G}$ is transformed or simplified. The proof is complete when $\mathcal{G}$ becomes empty (or effectively "True").

### 18.3.2. The `thesis` Keyword

The keyword `thesis` is a dynamic constant that evaluates to the **formula of the current goal**.

  * If the current goal is a conjunction $\Psi_1 \land \Psi_2$, `thesis` refers to the entire conjunction until split.
  * `thesis` allows generic reasoning steps without rewriting the full formula.

### 18.3.3. Goal Transformation Rules

The following rules define how statements transform the current goal $G$. If the current statement does not match the structure of $G$, a verification error occurs.

**1. Implication (`assume`)**

  * **Current Goal**: $G = \varphi \implies \psi$
  * **Statement**: `assume $\varphi$;`
  * **New Goal**: $G' = \psi$
  * **Constraint**: The assumed formula must be syntactically identical (or logically equivalent via expansion) to the antecedent.

**2. Universal Quantification (`let`)**

  * **Current Goal**: $G = \forall x : T . \varphi[x]$
  * **Statement**: `let y be T;`
  * **New Goal**: $G' = \varphi[y]$
  * **Constraint**: The type of $y$ must match (or be a subtype of) $T$.

**3. Conjunction (`thus`)**

  * **Current Goal**: $G = \varphi \land \psi$
  * **Statement**: `thus $\varphi$;`
  * **New Goal**: $G' = \psi$
  * **Constraint**: `thus` indicates that a component of the goal is being discharged.

**4. Direct Conclusion (`thus`)**

  * **Current Goal**: $G = \varphi$ (atomic or non-decomposable)
  * **Statement**: `thus $\varphi$;`
  * **New Goal**: $\emptyset$ (Subproof complete)

**5. Existential Quantification (`take`)**

  * **Current Goal**: $G = \exists x : T . \varphi[x]$
  * **Statement**: `take y;`
  * **New Goal**: $G' = \varphi[y]$
  * **Constraint**: $y$ must be a term of type $T$.

**6. Equivalence (`iff`)**

  * **Current Goal**: $G = \varphi \iff \psi$
  * **Transformation**: Automatically splits into $G_1 = \varphi \implies \psi$ and $G_2 = \psi \implies \varphi$. Usually handled by two nested `now` blocks or explicit deduction.

## 18.4. Proof Structure and Scope

### 18.4.1. Proof Blocks

A `proof` block creates a new logical scope. It acts as a container for the goal transformation process described above.

  * **Input**: Inherits the formula from the preceding `theorem` or `definition`.
  * **Output**: Must result in an empty goal state. Any remaining `thesis` at the `end` keyword triggers a "Not proven" error.

### 18.4.2. Scope and Visibility

  * **Labels**: Labels defined inside a proof (e.g., `A1:`) are **local** to that proof block. They cannot be accessed from outside.
  * **Variables**: Variables introduced via `let`, `given`, or `consider` are local to the enclosing block.
  * **Shadowing**: Local declarations shadow global symbols and outer-scope variables, following standard lexical scoping rules (see Chapter 12).

### 18.4.3. Diffuse Reasoning (Nested Proofs)

Complex proofs often require sub-arguments. These are handled via "Diffuse Statements" (see Chapter 17), which behave as anonymous theorems.

  * **`now ... end`**: Creates a block that returns a formula $\Phi$ as a justified proposition.
      * Inside the block, the initial goal is undefined until explicitly stated (conceptually $\top$), or inferred from context if used in a `thus now ... end` construction.
  * **`hereby ... end`**: Syntactic sugar for `thus now ... end`. It asserts the result of the block as a partial conclusion of the main goal.

## 18.5. Type System Proof Obligations

Definitions in Mizar Evolution (`func`, `pred`, `mode`, `cluster`) generate implicit theorems that must be proved. These are called **Proof Obligations**.

### 18.5.1. Existence and Uniqueness Formulas

For a functor definition using `means`:

```mizar
definition
  let x be A;
  func F(x) -> B means P[it, x];
end;
```

The verifier generates the following obligations:

1.  **Existence**:
    $$ \forall x : A . \exists y : B . P[y, x] $$

      * Target of `existence` block.

2.  **Uniqueness**:
    $$ \forall x : A . \forall y_1, y_2 : B . (P[y_1, x] \land P[y_2, x] \implies y_1 = y_2) $$

      * Target of `uniqueness` block.

For a predicate definition, only **Existence** (Satisfiability) is required if the predicate is to be used in a `cluster`.

### 18.5.2. Coherence and Compatibility Formulas

When redefining a functor or attribute, logical consistency is required.

**Attribute Redefinition**:
Given `attr A is Name` and a redefinition for subtype `B` ($B \subseteq A$) with condition $P'[x]$:
$$ \forall x : B . ( \text{OriginalDef}[x] \iff P'[x] ) $$

  * Target of `coherence` block.

**Result Type Redefinition**:
Given `func F -> A` redefined as `func F -> B` (where $B \subseteq A$):
$$ \forall x . F(x) \text{ is } B $$

  * Target of `coherence` block.

### 18.5.3. Cluster Registration Formulas

**Conditional Cluster**:

```mizar
registration
  cluster A -> B;
end;
```

Generated Obligation:
$$ \forall x . (x \text{ is } A \implies x \text{ is } B) $$

  * Target of `coherence` block.

**Existential Cluster**:

```mizar
registration
  cluster A;
end;
```

Generated Obligation:
$$ \exists x . (x \text{ is } A) $$

  * Target of `existence` block.

## 18.6. Implementation Notes

  * **Verification Order**: Proofs are verified top-down. `conjecture` blocks are skipped but added to the symbol table.
  * **Error Handling**:
      * If a `proof` block fails to discharge the goal, the theorem is marked as invalid.
      * Using a `conjecture` should emit a compiler warning ("Relies on unproven conjecture").
  * **Thesis Matching**: The matching between statements (like `assume`) and the current goal is performed modulo definitional expansion. If syntactic matching fails, the verifier attempts to unfold definitions.
