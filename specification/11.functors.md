# 11. Functors

- [11. Functors](#11-functors)
    - [11.1. Basic Syntax and Semantics](#111-basic-syntax-and-semantics)
    - [11.2. Functor Definition Methods](#112-functor-definition-methods)
    - [11.3. Partial Functions and Definedness](#113-partial-functions-and-definedness)
    - [11.4. Type Dependencies and Return Types](#114-type-dependencies-and-return-types)
    - [11.5. Functor Redefinition](#115-functor-redefinition)
    - [11.6. Correctness Conditions](#116-correctness-conditions)
    - [11.7. Infix, Prefix, and Postfix Notation](#117-infix-prefix-and-postfix-notation)
    - [11.8. Bracket Notation and Custom Symbols](#118-bracket-notation-and-custom-symbols)
    - [11.9. Operator Precedence](#119-operator-precedence)


## 11.1. Basic Syntax and Semantics

Functors in Mizar are defined using the `func` keyword:

```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z be object holds z in it iff z in X or z in Y;
end
```

**Basic components:**
- `func` keyword introduces a functor definition
- Parameter declarations specify the types of arguments
- Return type specified after `->` 
- `means` clause provides the logical definition using `it` for the result
- Functor symbols can use almost any sequence of printable non-whitespace characters
- Lexer uses longest-match rule among imported symbols

**Semantics:**
- Functors represent operations that construct mathematical objects
- Parameter types determine the domain of the functor
- Return type specifies the codomain
- The `means` clause defines the result using `it` as placeholder

## 11.2. Functor Definition Methods

Functors can be defined using two different approaches:

**1. Means definition** - defines the result implicitly:
```mizar
definition
  let X, Y be set;
  func X \/ Y -> set means
    for z be object holds z in it iff z in X or z in Y;
end
```

**2. Equals definition** - defines the result explicitly:
```mizar
definition
  let n be Nat;
  func twice(n) -> Nat equals 2 * n;
end
```

**Import behavior:**
- All functors are user-defined (no built-in functors exist in Mizar)
- User-defined functors become available through import statements
- Symbol precedence follows the rules described in [Chapter 2](./2.lexical_structure.md)
- Conflicts are resolved using namespace qualification

## 11.3. Partial Functions and Definedness

Functors in Mizar can represent partial functions using conditional definitions:

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func x / y -> Real means
    it * y = x;
end
```

**Definedness conditions:**
- `assume` clauses specify when the functor is defined
- Outside the domain, the functor may return arbitrary values
- Type system ensures syntactic well-formedness but not semantic definedness
- Note: Definedness checking is more complex than type checking and poses implementation challenges

**Total vs Partial:**
```mizar
:: Total functor - always defined
definition
  let n be Nat;
  func twice(n) -> Nat equals 2 * n;
end

:: Partial functor - conditionally defined  
definition
  let f be Function;
  assume f is one-to-one;
  func f" -> Function means
    dom it = rng f & for x, y be object holds 
    [x, y] in it iff [y, x] in f;
end
```

## 11.4. Type Dependencies and Return Types

**Simple functors** with fixed parameter and return types:
```mizar
definition
  let m, n be Nat;
  func gcd(m, n) -> Nat means
    it divides m & it divides n &
    for k be Nat st k divides m & k divides n holds k divides it;
end
```

**Dependent return types** based on parameters:
```mizar
definition
  let G be Group;
  func center(G) -> Subgroup of G means
    for x be Element of G holds x in it iff
    for y be Element of G holds x, y are_commute;
end
```

**Multiple parameter functors** with complex dependencies:
```mizar
definition
  let G be Group;
  let H, K be Subgroup of G;
  func H * K -> Subset of G means
    for x be Element of G holds x in it iff
    ex h be Element of H ex k be Element of K st x = h * k;
end
```

## 11.5. Functor Redefinition

Functor redefinition follows the same principles as predicate redefinition (see [6.2.4](#624-predicate-redefinition)), with the key difference being the ability to specialize the return type.

**Key Difference from Predicate Redefinition**

Unlike predicates, functor redefinition can refine the return type and provide alternative logical characterizations:

```mizar
definition
  let x be Real;
  func |.x.| -> Real means
    :abs_general:
    (x >= 0 implies it = x) & (x < 0 implies it = -x);
end

definition
  let x be non negative Real;
  redefine func |.x.| -> non negative Real means
    it = x;
  coherence with abs_general
  proof
    :: For non-negative reals, absolute value is the identity function
  end
end
```

**Additional Requirements for Type Specialization**

When specializing return types:

1. **Return Type Compatibility**: The specialized return type must be a subtype of the original return type
2. **Type Safety**: All existing uses of the functor must remain type-safe with the new return type

**Benefits**

Functor redefinition provides the same benefits as predicate redefinition, plus:
- **Enhanced Type Information**: More precise return types enable better type inference and checking

## 11.6. Correctness Conditions

Implicit functor definitions with `means` require existence and uniqueness proofs, while those defined with `equals` are automatically well-defined.

#### Implicit Definition

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func x / y -> Real means
    it * y = x;
  existence
  proof
    :: Proof that a value satisfying the condition exists
  end
  uniqueness
  proof
    :: Proof that the value is unique
  end
end
```

#### Explicit Definition

```mizar
definition
  let n be Nat;
  func twice(n) -> Nat equals 2 * n;
  :: No additional proofs required - automatically well-defined
end
```

**Note**: These requirements ensure mathematical well-definedness and are essential for maintaining the logical consistency of the system.

## 11.7. Infix, Prefix, and Postfix Notation

Mizar allows direct definition of various notation patterns in predicate and functor definitions:

**Infix notation** for binary predicates:
```mizar
definition
  let x, y be Real;
  pred x <= y means
    x < y or x = y;
end
```

**Infix notation** for binary functors:
```mizar
definition
  let x, y be Real;
  func x + y -> Real means
    it = plus(x, y);
end
```

**Prefix notation** for unary functors:
```mizar
definition
  let x be Real;
  func - x -> Real means
    it + x = 0;
end
```

**Postfix notation** patterns:
```mizar
definition
  let n be Nat;
  func n ! -> Nat equals
    Product(id(Seg n));
end
```

## 11.8. Bracket Notation and Custom Symbols

**Left and right bracket functors** using `[:` and `:]`:
```mizar
definition
  let X, Y be set;
  func [: X, Y :] -> set means
    for z be object holds z in it iff
    ex x, y be object st x in X & y in Y & z = [x, y];
end
```

## 11.9. Operator Precedence

**Symbol-based precedence declaration** using global annotations:

```mizar
:: Global symbol precedence declarations (range: 0-255, default: 64)
@symbol_precedence(*, 100, left_associative);      :: Multiplication
@symbol_precedence(/, 100, left_associative);      :: Division
@symbol_precedence(+, 80, left_associative);       :: Addition
@symbol_precedence(-, 80, left_associative);       :: Subtraction
```

**Automatic precedence application** in definitions:
```mizar
definition
  let x, y be Real;
  func x + y -> Real means  :: Automatically gets precedence 80, left_associative
    it = real_addition(x, y);
end

definition
  let x, y be Matrix;
  func x * y -> Matrix means  :: Automatically gets precedence 100, left_associative
    it = matrix_multiplication(x, y);
end
```

**Consistency checking** across modules:
```mizar
:: Module A
@symbol_precedence(+, 80, left_associative);

:: Module B - would cause link error
@symbol_precedence(+, 100, left_associative);  :: Error: precedence conflict for '+'
```

**Link-time error handling:**
- All modules must declare identical precedence for the same symbol
- Conflicts detected during module linking phase
- Clear error messages indicating conflicting declarations

**Associativity types:**
- `left_associative`: `x + y + z` = `(x + y) + z`
- `right_associative`: `x ^ y ^ z` = `x ^ (y ^ z)`
- `non_associative`: Relational operators, requires explicit parentheses
