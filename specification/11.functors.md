# 11. Functors

- [11. Functors](#11-functors)
  - [11.1 Overview and Syntax](#111-overview-and-syntax)
  - [11.2 Functors vs Predicates](#112-functors-vs-predicates)
  - [11.3 Definition Styles: `equals` vs `means`](#113-definition-styles-equals-vs-means)
  - [11.4 Partial Functions and `assume`](#114-partial-functions-and-assume)
  - [11.5 Dependent Return Types](#115-dependent-return-types)
  - [11.6 Correctness Conditions](#116-correctness-conditions)
  - [11.7 Functor Redefinition](#117-functor-redefinition)
  - [11.8 Notation Styles](#118-notation-styles)
  - [11.9 Operator Precedence and Associativity](#119-operator-precedence-and-associativity)
  - [11.10 Symbol Resolution and Imports](#1110-symbol-resolution-and-imports)
  - [11.11 Logic Encoding Details](#1111-logic-encoding-details)
  - [11.12 Complete Syntax (EBNF)](#1112-complete-syntax-ebnf)

## 11.1 Overview and Syntax

Functors introduce symbolic functions that map typed inputs to typed outputs. Each functor has a name (label), a pattern, a return type, and a definition body.

**Syntax (EBNF)**:

```ebnf
func_def         ::= "func" label ":" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";" ;
label            ::= identifier ;
func_pattern     ::= [ loci ] functor_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
functor_symbol   ::= identifier | symbolic_func ;
symbolic_func    ::= symbol_char+ ;
type_expression  ::= attribute_chain radix_type ;
```

**Example**:

```mizar
definition
  let X, Y be set;
  func UnionDef: X \/ Y -> set means
    for z being object holds z in it iff z in X or z in Y;
end;
```

Functors can be:

* **Built-in**: e.g., `{}` (empty set)
* **User-defined**: declared with `func` and `means` or `equals`
* **Overloaded**: disambiguated by parameter types

Key characteristics:
* `it` denotes the return value in `means` definitions
* Return type is specified after `->`
* Functor symbols can be arbitrary non-whitespace character sequences
* Lexical analysis follows the longest-match rule

> [!NOTE]
> For **inline functor definitions** within proofs (`deffunc`), see [Chapter 17 (Statements), §17.2.3](./17.statements.md#1723-inline-function-definition-deffunc).

## 11.2 Functors vs Predicates

Functors and predicates are both user-defined symbols, but serve different purposes:

| Aspect | Functors (`func`) | Predicates (`pred`) |
| --- | --- | --- |
| **Purpose** | Compute and return values | Express boolean relations |
| **Return type** | Any type (specified after `->`) | Always boolean (true/false) |
| **Syntax** | `x + y`, `f(x)`, `X \/ Y` | `x c= y`, `a divides b` |
| **Definition keyword** | `equals` or `means` | `means` only |
| **Correctness** | Requires existence/uniqueness for `means` | No existence/uniqueness needed |

**When to use functors**:
- Computing values: `x + y`, `card X`
- Building structures: `X \/ Y`, `[: X, Y :]`
- Defining mathematical operations

**When to use predicates**:
- Testing conditions: `x c= y`
- Defining relations: `a divides b`
- Expressing properties in formulas

**Example comparison**:

```mizar
:: As a functor (returns a value)
definition
  let x, y be Real;
  func SumDef: x + y -> Real equals ...;
end;

:: As a predicate (returns boolean)
definition
  let x, y be Real;
  pred LessOrEqualDef: x <= y means x < y or x = y;
end;

:: Functors are used in term expressions
set z = x + y;

:: Predicates are used in formulas
assume x <= y;
```

> [!NOTE]
> Detailed predicate syntax and semantics are defined in [Chapter 10 (Predicates)](./10.predicates.md).

## 11.3 Definition Styles: `equals` vs `means`

Mizar supports two styles of functor definitions:

### 11.3.1 Explicit Definition (`equals`)

Provides an explicit value. The system considers the functor well-defined by construction, so no additional proofs are needed.

```mizar
definition
  let n be Nat;
  func DoubleDef: twice(n) -> Nat equals 2 * n;
end;

definition
  let X be set;
  func PowerSetDef: power_set(X) -> set equals
    { Y where Y is set : Y c= X };
end;            
```

### 11.3.2 Implicit Definition (`means`)

Specifies the defining condition for the result, using `it` as a placeholder. This style requires the user to prove that a unique such result exists.

```mizar
definition
  let x, y be Real;
  func DivDef: x / y -> Real means it * y = x;
  existence
  proof ... end;
  uniqueness
  proof ... end;
end;

definition
  let G be Group;
  func IdentityDef: 1_G -> Element of G means
    for a being Element of G holds it * a = a & a * it = a;
  existence
  proof ... end;
  uniqueness
  proof ... end;
end;
```

**When to use each style**:

| Style | Use when... | Example |
| --- | --- | --- |
| `equals` | Value can be computed directly | `twice(n) equals 2 * n` |
| `means` | Value is characterized by properties | `x / y means it * y = x` |

## 11.4 Partial Functions and `assume`

`assume` clauses constrain the domain of definition:

```mizar
definition
  let x, y be Real;
  assume y <> 0;
  func PartialDivDef: x / y -> Real means it * y = x;
  existence
  proof ... end;
  uniqueness
  proof ... end;
end;

definition
  let f be Function, x be object;
  assume x in dom f;
  func ApplyDef: f . x -> object equals f(x);
end;
```

**Semantics**:
* Outside the assumed domain, the result is undefined
* Calls to partial functors require proof that preconditions hold

> [!TIP]
> It is recommended to encode preconditions into argument types when possible. For example, require `y` to be a `non zero Real` instead of using `assume y <> 0`. This improves clarity and reduces verification burden.

## 11.5 Dependent Return Types

Return types can depend on input values:

```mizar
definition
  let G be Group;
  func CenterDef: center G -> Subgroup of G means
    for a being Element of it holds
      for b being Element of G holds a * b = b * a;
end;

definition
  let X be set;
  func IdDef: id X -> Function of X, X equals
    { [x, x] where x is Element of X : x in X };
end;
```

Multiple dependencies are supported:

```mizar
definition
  let G be Group;
  let H, K be Subgroup of G;
  func SubgroupProdDef: H * K -> Subset of G equals
    { h * k where h is Element of H, k is Element of K : true };
end;
```

## 11.6 Correctness Conditions

Unlike predicates, functors have strict correctness requirements:

| Condition | Applies to | Description |
| --- | --- | --- |
| **Existence** | `means` only | Prove that at least one value satisfies the condition |
| **Uniqueness** | `means` only | Prove that at most one value satisfies the condition |
| **Well-formedness** | Both | The defining expression/formula must be syntactically valid |
| **Type correctness** | Both | All terms must be type-correct |
| **Definedness** | `assume` | Outside the assumed domain, the functor is undefined |

**Syntax**:

```ebnf
correctness_conditions ::= [ existence_block ] [ uniqueness_block ] ;
existence_block        ::= "existence" proof_or_refs ;
uniqueness_block       ::= "uniqueness" proof_or_refs ;
proof_or_refs          ::= proof_block | "by" references ";" ;
```

**Example with proofs**:

```mizar
definition
  let X be non empty set;
  func ChooseDef: choose X -> Element of X means it in X;
  existence
  proof
    consider x being object such that A1: x in X by non_empty_def;
    reconsider x as Element of X by A1;
    take x;
    thus x in X by A1;
  end;
  uniqueness
  proof
    :: In general, choice function may not be unique
    :: This would require additional axioms
  end;
end;
```

> [!NOTE]
> Functors defined via `equals` are well-defined by construction and do not require existence or uniqueness proofs.

## 11.7 Functor Redefinition

Existing functors can be redefined for more specific types to provide:
- Narrower return types
- Simplified defining conditions
- Type-specific optimizations

**Syntax**:

```ebnf
redefine_func  ::= "redefine" "func" func_pattern "->" type_expression
                   ( "means" formula | "equals" term_expression ) ";"
                   "coherence" [ "with" label ] proof_or_refs ";" ;
```

**Example**:

```mizar
definition
  let x be Real;
  func AbsGeneral: |.x.| -> Real means
    (x >= 0 implies it = x) & (x < 0 implies it = -x);
end;

definition
  let x be non negative Real;
  redefine func |.x.| -> non negative Real equals x;
  coherence with AbsGeneral
  proof
    :: For non-negative x, |x| = x which is non-negative
    ...;
  end;
end;
```

Redefinition requirements:

* Use `redefine func`
* The redefined return type must be a subtype of the original
* Provide a `coherence` proof showing equivalence under the new parameter types
* All previous uses must remain type-safe

## 11.8 Notation Styles

Supported notations:

| Notation | Pattern | Example |
| --- | --- | --- |
| **Infix** | `x symbol y` | `x + y`, `X \/ Y` |
| **Prefix** | `symbol x` | `- x`, `card X` |
| **Postfix** | `x symbol` | `n !`, `f "` |
| **Circumfix (Bracket)** | `left x right` | `[: X, Y :]`, `|. x .|` |
| **Functional** | `symbol ( args )` | `sin(x)`, `max(a, b)` |

**Examples**:

```mizar
:: Infix
func AddDef: x + y -> Real equals ...;
func UnionDef: X \/ Y -> set means ...;

:: Prefix
func NegDef: - x -> Real equals ...;
func CardDef: card(X) -> Cardinal means ...;

:: Postfix
func FactorialDef: n ! -> Nat equals Product(id(Seg n));
func InverseDef: f " -> Function means ...;

:: Circumfix (bracket notation)
func CartesianDef: [: X, Y :] -> set means ...;
func AbsDef: |. x .| -> Real means ...;

:: Functional (parenthesized)
func SinDef: sin(x) -> Real means ...;
func MaxDef: max(a, b) -> Real equals ...;
```

## 11.9 Operator Precedence and Associativity

Declared via annotations:

```mizar
@symbol_precedence(+, 80, left_associative);
@symbol_precedence(*, 90, left_associative);
@symbol_precedence(^, 95, right_associative);
```

**Properties**:

| Property | Values | Default |
| --- | --- | --- |
| **Precedence** | 0–255 | 64 |
| **Associativity** | `left_associative`, `right_associative`, `non_associative` | `non_associative` |

**Associativity semantics**:

| Type | Effect | Example |
| --- | --- | --- |
| `left_associative` | Groups left-to-right | `a + b + c` → `(a + b) + c` |
| `right_associative` | Groups right-to-left | `a ^ b ^ c` → `a ^ (b ^ c)` |
| `non_associative` | Requires explicit parentheses | `a < b < c` → error |

**Conflict handling**:
* Precedence must be consistent across modules
* Consistency is checked during module linking
* Conflicts result in descriptive link-time errors

## 11.10 Symbol Resolution and Imports

User-defined functors are made available by importing their defining modules:

```mizar
import algebra.group as grp;
let G be set;
let x = grp.center(G);
```

Conflicts between names are resolved by:

* **Longest-match rule** during lexing
* **Qualified names** when needed

**Example**:

```mizar
import geometry.vector;
import linear_algebra.vector as linalg;

:: Use qualified names to disambiguate
let v = geometry.vector.zero;
let w = linalg.zero;
```

> [!NOTE]
> For synonyms of functors, see [Chapter 12 (Symbol Management), §12.1](./12.symbol_management.md#121-synonyms-and-antonyms).

## 11.11 Logic Encoding Details

This section describes how functors map to First-Order Logic.

### 11.11.1 Functors as FOL Function Symbols

Each user-defined functor is encoded as an FOL function symbol.

| Mizar Source | FOL Encoding |
| --- | --- |
| `x + y` | `add(x, y)` |
| `card X` | `card(X)` |
| `[: X, Y :]` | `cartesian_product(X, Y)` |
| `f . x` | `apply(f, x)` |

### 11.11.2 `equals` Definitions as Equations

A functor defined via `equals` generates a universally quantified equation:

```
func twice(n) equals 2 * n
⇒  forall n (twice(n) = 2 * n)
```

More generally:

```
func F(x1, ..., xn) equals t
⇒  forall x1, ..., xn (F(x1, ..., xn) = t)
```

### 11.11.3 `means` Definitions as Unique Existence

A functor defined via `means` generates axioms asserting unique existence:

```
func x / y means it * y = x
⇒  forall x, y (
     exists! z (z * y = x) ∧
     div(x, y) * y = x
   )
```

The `it` placeholder is replaced by the function application in the generated axiom.

### 11.11.4 Typed Parameters as Guards

Type constraints on parameters are encoded as antecedents:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x, y be Real; func x + y -> Real` | `forall x, y (is_Real(x) ∧ is_Real(y) → is_Real(add(x, y)))` |
| `let G be Group; func center(G) -> Subgroup of G` | `forall G (is_Group(G) → is_Subgroup(center(G), G))` |

### 11.11.5 Domain Restrictions (`assume`)

When a functor uses `assume`, the condition becomes an additional antecedent:

```
let x, y be Real;
assume y <> 0;
func x / y -> Real means ...

⇒  forall x, y (is_Real(x) ∧ is_Real(y) ∧ y ≠ 0 → is_Real(div(x, y)) ∧ div(x, y) * y = x)
```

### 11.11.6 Return Type Encoding

The return type generates a type assertion for the result:

| Mizar Source | FOL Encoding |
| --- | --- |
| `func f(x) -> Nat` | `forall x (...preconditions... → is_Nat(f(x)))` |
| `func g(X) -> non empty set` | `forall X (...preconditions... → is_set(g(X)) ∧ ¬is_empty(g(X)))` |

### 11.11.7 Redefinition Encoding

A redefinition generates an equivalence axiom under restricted types:

```
redefine func |.x.| -> non negative Real equals x;
⇒  forall x (
     is_Real(x) ∧ is_non_negative(x)
     → abs(x) = x ∧ is_non_negative(abs(x))
   )
```

## 11.12 Complete Syntax (EBNF)

Summary of functor-related syntax.

```ebnf
(* Functor Definition *)
func_def         ::= "func" label ":" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";"
                     [ correctness_conditions ] ;
label            ::= identifier ;
func_pattern     ::= [ loci ] functor_symbol [ loci ] ;
loci             ::= locus | "(" locus_list ")" ;
locus_list       ::= locus { "," locus } ;
locus            ::= identifier ;
functor_symbol   ::= identifier | symbolic_func ;
symbolic_func    ::= symbol_char+ ;

(* Correctness Conditions *)
correctness_conditions ::= [ existence_block ] [ uniqueness_block ] ;
existence_block  ::= "existence" proof_or_refs ;
uniqueness_block ::= "uniqueness" proof_or_refs ;
proof_or_refs    ::= proof_block | "by" references ";" ;

(* Functor Redefinition *)
redefine_func    ::= "redefine" "func" func_pattern "->" type_expression
                     ( "means" formula | "equals" term_expression ) ";"
                     "coherence" [ "with" label ] proof_or_refs ";" ;

(* Functor Application - see Chapter 13/14 *)
functor_application ::= [ term_list ] functor_symbol [ term_list ]
                      | functor_symbol "(" [ term_list ] ")" ;
term_list        ::= term_expression { "," term_expression } ;

(* Operator Precedence Annotation *)
precedence_annotation ::= "@symbol_precedence" "(" functor_symbol ","
                          precedence_value "," associativity ")" ";" ;
precedence_value ::= integer ;  (* 0-255 *)
associativity    ::= "left_associative" | "right_associative" | "non_associative" ;
```
