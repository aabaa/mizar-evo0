# 12. Modules and Namespaces

This chapter defines the structure of Mizar modules, the rules for namespaces, and the mechanisms for dependency management. It establishes how physical files map to logical theories.

* [12. Modules and Namespaces](#12-modules-and-namespaces)
  * [12.1 Module Concept and Logic Encoding](#121-module-concept-and-logic-encoding)
  * [12.2 Repository Layout and Naming](#122-repository-layout-and-naming)
  * [12.3 Import Statements](#123-import-statements)
  * [12.4 Export Statements](#124-export-statements)
  * [12.5 Visibility Control (Private/Public)](#125-visibility-control-privatepublic)
  * [12.6 Logic Encoding and Separate Compilation](#126-logic-encoding-and-separate-compilation)
  * [12.7 Complete Syntax (EBNF)](#127-complete-syntax-ebnf)
  * [12.8 Example](#128-example)

## 12.1 Module Concept and Logic Encoding

A **Module** in Mizar serves two distinct roles:

1. **Unit of Compilation**: Corresponds to a single `.miz` source file.
2. **Logical Theory**: Defines a theory $T = (\Sigma, \Gamma)$ in First-Order Logic, where $\Sigma$ is the signature (vocabulary of functors, predicates, types, etc.) and $\Gamma$ is the set of axioms and theorems.

**Namespace Principle**:
There is a **one-to-one mapping** between the logical namespace and the physical file path. Every symbol defined in a module is logically identified by a **Fully Qualified Name (FQN)** derived directly from its file location.

## 12.2 Repository Layout and Naming

Modules are organized hierarchically. To manage trust levels, stability, and ecosystem growth effectively, the system distinguishes between **five primary namespace roots**.

### 12.2.1 Logical Namespace Roots

| Root | Name | Description | Governance |
| --- | --- | --- | --- |
| **`std`** | Standard Library | Core, trusted library maintained by the Mizar team | Mizar Team |
| **`pub`** | Published (JFM) | Verified articles from the *Journal of Formalized Mathematics* | JFM Editorial Board |
| **`pkg`** | Package Registry | Third-party packages registered in the central registry | Community (crates.io model) |
| **`dev`** | Development | Local development workspace and experimental projects | User-local |
| **`ext`** | External | References to external repositories (mirrors, forks) | External maintainers |

#### `std` (Standard Library)

The standard library contains foundational theories that all users can rely upon. It is maintained by the Mizar team with strict quality control.

```mizar
import std.algebra.group;
import std.topology.metric_space;
import std.set_theory.zfc;
```

#### `pub` (Published / JFM)

Contains verified articles from the *Journal of Formalized Mathematics*. These are "frozen" theories that preserve the academic value and citation stability of JFM publications.

```mizar
import pub.jfm.pepin.jordan_curve;
import pub.jfm.trybulec.boolean_properties;
```

#### `pkg` (Package Registry)

Third-party packages published to the central Mizar package registry (similar to crates.io). Package names must be registered and are globally unique.

**Naming Conventions**:

| Pattern | Description | Example |
| --- | --- | --- |
| `pkg.<package_name>` | Registered package name | `pkg.mathcomp_mizar.algebra` |
| `pkg.<scope>.<name>` | Scoped package | `pkg.nakasho.quantum.hilbert` |

```mizar
import pkg.mathcomp_mizar.algebra.ring;
import pkg.bourbaki.topology.filters as filters;
import pkg.nakasho.quantum.hilbert;
```

**Registration Rules**:
* Package names are registered first-come, first-served in the central registry
* Scopes (first component after `pkg.`) can be reserved by registering an account
* Package names must be lowercase with underscores (`snake_case`)

#### `dev` (Development)

Local development workspace for unpublished projects, experiments, and work-in-progress. Not shared with the registry.

```mizar
import dev.my_project.utils;
import dev.experiments.category_theory;
```

#### `ext` (External)

References to external repositories that are mirrored or vendored locally. Used for dependencies not published to the central registry.

```mizar
import ext.github.user.repo.module;
import ext.gitlab.org.project.submodule;
```

> [!NOTE]
> The `ext` root is intended for exceptional cases. Authors are encouraged to publish to `pkg` for discoverability and dependency resolution.

### 12.2.2 Mapping Files to Namespaces

The package manager maps these logical roots to physical paths. The logical namespace reflects the directory structure and file name exactly.

* **Format**: `<Root>.<Component>...<Name>`
* **Rule**:
  * The path separator `/` (or `\` on Windows) corresponds to the dot `.` in the namespace.
  * The `.miz` extension is omitted in the namespace identifier.

**Examples**:

| Logical Namespace | Physical Path (relative to root) |
| --- | --- |
| `std.algebra.linear.vector_space` | `std/algebra/linear/vector_space.miz` |
| `pub.jfm.pepin.jordan_curve` | `pub/jfm/pepin/jordan_curve.miz` |
| `pkg.mathcomp_mizar.algebra.ring` | `pkg/mathcomp_mizar/algebra/ring.miz` |
| `dev.my_project.utils` | `dev/my_project/utils.miz` |

## 12.3 Import Statements

The `import` statement declares a dependency on another module.

**Syntax (EBNF)**:

```ebnf
import_stmt       ::= "import" module_alias_decl { "," module_alias_decl } ";" ;
module_alias_decl ::= module_path [ "as" module_identifier ] ;
module_path       ::= [ relative_prefix ] module_identifier { "." module_identifier } ;
relative_prefix   ::= "." | ".." ;
module_identifier ::= identifier ;
```

### 12.3.1 Resolution Rules

1. **Absolute Import**:
  * `import std.algebra.group;`
  * Resolves to `<std_root>/algebra/group.miz`.
2. **Relative Import**:
  * `import .utils;` (Siblings: `./utils.miz`)
  * `import ..common;` (Parent: `../common.miz`)

### 12.3.2 Aliasing

Aliases provide short names for namespaces to avoid verbosity or collision.

```mizar
import std.algebra.group as Grp;
let G be Grp.Group;
```

### 12.3.3 Cyclic Imports

Cyclic dependencies (e.g., A imports B, B imports A) are **forbidden**. The dependency graph must be a Directed Acyclic Graph (DAG) to ensure decidability of the compilation order.

## 12.4 Export Statements

The `export` statement re-publishes imported symbols or namespaces, effectively making the current module a "facade" or "aggregate" module. This allows for creating "prelude" modules that aggregate common definitions.

**Syntax (EBNF)**:
  ```ebnf
  export_stmt ::= "export" module_path { "," module_path } ";" ;
  ```

* **Usage**: `export std.algebra.group;`

## 12.5 Visibility Control (Private/Public)

By default, all definitions and declarations are **public**. Visibility modifiers can restrict access to individual items, either at the top level or within definition blocks.

**Syntax (EBNF)**:
```ebnf
visibility        ::= "private" | "public" ;

(* Top-level declarations *)
top_level_decl    ::= [ visibility ] ( theorem_decl | scheme_decl | notation_decl ) ;

(* Items inside a definition block *)
definitional_item ::= [ visibility ] ( func_def | pred_def | mode_def | attr_def | struct_def ) ;
```

* **Public**: Part of the module's signature $\Sigma$. Accessible by importers.
* **Private**: Internal lemma or helper definition. Only visible within the file.

## 12.6 Logic Encoding and Separate Compilation

To avoid the performance degradation seen in monolithic libraries, Mizar adopts a **Separate Compilation** model.

### 12.6.1 Opaque Imports

When Module A imports Module B:

1. **No Re-verification**: The proofs in Module B are **not** re-checked.
2. **Signature Loading**: Only the logical signature and public theorems are loaded.

### 12.6.2 Symbol Mangling for ATPs

Identifiers are transformed into globally unique symbols for ATPs based on their FQN.

| Mizar Source | Logical Encoding (TPTP Example) |
| --- | --- |
| Namespace `std.algebra.group` | Prefix `std__algebra__group__` |
| Predicate `is_abelian` | `std__algebra__group__is_abelian` |

## 12.7 Complete Syntax (EBNF)

The following EBNF summarizes the module-level structure defined in this chapter.

```ebnf
compilation_unit   ::= { directive } { declaration } ;

directive          ::= import_stmt
                     | export_stmt ;

import_stmt        ::= "import" module_alias_decl { "," module_alias_decl } ";" ;
export_stmt        ::= "export" module_path { "," module_path } ";" ;

module_alias_decl  ::= module_path [ "as" module_identifier ] ;
module_path        ::= [ relative_prefix ] module_identifier { "." module_identifier } ;
relative_prefix    ::= "." | ".." ;
module_identifier  ::= identifier ;

(* Declaration Rules *)
declaration        ::= definition_block         (* Visibility is handled inside *)
                     | [ visibility ] theorem_decl
                     | [ visibility ] scheme_decl
                     | [ visibility ] notation_decl
                     | registration_block ;

visibility         ::= "private" | "public" ;

(* Definition Block Structure *)
definition_block   ::= "definition" { definition_content } "end" ";" ;

definition_content ::= parameter_decl           (* let ... *)
                     | assumption               (* assume ... *)
                     | [ visibility ] definitional_item ;

definitional_item  ::= func_def | pred_def | mode_def | attr_def | struct_def ;

(* Note: Specific syntax for func_def, theorem_decl, etc. is defined in subsequent chapters *)
```

## 12.8 Examples

### 12.8.1 Standard Library Module

**File**: `std/algebra/abelian_group.miz`

```mizar
:: Defines module: std.algebra.abelian_group

:: 1. Imports
import std.algebra.group as Grp;
import std.arithmetics.integers;

:: 2. Exports
export Grp;

:: 3. Private Lemma
private theorem CommutativityLemma:
  for a, b being Element of Grp.Group holds ...;

:: 4. Public Definition (Attribute)
definition
  let G be Grp.Group;
  attr G is abelian means
    for a, b being Element of G holds a * b = b * a;
end;

:: 5. Public Theorem
theorem AbelianProperties:
  for G being Grp.Group st G is abelian holds ...
  by CommutativityLemma;
```

### 12.8.2 Third-Party Package Module

**File**: `pkg/mathcomp_mizar/algebra/ring_extensions.miz`

```mizar
:: Defines module: pkg.mathcomp_mizar.algebra.ring_extensions

:: Imports from standard library and JFM
import std.algebra.ring;
import pub.jfm.trybulec.polynomial_ring;

:: Imports from same package
import .ring_morphisms;

definition
  let R, S be Ring;
  mode RingExtension of R, S is ...;
end;
```

### 12.8.3 Development Module

**File**: `dev/my_research/experimental_lattice.miz`

```mizar
:: Defines module: dev.my_research.experimental_lattice

import std.algebra.lattice;
import pkg.mathcomp_mizar.algebra.ring_extensions;

:: Experimental definitions, not yet ready for publication
private func experimental_closure(L) -> Lattice means ...;

theorem ExperimentalResult:
  ...;
```