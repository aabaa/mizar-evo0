# 8. Type Inference

- [8. Type Inference](#8-type-inference-and-conversion)
  - [8.1 Basic Type Inference](#81-basic-type-inference)
  - [8.2 Type Conversion](#82-type-conversion)
  - [8.3 Type Checking Process](#83-type-checking-process)
  - [8.4 Logic Encoding Details](#84-logic-encoding-details)
  - [8.5 Complete Syntax (EBNF)](#85-complete-syntax-ebnf)

## 8.1 Basic Type Inference

Type inference is based on inheritance, attribute clusters, and structural compatibility.

```mizar
let G be Group;
reconsider M = G as Magma;  :: Group is inferred to be a Magma
```

The inference engine is invoked in the following contexts:

| Context | Description |
| --- | --- |
| `let` declarations | Infers variable types from mode definitions |
| `reconsider` | Validates type conversion with proof obligations |
| `consider` | Verifies type constraints for existential choice |
| `given` | Introduces types for existential assumptions |
| `take` | Checks witness types in existential proofs |
| Mode applications | Resolves parameterized types |
| Functor applications | Validates argument types and infers return types |
| Attribute testing | Checks attribute membership via clusters |

## 8.2 Type Conversion

Two kinds of conversions are supported: implicit (automatic) and explicit (user-specified).

**Syntax (EBNF)**:

```ebnf
qua_expression      ::= "(" term_expression "qua" type_expression ")" ;
reconsider_stmt     ::= "reconsider" reconsider_item "as" type_expression
                        [ simple_justification ] ";" ;
reconsider_item     ::= identifier | identifier "=" term_expression ;
simple_justification ::= "by" references ;  (* can be omitted entirely *)
references          ::= reference { "," reference } ;
justification       ::= simple_justification | proof_block ;  (* see Chapter 17 *)
```

> [!NOTE]
> See also **Chapter 4 (Variables and Constants)** for additional `reconsider` usage context.

### 8.2.1 Implicit Conversion (Widening)

Automatically applied by the verifier when a subtype is used where a supertype is expected:

* **Upcasting**: e.g., `Group` → `Magma`, `Prime` → `Integer`
* **Attribute implications**: via cluster registrations
* **Mode/structure-based compatibility**: structural subtyping

**Example**:

```mizar
let n be Prime;
:: n can be used where Integer is expected (implicit widening)
let m be Integer;
reconsider m = n as Integer;  :: explicit, but no proof needed
```

### 8.2.2 Explicit Conversion

#### `qua` Operator (Up-cast / View)

The `qua` operator accesses a value as a **supertype** or **compatible structural type**. It does not require justification because it only provides a restricted view of the term without claiming additional properties.

**Characteristics**:
- **No justification required**: `qua` is implicit up-cast only
- **No new binding created**: The original term is accessed through a type-restricted view
- **Use case**: Disambiguate field/property access in multiple inheritance

```mizar
let R be DoubleLoopStr;
(R qua AddLoopStr) is associative;  :: View R as AddLoopStr
(R qua MulLoopStr) is commutative;  :: View R as MulLoopStr
```

> [!NOTE]
> `qua` cannot be used for down-casting (narrowing to a more specific type). Use `reconsider` for that purpose.

#### `reconsider` Statement (Narrowing / Down-cast)

Required when converting to a more specific type. Generates proof obligations.

**`reconsider` statement**: Declares a new variable with a different type, or reinterprets an existing variable, requiring justification.

**Form 1: With new binding**:
```mizar
let x be Real;
assume x >= 0;
reconsider y = x as non negative Real by assumption;
```

**Form 2: Reinterpret existing variable**:
```mizar
let n be Integer;
assume n >= 0;
reconsider n as Nat by A1;  :: Same variable, narrower type
```

**Form 3: With proof block**:
```mizar
let f be Function;
reconsider g = f as Bijection
proof
  thus f is one-to-one & f is onto by ...;
end;
```

**Attributed type narrowing**:
```mizar
let S be set;
assume S <> {};
reconsider S as non empty set by assumption;

let G be Magma;
assume G is associative & G is unital & G is invertible;
reconsider H = G as Group by A1, A2, A3;
```

### 8.2.3 Choosing Between `qua` and `reconsider`

| Scenario | Use | Example |
| --- | --- | --- |
| Access supertype fields/properties | `qua` | `(R qua AddLoopStr).zero` |
| Disambiguate inherited attributes | `qua` | `(R qua MulLoopStr) is commutative` |
| Narrow to subtype (with proof) | `reconsider` | `reconsider n as Prime by ...` |
| Add attributes (with proof) | `reconsider` | `reconsider S as non empty set by ...` |
| Create new typed binding | `reconsider` | `reconsider y = x as Nat by ...` |

## 8.3 Type Checking Process

The type checking process proceeds in the following order:

1. **Parse**: Extract type declarations and usage sites
2. **Resolve**: Apply mode definitions and attribute clusters
3. **Generate obligations**: Create proof goals for conversions
4. **Verify**: Discharge obligations using inference or explicit proofs
5. **Apply conversions**: Insert implicit/explicit casts

```
Declaration: let x be T
⇒  Assert: is_T(x)

Conversion: reconsider y = x as U
⇒  Goal: is_T(x) → is_U(x)
⇒  Proof required if not implied by clusters
```

## 8.4 Logic Encoding Details

This section describes how type inference and conversion map to First-Order Logic.

### 8.4.1 Type Assertions

Variable declarations generate type predicates:

| Mizar Source | FOL Encoding |
| --- | --- |
| `let x be Integer;` | `is_Integer(x)` |
| `let G be Group;` | `is_Group(G)` |

### 8.4.2 Widening (Implicit Conversion)

Widening relies on subtype axioms:

```
mode Prime is prime Integer
⇒  forall x (is_Prime(x) implies is_Integer(x))
```

When `Prime` is used where `Integer` is expected, the implication is applied automatically.

### 8.4.3 Narrowing (Explicit Conversion)

Narrowing generates proof obligations:

| Mizar Source | FOL Encoding |
| --- | --- |
| `reconsider y = x as Prime` | `Goal: is_Integer(x) ∧ is_prime(x)` |
| `(R qua AddLoopStr)` | `Assumption: is_AddLoopStr(R)` |

### 8.4.4 `qua` Operator Encoding

The `qua` operator creates a type-restricted view:

```
(x qua T).field
⇒  Precondition: is_T(x)
⇒  Access: field(x)
```

## 8.5 Complete Syntax (EBNF)

Summary of type inference and conversion syntax.

> [!NOTE]
> For advanced type conversion scenarios, including implicit conversions, overload resolution, and symbol redefinition, see **Chapter 22 (Type Conversion and Overload Resolution)**.

```ebnf
(* Explicit Conversion *)
qua_expression      ::= "(" term_expression "qua" type_expression ")" ;
reconsider_stmt     ::= "reconsider" reconsider_item "as" type_expression
                        [ simple_justification ] ";" ;
reconsider_item     ::= identifier | identifier "=" term_expression ;

(* Justification - see Chapter 17 for full details *)
simple_justification ::= "by" references ;  (* can be omitted entirely *)
references          ::= reference { "," reference } ;
justification       ::= simple_justification | proof_block ;  (* see Chapter 17/18 *)

(* Type Expression - see Chapter 3 *)
type_expression     ::= attribute_chain radix_type ;
attribute_chain     ::= { [ "non" ] attribute_ref } ;
attribute_ref       ::= [ param_prefix ] [ struct_name "." ] attribute_name ;
param_prefix        ::= parameter "-" | "(" parameter_list ")" "-" ;
radix_type          ::= builtin_type | mode_name [ type_args ] | struct_name [ type_args ] ;
```
