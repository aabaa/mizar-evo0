# 2. Lexical Structure

* [2. Lexical Structure](#2-lexical-structure)
  * [2.1 Character Set and Encoding](#21-character-set-and-encoding)
  * [2.2 Whitespace and Formatting](#22-whitespace-and-formatting)
  * [2.3 Tokens and Lexicon](#23-tokens-and-lexicon)
  * [2.4 Reserved Words](#24-reserved-words)
  * [2.5 Special Symbols](#25-special-symbols)
  * [2.6 Identifiers](#26-identifiers)
  * [2.7 Numerals and Literals](#27-numerals-and-literals)
  * [2.8 File and Module Naming](#28-file-and-module-naming)
  * [2.9 Comments and Annotations](#29-comments-and-annotations)
  * [2.10 Lexical Preprocessing](#210-lexical-preprocessing)


## 2.1 Character Set and Encoding

* **Encoding**: UTF-8
* **Code sections**: ASCII only (letters, digits, symbols)
* **Comments and annotations**: Full Unicode allowed, including Greek letters and LaTeX-style notation (e.g., `\alpha`)
* **Escape character**: Use `\` to escape special characters in string literals

## 2.2 Whitespace and Formatting

* Whitespace is not semantically significant (except within string literals).
* Use space, tab, newline for layout.
* **Recommendations**:
  * Indent consistently (2 or 4 spaces).
  * Limit line length to 100 characters.
  * Break long expressions after logical or arithmetic operators.


**Example**:

```mizar
theorem Pythagorean:
  for a, b, c being Real st a > 0 & b > 0 & c > 0 holds
  a^2 + b^2 = c^2 implies
  ex t being right Triangle st
    t.leg1 = a & t.leg2 = b & t.hypotenuse = c;
```

## 2.3 Tokens and Lexicon

The lexer processes the following token types:

* **Reserved words**: predefined keywords with fixed semantics
* **Special symbols**: punctuation, operator-like symbols, and template markers
* **Identifiers**: user-defined names
* **Numerals**: unsigned sequences of digits
* **String literals**: quoted sequences of characters

Lexical analysis is context-sensitive: imported modules can extend the active lexicon. In case of ambiguity, the lexer uses a **longest-match rule**.

## 2.4 Reserved Words

Reserved words are case-sensitive and may not be used as identifiers. The complete list is as follows:
*(Note: This list is provisional and subject to change)*

```mizar
according aggregate all and antonym are as associativity
assume asymmetry attr
be begin being by
canceled case cases cluster coherence commutativity
compatibility conjecture connectedness consider consistency
constructor contradiction correctness
def deffunc define definition definitions defpred do does
end equals ex exactly existence export extend
for from func
given
hence hereby holds
idempotence identify if iff implies import involutiveness
inherits irreflexivity is it let
means mode
non not notation notations now
of or otherwise over
per pred prefix projectivity proof provided private
qua
reconsider reduce reducibility redefine reflexivity registration
registrations requirements reserve
sch scheme schemes section selector set sethood st struct
such suppose symmetry synonym
take that the then theorem theorems thesis thus to
transitivity
uniqueness
vocabularies
when where with wrt
```

These words must be recognized as individual tokens, not as identifiers.

## 2.5 Special Symbols

Special symbols are non-alphanumeric characters or sequences with syntactic meaning. The complete list is:

```mizar
,   .   ;   :   (   )   [   ]   {   }   =   &   ->   .=   ...
```

* `,` `;` `:`: Delimiters
* `.`: Namespace separator or postfix dot notation
* `=` `.=`: Equality and stepwise transformation
* `->`: Function arrow
* `...`: Ellipsis

## 2.6 Identifiers

Identifiers are used for variables, types, and labels.

**Syntax(EBNF)**:

```ebnf
identifier = ( letter | "_" ) { letter | digit | "_" | "'" } ;
letter     = "a"..."z" | "A"..."Z" ;
digit      = "0"..."9" ;
```

* Must not match any reserved word.
* Case-sensitive.
* May override symbols (e.g., `id`) if they form a valid identifier.
* Shadowing follows scoping and longest-match precedence.

## 2.7 Numerals and Literals

* **Numerals**: Built-in representation of natural numbers.

  * **Syntax (EBNF)**:
    ```ebnf
    numeral = digit { digit } ;
    ```
  * Examples: `0`, `1`, `42`.

* **String Literals**: Used for file paths, directives, or external tool configurations.
  * **Syntax (EBNF)**:
    ```ebnf
    string_literal = '"' { character } '"' ;
    ```
  * Escaping: `\"` for quote, `\\` for backslash.
  * Examples: `"mml/algebra/group"`, `"C:\\Mizar"`.

* **Other literals**: No built-in support; booleans, floats, etc., must be encoded as terms in the library.

## 2.8 File and Module Naming

* Files must end with `.miz`
* Each file defines one module; module name = file name (sans extension)
* The directory path determines the namespace

* **Example**:
  ```
  File path: /mml/algebra/group.miz
  Module name: group
  Namespace: mml.algebra.group
  ```

## 2.9 Comments and Annotations

### 2.9.1 Comment Types

* **Single-line**: Begins with `::`
  ```mizar
  :: This is a single-line comment
  ```

* **Multi-line**: Between `::=` and `=::`
  ```mizar
  ::=
  This is a multi-line comment
  It may contain LaTeX: $E = mc^2$
  =::
  ```

* **Documentation**: Begins with `:::`
  ```mizar
  ::: Pythagorean theorem: $a^2 + b^2 = c^2$
  theorem Pythagorean:
  ```

### 2.9.2 Annotations

* Begin with `@`, used for metadata or parser hints
  ```mizar
  ::: @proof-sketch This proof proceeds by induction on $n$
  @symbol_precedence(*, 100, left_associative)
  ```

## 2.10 Lexical Preprocessing

* Comments are removed before parsing.
* Imports are resolved before tokenization; imported symbols affect lexing.
* Token recognition depends on the currently active lexicon.
* The lexer uses a **longest-match rule** among all known symbols.

**Example**:

Suppose the following operators are defined in module `A`:

```mizar
definition
  let x, y be Real;
  func x +* y -> Real means ...;
  func x *+ y -> Real means ...;
  func x +*+ y -> Real means ...;
end
```

Then in another file:

```mizar
import A;
let x, y be Real;

x +* y;     :: parsed as `+*` (Symbol from A)
x *+ y;     :: parsed as `*+` (Symbol from A)
x +*+ y;    :: parsed as `+*+` (Symbol from A)
x + *+ y;   :: parsed as `+` (Standard) and `*+` (Symbol from A)
```

This example illustrates how the longest-match rule and import-sensitive context influence lexical analysis.
